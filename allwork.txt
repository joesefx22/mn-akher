{
  "name": "sport-fields-booking",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "db:generate": "prisma generate",
    "db:push": "prisma db push",
    "db:migrate": "prisma migrate dev",
    "db:studio": "prisma studio",
    "db:seed": "tsx prisma/seed.ts",
    "typecheck": "tsc --noEmit",
    "fix": "rm -rf node_modules/.prisma node_modules/@prisma && npx prisma generate",
    "clean": "rm -rf node_modules .next .turbo"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.3.2",
    "@prisma/client": "^5.22.0",
    "@tailwindcss/aspect-ratio": "^0.4.2",
    "@tailwindcss/forms": "^0.5.11",
    "@tailwindcss/typography": "^0.5.19",
    "@upstash/redis": "^1.36.1",
    "axios": "^1.6.2",
    "bcryptjs": "^2.4.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^3.6.0",
    "dotenv": "^16.4.1",
    "jose": "^5.6.3",
    "lucide-react": "^0.344.0",
    "next": "14.2.5",
    "next-auth": "4.24.7",
    "nodemailer": "^6.9.10",
    "pino": "^9.3.1",
    "pino-pretty": "^10.3.1",
    "rate-limiter-flexible": "^5.0.5",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-hook-form": "^7.51.3",
    "react-hot-toast": "^2.4.1",
    "react-icons": "^5.0.1",
    "tailwind-merge": "^2.2.1",
    "tailwindcss-animate": "^1.0.7",
    "uuid": "^9.0.1",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/node": "^20.19.29",
    "@types/nodemailer": "^6.4.14",
    "@types/react": "^18.2.56",
    "@types/react-dom": "^18.2.19",
    "@types/uuid": "^9.0.8",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.56.0",
    "eslint-config-next": "14.2.5",
    "postcss": "^8.4.33",
    "prisma": "^5.22.0",
    "tailwindcss": "^3.4.1",
    "ts-node": "^10.9.2",
    "tsx": "^4.7.0",
    "typescript": "^5.9.3"
  },
  "engines": {
    "node": ">=18.17.0"
  },
  "prisma": {
    "seed": "tsx prisma/seed.ts"
  }
}
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//////////////////// ENUMS ////////////////////

enum Role {
  PLAYER
  OWNER
  EMPLOYEE
  ADMIN
}

enum SkillLevel {
  WEAK
  AVERAGE
  GOOD
  EXCELLENT
  LEGENDARY
}

enum FieldType {
  FOOTBALL
  PADEL
  TENNIS
  BASKETBALL
  SWIMMING
}

enum FieldStatus {
  OPEN
  CLOSED
  MAINTENANCE
  UNDER_CONSTRUCTION
}

enum SlotStatus {
  AVAILABLE
  NEEDS_CONFIRMATION
  TEMP_LOCKED
  BOOKED
  UNAVAILABLE
  CANCELLED
}

enum BookingStatus {
  DRAFT
  PENDING_CONFIRMATION
  CONFIRMED
  CANCELLED
  FAILED
  EXPIRED
  PENDING_PAYMENT
  COMPLETED
}

enum PaymentStatus {
  PENDING
  PROCESSING
  PAID
  FAILED
  REFUNDED
  PARTIALLY_REFUNDED
  CANCELLED
}

enum NotificationType {
  SYSTEM
  BOOKING_CREATED
  BOOKING_CONFIRMED
  BOOKING_CANCELLED
  BOOKING_EXPIRED
  PAYMENT_INITIATED
  PAYMENT_SUCCESS
  PAYMENT_FAILED
  PAYMENT_REFUNDED
  SLOT_LOCKED
  SLOT_RELEASED
  USER_WELCOME
  PASSWORD_RESET
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  REGISTER
  PASSWORD_CHANGE
  PROFILE_UPDATE
}

//////////////////// USER ////////////////////

model User {
  // === Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ===
  id            String   @id @default(cuid())
  
  // === Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø´Ø®ØµÙŠØ© ===
  name          String
  email         String   @unique
  passwordHash  String?
  phoneNumber   String?  @unique
  dateOfBirth   DateTime?
  avatarUrl     String?
  bio           String?  @db.Text
  age           Int?
  description   String?  @db.Text
  
  // === Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª ===
  skillLevel    SkillLevel @default(AVERAGE)
  preferredPositions String[]
  
  // === Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª ===
  role          Role @default(PLAYER)
  roleUpdatedAt DateTime?  // âœ… Ù…ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„ÙƒÙˆØ¯ (app/api/auth/register/route.ts)
  
  // === Ø§Ù„Ø£Ù…Ø§Ù† ÙˆØ§Ù„Ù…ØµØ§Ø¯Ù‚Ø© ===
  emailVerified Boolean   @default(false)
  emailVerifiedAt DateTime?
  isVerified     Boolean   @default(false)  // âœ… Ù…ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„ÙƒÙˆØ¯ (app/api/auth/me/route.ts)
  isActive      Boolean   @default(true)
  lastLoginAt   DateTime?  // âœ… Ù…ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„ÙƒÙˆØ¯ (app/api/auth/me/route.ts)
  loginAttempts Int       @default(0)
  lockedUntil   DateTime?
  
  // === Ø§Ù„Ø·ÙˆØ§Ø¨Ø¹ Ø§Ù„Ø²Ù…Ù†ÙŠØ© ===
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  deletedAt     DateTime?
  
  // === Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª ===
  slotsLocked   Slot[]    @relation("SlotLockedByUser")
  payments      Payment[]
  bookings      Booking[]
  notifications Notification[]
  reviews       Review[]
  idempotencyKeys IdempotencyKey[]
  auditLogs     AuditLog[]
  flaggedUsers  FlaggedUser[]
  
  // === Ø§Ù„ÙÙ‡Ø§Ø±Ø³ ===
  @@index([email, isActive])
  @@index([role, isActive])
  @@index([createdAt])
  @@map("users")
}

//////////////////// FIELD ////////////////////

model Field {
  // === Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ===
  id          String   @id @default(cuid())
  
  // === Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ===
  name        String
  description String?  @db.Text
  location    String
  address     String
  coordinates String?
  
  // === Ø§Ù„Ù†ÙˆØ¹ ÙˆØ§Ù„ÙˆØ³Ø§Ø¦Ø· ===
  type        FieldType
  mainImage   String?  // âœ… Ø§Ø³Ù… Ù…ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„Ù…Ø®Ø·Ø·
  imageUrl    String?  // âœ… Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù‚Ø¯ÙŠÙ…
  gallery     String[]
  
  // === Ø§Ù„ØªØ³Ø¹ÙŠØ± ===
  pricePerHour    Decimal @db.Decimal(10, 2)
  depositAmount   Decimal @db.Decimal(10, 2) @default(0)
  depositPrice    Decimal @db.Decimal(10, 2) @default(0)  // âœ… Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„ÙƒÙˆØ¯
  currency        String  @default("EGP")
  
  // === Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠ ===
  openingTime     String  @default("08:00")
  closingTime     String  @default("22:00")
  slotDuration    Int     @default(60)
  slotDurationMin Int     @default(60)  // âœ… Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„ÙƒÙˆØ¯
  
  // === Ø§Ù„Ø­Ø§Ù„Ø© ÙˆØ§Ù„Ù…Ø±Ø§ÙÙ‚ ===
  status          FieldStatus @default(OPEN)
  facilities      String[]
  capacity        Int?
  
  // === Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø§Ù„Ùƒ ===
  ownerId         String?
  ownerEmail      String?
  ownerPhone      String?
  
  // === Ø§Ù„Ø·ÙˆØ§Ø¨Ø¹ Ø§Ù„Ø²Ù…Ù†ÙŠØ© ===
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // === Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª ===
  slots    Slot[]
  bookings Booking[]
  reviews  Review[]
  
  // === Ø§Ù„ÙÙ‡Ø§Ø±Ø³ ===
  @@index([location])
  @@index([type, status])
  @@index([pricePerHour])
  @@map("fields")
}

//////////////////// SLOT ////////////////////

model Slot {
  // === Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ===
  id      String   @id @default(cuid())
  
  // === Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ù…Ø¹ Ø§Ù„Ù…Ù„Ø¹Ø¨ ===
  fieldId String
  field   Field  @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  
  // === Ø§Ù„ØªÙˆÙ‚ÙŠØª ===
  startTime   DateTime
  endTime     DateTime
  duration    Int     @default(60)  // âœ… Ù…ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„Ù…Ø®Ø·Ø·
  durationMinutes Int @default(60)  // âœ… Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„ÙƒÙˆØ¯
  
  // === Ø§Ù„ØªØ³Ø¹ÙŠØ± ===
  price       Decimal @db.Decimal(10, 2)
  deposit     Decimal @db.Decimal(10, 2) @default(0)
  
  // === Ø§Ù„Ø­Ø§Ù„Ø© ÙˆØ§Ù„Ù‚ÙÙ„ ===
  status      SlotStatus @default(AVAILABLE)
  lockedUntil DateTime?
  lockedById  String?
  lockedBy    User?     @relation("SlotLockedByUser", fields: [lockedById], references: [id], onDelete: SetNull)
  lockedByUser User?    @relation("SlotLockedByUser", fields: [lockedById], references: [id], onDelete: SetNull)  // âœ… alias
  
  // === Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆØµÙÙŠØ© ===
  isPeakHour  Boolean @default(false)
  discount    Decimal @db.Decimal(5, 2) @default(0)
  
  // === Ø§Ù„Ø·ÙˆØ§Ø¨Ø¹ Ø§Ù„Ø²Ù…Ù†ÙŠØ© ===
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // === Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª ===
  bookings Booking[]
  
  // === Ø§Ù„Ù‚ÙŠÙˆØ¯ ÙˆØ§Ù„ÙÙ‡Ø§Ø±Ø³ ===
  @@unique([fieldId, startTime])
  @@index([status, lockedUntil])
  @@index([startTime, endTime])
  @@index([fieldId, status])
  @@map("slots")
}

//////////////////// BOOKING ////////////////////

model Booking {
  // === Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ===
  id String @id @default(cuid())
  
  // === Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ù…Ø¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ===
  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // === Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ù…Ø¹ Ø§Ù„Ù…Ù„Ø¹Ø¨ ===
  fieldId String
  field   Field @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  
  // === Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ù…Ø¹ Ø§Ù„Ù…ÙŠØ¹Ø§Ø¯ ===
  slotId String
  slot   Slot @relation(fields: [slotId], references: [id], onDelete: Cascade)
  
  // === Ø§Ù„Ø­Ø§Ù„Ø© ===
  status        BookingStatus @default(DRAFT)
  paymentStatus PaymentStatus @default(PENDING)
  
  // === Ø§Ù„ØªØ³Ø¹ÙŠØ± ===
  totalAmount   Decimal @db.Decimal(10, 2)
  amountPaid    Decimal @db.Decimal(10, 2) @default(0)
  depositPaid   Decimal @db.Decimal(10, 2) @default(0)
  
  // === Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¯ÙØ¹ ÙˆØ§Ù„Ø·Ù„Ø¨ ===
  orderId       String? @unique
  paymentId     String? @unique
  gateway       String?
  
  // === Ø§Ù„ØªÙˆÙ‚ÙŠØª ===
  expiresAt       DateTime?
  confirmedAt     DateTime?
  cancelledAt     DateTime?
  completedAt     DateTime?
  
  // === Idempotency ÙˆØ§Ù„ØªØªØ¨Ø¹ ===
  idempotencyKey String? @unique
  ipAddress      String?
  userAgent      String?
  
  // === Ø§Ù„Ø·ÙˆØ§Ø¨Ø¹ Ø§Ù„Ø²Ù…Ù†ÙŠØ© ===
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // === Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª ===
  payments      Payment[]
  notifications Notification[]
  reviews       Review[]
  
  // === Ø§Ù„ÙÙ‡Ø§Ø±Ø³ ===
  @@index([userId, status])
  @@index([slotId, status])
  @@index([orderId])
  @@index([createdAt])
  @@index([expiresAt])
  @@map("bookings")
}

//////////////////// PAYMENT ////////////////////

model Payment {
  // === Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ===
  id String @id @default(cuid())
  
  // === Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª ===
  bookingId String
  booking   Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  
  userId    String
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // === Ø§Ù„Ù…Ø¨Ù„Øº ÙˆØ§Ù„Ø¹Ù…Ù„Ø© ===
  amount      Decimal @db.Decimal(10, 2)
  currency    String  @default("EGP")
  feeAmount   Decimal @db.Decimal(10, 2) @default(0)
  netAmount   Decimal @db.Decimal(10, 2)
  
  // === Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨ÙˆØ§Ø¨Ø© ===
  gateway       String
  gatewayId     String? @unique
  orderId       String? @unique
  transactionId String? @unique
  paymentId     String? @unique
  
  // === Ø§Ù„Ø­Ø§Ù„Ø© ===
  status      PaymentStatus @default(PENDING)
  refundedAmount Decimal @db.Decimal(10, 2) @default(0)
  
  // === Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆØµÙÙŠØ© ===
  metadata    Json?
  receiptUrl  String?
  errorMessage String?
  
  // === Ø§Ù„Ø·ÙˆØ§Ø¨Ø¹ Ø§Ù„Ø²Ù…Ù†ÙŠØ© ===
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  paidAt      DateTime?
  refundedAt  DateTime?
  
  // === Ø§Ù„ÙÙ‡Ø§Ø±Ø³ ===
  @@index([bookingId])
  @@index([userId])
  @@index([gatewayId])
  @@index([status, createdAt])
  @@map("payments")
}

//////////////////// NOTIFICATION ////////////////////

model Notification {
  // === Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ===
  id        String   @id @default(cuid())
  
  // === Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª ===
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  bookingId String?
  booking   Booking? @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  
  // === Ø§Ù„Ù…Ø­ØªÙˆÙ‰ ===
  type    NotificationType
  title   String
  message String  @db.Text
  data    Json?
  
  // === Ø§Ù„Ø­Ø§Ù„Ø© ===
  isRead    Boolean   @default(false)
  isSent    Boolean   @default(true)
  sentAt    DateTime  @default(now())
  
  // === Ø§Ù„Ù‚Ù†ÙˆØ§Øª ===
  sentVia   String[]
  
  // === Ø§Ù„Ø·ÙˆØ§Ø¨Ø¹ Ø§Ù„Ø²Ù…Ù†ÙŠØ© ===
  createdAt DateTime @default(now())
  readAt    DateTime?
  
  // === Ø§Ù„ÙÙ‡Ø§Ø±Ø³ ===
  @@index([userId, isRead])
  @@index([bookingId])
  @@index([type, createdAt])
  @@map("notifications")
}

//////////////////// REVIEW ////////////////////

model Review {
  // === Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ===
  id        String   @id @default(cuid())
  
  // === Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª ===
  fieldId   String
  field     Field    @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  bookingId String?
  booking   Booking? @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  
  // === Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø© ===
  rating    Int      @default(5)
  title     String?
  comment   String?  @db.Text
  
  // === Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆØµÙÙŠØ© ===
  isVerified Boolean @default(false)
  helpfulVotes Int    @default(0)
  
  // === Ø§Ù„Ø·ÙˆØ§Ø¨Ø¹ Ø§Ù„Ø²Ù…Ù†ÙŠØ© ===
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // === Ø§Ù„Ù‚ÙŠÙˆØ¯ ÙˆØ§Ù„ÙÙ‡Ø§Ø±Ø³ ===
  @@unique([fieldId, userId, bookingId])
  @@index([fieldId, rating])
  @@index([userId])
  @@index([createdAt])
  @@map("reviews")
}

//////////////////// IDEMPOTENCY KEY ////////////////////

model IdempotencyKey {
  // === Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ===
  id          String   @id @default(cuid())
  
  // === Ø§Ù„Ù…ÙØªØ§Ø­ ÙˆØ§Ù„Ù…Ø³ØªØ®Ø¯Ù… ===
  key         String
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // === Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø·Ù„Ø¨ ===
  requestHash String
  method      String
  path        String  // âœ… Ù…ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„ÙƒÙˆØ¯ (idempotency-guard.ts)
  response    Json?
  
  // === Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© ===
  expiresAt   DateTime
  
  // === Ø§Ù„Ø·ÙˆØ§Ø¨Ø¹ Ø§Ù„Ø²Ù…Ù†ÙŠØ© ===
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // === Ø§Ù„Ù‚ÙŠÙˆØ¯ ===
  @@unique([key, userId])
  @@index([expiresAt])
  @@map("idempotency_keys")
}

//////////////////// AUDIT LOG ////////////////////

model AuditLog {
  // === Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ===
  id String @id @default(cuid())
  
  // === Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ===
  userId String?
  user   User? @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  // === ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ ===
  action     AuditAction
  entityType String?
  entityId   String?
  
  // === Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª ===
  oldData    Json?
  newData    Json?
  
  // === Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø·Ù„Ø¨ ===
  ipAddress  String?
  userAgent  String?
  endpoint   String?
  
  // === Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆØµÙÙŠØ© ===
  success    Boolean @default(true)
  errorMessage String?
  
  // === Ø§Ù„Ø·ÙˆØ§Ø¨Ø¹ Ø§Ù„Ø²Ù…Ù†ÙŠØ© ===
  createdAt DateTime @default(now())
  
  // === Ø§Ù„ÙÙ‡Ø§Ø±Ø³ ===
  @@index([userId, createdAt])
  @@index([action, entityType])
  @@index([createdAt])
  @@map("audit_logs")
}

//////////////////// FLAGGED USER ////////////////////

model FlaggedUser {
  // === Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ===
  id     String @id @default(cuid())
  
  // === Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ===
  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // === ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¹Ù„Ù… ===
  reason    String   @db.Text
  category  String
  severity  String   @default("MEDIUM")
  
  // === Ø§Ù„Ø­Ù„ ===
  resolved   Boolean  @default(false)
  resolvedAt DateTime?
  resolvedBy String?
  resolutionNote String? @db.Text
  
  // === Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ© ===
  expiresAt DateTime?
  
  // === Ø§Ù„Ø·ÙˆØ§Ø¨Ø¹ Ø§Ù„Ø²Ù…Ù†ÙŠØ© ===
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // === Ø§Ù„ÙÙ‡Ø§Ø±Ø³ ===
  @@index([userId, resolved])
  @@index([severity, createdAt])
  @@map("flagged_users")
}
// lib/shared/rate-limit/index.ts
export class RateLimitService {
  private requests = new Map<string, { count: number; resetTime: number }>();

  check(key: string, limit: number, windowMs: number): boolean {
    const now = Date.now();
    const record = this.requests.get(key);

    if (!record || now > record.resetTime) {
      // New window
      this.requests.set(key, {
        count: 1,
        resetTime: now + windowMs
      });
      return true;
    }

    if (record.count >= limit) {
      return false;
    }

    record.count++;
    return true;
  }
}

export const rateLimitService = new RateLimitService();
// lib/shared/logger/index.ts
import pino from 'pino'

// Ø¥Ù†Ø´Ø§Ø¡ logger Ø£Ø³Ø§Ø³ÙŠ
export const logger = pino({
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  transport: {
    target: 'pino-pretty',
    options: {
      colorize: true,
      translateTime: 'HH:MM:ss',
      ignore: 'pid,hostname'
    }
  }
})

// Loggers Ù…ØªØ®ØµØµØ©
export const authLogger = logger.child({ module: 'auth' })
export const bookingLogger = logger.child({ module: 'booking' })
export const paymentLogger = logger.child({ module: 'payment' })
export const apiLogger = logger.child({ module: 'api' })
export const cronLogger = logger.child({ module: 'cron' })

// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„Ù€ console.log ÙÙŠ development
export const devLogger = {
  log: (...args: any[]) => {
    if (process.env.NODE_ENV !== 'production') {
      console.log('[DEV]', ...args)
    }
  },
  error: (...args: any[]) => {
    if (process.env.NODE_ENV !== 'production') {
      console.error('[DEV ERROR]', ...args)
    }
  },
  warn: (...args: any[]) => {
    if (process.env.NODE_ENV !== 'production') {
      console.warn('[DEV WARN]', ...args)
    }
  }
}
// lib/shared/helpers/index.ts
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

// 1. Utility Functions
export function cn(...classes: (string | undefined | null | false)[]) {
  return classes.filter(Boolean).join(" ");
}

export function cnMerge(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

// 2. Formatting Functions
export function formatDate(date: Date | string): string {
  const d = new Date(date)
  return d.toLocaleDateString('ar-EG', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  })
}

export function formatRole(role: string): string {
  const roleMap: Record<string, string> = {
    PLAYER: 'ğŸ® Ù„Ø§Ø¹Ø¨',
    OWNER: 'ğŸŸï¸ Ù…Ø§Ù„Ùƒ Ù…Ù„Ø¹Ø¨',
    EMPLOYEE: 'ğŸ‘¨â€ğŸ’¼ Ù…ÙˆØ¸Ù',
    ADMIN: 'ğŸ›¡ï¸ Ù…Ø¯ÙŠØ±'
  }
  return roleMap[role] || role
}

export function formatSkillLevel(skillLevel: string): string {
  const skillMap: Record<string, string> = {
    WEAK: 'Ø¶Ø¹ÙŠÙ ğŸ˜…',
    AVERAGE: 'Ù…ØªÙˆØ³Ø· ğŸ˜Š',
    GOOD: 'Ø¬ÙŠØ¯ ğŸ˜',
    EXCELLENT: 'Ù…Ù…ØªØ§Ø² ğŸ”¥',
    LEGENDARY: 'Ø£Ø³Ø·ÙˆØ±ÙŠ ğŸ‘‘'
  }
  return skillMap[skillLevel] || skillLevel
}

export function truncateText(text: string, maxLength: number = 50): string {
  if (text.length <= maxLength) return text
  return text.substring(0, maxLength) + '...'
}

export function formatNumber(num: number): string {
  if (num >= 1000000) {
    return (num / 1000000).toFixed(1) + ' Ù…Ù„ÙŠÙˆÙ†'
  }
  if (num >= 1000) {
    return (num / 1000).toFixed(1) + ' Ø£Ù„Ù'
  }
  return num.toString()
}

export function formatCurrency(amount: number): string {
  return amount.toLocaleString('ar-EG') + ' Ø¬.Ù…'
}

export function getTimeAgo(date: Date | string): string {
  const now = new Date()
  const past = new Date(date)
  const diffMs = now.getTime() - past.getTime()
  const diffMins = Math.floor(diffMs / 60000)
  const diffHours = Math.floor(diffMs / 3600000)
  const diffDays = Math.floor(diffMs / 86400000)

  if (diffMins < 1) return 'Ø§Ù„Ø¢Ù†'
  if (diffMins < 60) return `Ù‚Ø¨Ù„ ${diffMins} Ø¯Ù‚ÙŠÙ‚Ø©`
  if (diffHours < 24) return `Ù‚Ø¨Ù„ ${diffHours} Ø³Ø§Ø¹Ø©`
  if (diffDays < 30) return `Ù‚Ø¨Ù„ ${diffDays} ÙŠÙˆÙ…`
  if (diffDays < 365) return `Ù‚Ø¨Ù„ ${Math.floor(diffDays / 30)} Ø´Ù‡Ø±`
  return `Ù‚Ø¨Ù„ ${Math.floor(diffDays / 365)} Ø³Ù†Ø©`
}

export function getInitials(name: string): string {
  return name
    .split(' ')
    .map(word => word.charAt(0))
    .join('')
    .toUpperCase()
    .slice(0, 2)
}

// 3. Validation Functions
export function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  return emailRegex.test(email)
}

export function isValidPhone(phone: string): boolean {
  const phoneRegex = /^(\+?\d{1,3}[-.\s]?)?\(?\d{1,4}\)?[-.\s]?\d{1,4}[-.\s]?\d{1,9}$/
  return phoneRegex.test(phone.replace(/\s/g, ''))
}

// 4. Math & Calculation Functions
export function calculateAge(birthYear: number): number {
  const currentYear = new Date().getFullYear()
  return currentYear - birthYear
}

export function getGradientColor(level: string): string {
  const gradientMap: Record<string, string> = {
    WEAK: 'from-gray-400 to-gray-500',
    AVERAGE: 'from-blue-400 to-blue-500',
    GOOD: 'from-green-400 to-green-500',
    EXCELLENT: 'from-purple-400 to-purple-500',
    LEGENDARY: 'from-orange-400 to-orange-500'
  }
  return gradientMap[level] || 'from-gray-400 to-gray-500'
}

// 5. Helper Functions
export function generateRandomId(length: number = 8): string {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'
  let result = ''
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length))
  }
  return result
}

export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout
  
  return (...args: Parameters<T>) => {
    clearTimeout(timeout)
    timeout = setTimeout(() => func(...args), wait)
  }
}

// 6. Constants (Ù…Ù† Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø¢Ø®Ø±)
export const ROLES = {
  PLAYER: 'PLAYER',
  OWNER: 'OWNER',
  EMPLOYEE: 'EMPLOYEE',
  ADMIN: 'ADMIN'
} as const

export const TOKEN_TYPES = {
  EMAIL_VERIFICATION: 'EMAIL_VERIFICATION',
  PASSWORD_RESET: 'PASSWORD_RESET',
  REFRESH_TOKEN: 'REFRESH_TOKEN'
} as const

export const AUDIT_ACTIONS = {
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT',
  REGISTER: 'REGISTER',
  UPDATE_PROFILE: 'UPDATE_PROFILE',
  CHANGE_PASSWORD: 'CHANGE_PASSWORD',
  VERIFY_EMAIL: 'VERIFY_EMAIL',
  RESET_PASSWORD: 'RESET_PASSWORD',
  DELETE_ACCOUNT: 'DELETE_ACCOUNT'
} as const

export const ERROR_CODES = {
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  AUTHENTICATION_ERROR: 'AUTHENTICATION_ERROR',
  AUTHORIZATION_ERROR: 'AUTHORIZATION_ERROR',
  NOT_FOUND: 'NOT_FOUND',
  CONFLICT: 'CONFLICT',
  RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',
  TOKEN_EXPIRED: 'TOKEN_EXPIRED',
  INVALID_TOKEN: 'INVALID_TOKEN',
  SERVER_ERROR: 'SERVER_ERROR'
} as const

export const PASSWORD_POLICY = {
  MIN_LENGTH: 8,
  REQUIRE_UPPERCASE: true,
  REQUIRE_LOWERCASE: true,
  REQUIRE_NUMBER: true,
  REQUIRE_SPECIAL_CHAR: true
} as const

export const RATE_LIMITS = {
  LOGIN: {
    WINDOW_MS: 15 * 60 * 1000,
    MAX_ATTEMPTS: 5
  },
  REGISTER: {
    WINDOW_MS: 60 * 60 * 1000,
    MAX_ATTEMPTS: 3
  },
  FORGOT_PASSWORD: {
    WINDOW_MS: 60 * 60 * 1000,
    MAX_ATTEMPTS: 3
  }
} as const

// Types
export type RoleType = typeof ROLES[keyof typeof ROLES]
export type TokenType = typeof TOKEN_TYPES[keyof typeof TOKEN_TYPES]
export type ErrorCode = typeof ERROR_CODES[keyof typeof ERROR_CODES]
// lib/shared/helpers/api-auth.ts
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'

/**
 * =========================
 * Custom Auth Errors
 * =========================
 */

export class AuthError extends Error {
  status: number
  code: string

  constructor(
    message: string = 'ØºÙŠØ± Ù…ØµØ±Ø­',
    status: number = 401,
    code: string = 'UNAUTHORIZED'
  ) {
    super(message)
    this.name = 'AuthError'
    this.status = status
    this.code = code
  }
}

export class PermissionError extends Error {
  status = 403
  code = 'FORBIDDEN'

  constructor(message: string = 'ØµÙ„Ø§Ø­ÙŠØ© ØºÙŠØ± ÙƒØ§ÙÙŠØ©') {
    super(message)
    this.name = 'PermissionError'
  }
}

export class AccountError extends Error {
  status = 403
  code = 'ACCOUNT_INACTIVE'

  constructor(message: string = 'Ø§Ù„Ø­Ø³Ø§Ø¨ ØºÙŠØ± Ù†Ø´Ø·') {
    super(message)
    this.name = 'AccountError'
  }
}

/**
 * =========================
 * Core Guards
 * =========================
 */

// Ù„Ø§Ø²Ù… ÙŠÙƒÙˆÙ† Ø¹Ø§Ù…Ù„ Login
export async function requireAuth() {
  const session = await getServerSession(authOptions)

  if (!session) {
    throw new AuthError()
  }

  return session
}

// Ù„Ø§Ø²Ù… ÙŠÙƒÙˆÙ† Role Ù…Ø¹ÙŠÙ†
export function requireRole(
  session: Awaited<ReturnType<typeof requireAuth>>,
  allowedRoles: string[]
) {
  if (!allowedRoles.includes(session.user.role)) {
    throw new PermissionError()
  }
}

// Ø§Ù„Ø­Ø³Ø§Ø¨ Ù„Ø§Ø²Ù… ÙŠÙƒÙˆÙ† Active
export function requireActiveAccount(
  session: Awaited<ReturnType<typeof requireAuth>>
) {
  if (session.user.isActive === false) {
    throw new AccountError()
  }
}

/**
 * =========================
 * Optional helper (API only)
 * =========================
 */

export async function getSessionForAPI() {
  return getServerSession(authOptions)
}
// lib/shared/env/startup-check.ts
import { ENV } from './env'
import { logger } from '@/lib/shared/logger'  // âœ… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯
import { prisma } from '@/lib/infrastructure/database/prisma'  // âœ… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯

export async function startupCheck(): Promise<void> {
  logger.info('Starting application...')
  
  const checks = [
    { name: 'Environment', check: checkEnvironment },
    { name: 'Database', check: checkDatabase },
    { name: 'Paymob Config', check: checkPaymob },
  ]
  
  const results = await Promise.allSettled(
    checks.map(async ({ name, check }) => {
      try {
        await check()
        return { name, status: 'âœ…' }
      } catch (error: any) {
        return { name, status: 'âŒ', error: error.message }
      }
    })
  )
  
  console.log('\nğŸ“Š Startup Check Results:')
  console.log('========================')
  
  results.forEach(result => {
    if (result.status === 'fulfilled') {
      const value = result.value
      if (value.error) {
        console.log(`${value.status} ${value.name}: ${value.error}`)
      } else {
        console.log(`${value.status} ${value.name}`)
      }
    } else {
      console.log(`âŒ Check failed`)
    }
  })
  
  console.log('========================\n')
  
  // Warn if not production ready
  if (ENV.NODE_ENV === 'production') {
    const missingForProduction = []
    
    if (!ENV.PAYMOB_API_KEY) missingForProduction.push('PAYMOB_API_KEY')
    if (!ENV.PAYMOB_HMAC_SECRET) missingForProduction.push('PAYMOB_HMAC_SECRET')
    if (!ENV.PAYMOB_INTEGRATION_ID) missingForProduction.push('PAYMOB_INTEGRATION_ID')
    
    if (missingForProduction.length > 0) {
      logger.warn({ missing: missingForProduction }, 'âš ï¸  Missing production configuration:')
    }
  }
  
  logger.info('Startup check completed')
}

async function checkEnvironment(): Promise<void> {
  const required = ['NODE_ENV', 'DATABASE_URL', 'NEXTAUTH_URL']
  const missing = required.filter(key => !process.env[key])
  
  if (missing.length > 0) {
    throw new Error(`Missing environment variables: ${missing.join(', ')}`)
  }
}

async function checkDatabase(): Promise<void> {
  try {
    await prisma.$queryRaw`SELECT 1`
    logger.info('Database connection successful')
  } catch (error: any) {
    throw new Error(`Database connection failed: ${error.message}`)
  }
}

async function checkPaymob(): Promise<void> {
  if (ENV.NODE_ENV === 'production') {
    const required = ['PAYMOB_API_KEY', 'PAYMOB_HMAC_SECRET', 'PAYMOB_INTEGRATION_ID']
    const missing = required.filter(key => !ENV[key as keyof typeof ENV])
    
    if (missing.length > 0) {
      throw new Error(`Missing Paymob configuration: ${missing.join(', ')}`)
    }
    logger.info('Paymob configuration is ready for production')
  } else {
    logger.info('Paymob configuration check skipped (development)')
  }
}
import { z } from 'zod'

const envSchema = z.object({
  // === Database ===
  DATABASE_URL: z.string()
    .url()
    .refine(url => url.startsWith('postgresql://'), {
      message: 'DATABASE_URL must start with postgresql://'
    }),
  
  // === NextAuth ===
  NEXTAUTH_URL: z.string().url(),
  NEXTAUTH_SECRET: z.string()
    .min(32, 'NEXTAUTH_SECRET must be at least 32 characters'),
  
  // === Paymob ===
  PAYMOB_API_KEY: z.string().min(1),
  PAYMOB_HMAC_SECRET: z.string().min(1),
  PAYMOB_INTEGRATION_ID: z.string().min(1),
  PAYMOB_IFRAME_ID: z.string().default('default'),
  
  // === Cron ===
  CRON_SECRET: z.string()
    .min(32, 'CRON_SECRET must be at least 32 characters')
    .default('dev-cron-secret-change-in-production'),
  
  // === App ===
  APP_URL: z.string().url().default('http://localhost:3000'),
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  
  // === Logging ===
  LOG_LEVEL: z.enum(['debug', 'info', 'warn', 'error'])
    .default('info'),
  
  // === Email (Optional) ===
  RESEND_API_KEY: z.string().optional(),
  EMAIL_FROM: z.string().email().optional(),
  
  // === Google OAuth (Optional) ===
  GOOGLE_CLIENT_ID: z.string().optional(),
  GOOGLE_CLIENT_SECRET: z.string().optional(),
})

// Validate env
const env = envSchema.safeParse(process.env)

if (!env.success) {
  console.error('âŒ Invalid environment variables:', env.error.flatten().fieldErrors)
  
  // ÙÙŠ development Ù†Ø¹Ø·ÙŠ defaults Ù„Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
  if (process.env.NODE_ENV === 'production') {
    throw new Error('Invalid environment variables')
  }
  
  console.warn('âš ï¸  Running with default environment variables for development')
}

export const ENV = env.success ? env.data : {
  // Defaults for development
  NODE_ENV: 'development' as const,
  DATABASE_URL: process.env.DATABASE_URL || 'postgresql://localhost:5432/ihgezly',
  NEXTAUTH_URL: process.env.NEXTAUTH_URL || 'http://localhost:3000',
  NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET || 'dev-secret-change-in-production-32-chars-min',
  APP_URL: process.env.APP_URL || 'http://localhost:3000',
  CRON_SECRET: process.env.CRON_SECRET || 'dev-cron-secret-change-in-production',
  LOG_LEVEL: 'debug' as const,
  PAYMOB_API_KEY: process.env.PAYMOB_API_KEY || 'mock_api_key',
  PAYMOB_HMAC_SECRET: process.env.PAYMOB_HMAC_SECRET || 'mock_hmac_secret',
  PAYMOB_INTEGRATION_ID: process.env.PAYMOB_INTEGRATION_ID || 'mock_integration_id',
  PAYMOB_IFRAME_ID: process.env.PAYMOB_IFRAME_ID || 'default'
}
// lib/shared/context/request-context.ts
import { NextRequest, NextResponse } from 'next/server'
import { v4 as uuidv4 } from 'uuid'
import { getServerSession } from 'next-auth'
import { AsyncLocalStorage } from 'async_hooks'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'
import { logger } from '@/lib/shared/logger'

export class RequestContext {
  private static storage = new AsyncLocalStorage<Map<string, any>>()

  static get<T>(key: string): T | undefined {
    return this.storage.getStore()?.get(key)
  }

  static set(key: string, value: any): void {
    const store = this.storage.getStore()
    if (store) {
      store.set(key, value)
    }
  }

  // âœ… Ø®Ù„ÙŠÙ‡Ø§ generic Ø¹Ù„Ø´Ø§Ù† ØªØ±Ø¬Ø¹ Ù†ÙØ³ Ù†ÙˆØ¹ callback
  static run<T>(context: Map<string, any>, callback: () => T): T {
    return this.storage.run(context, callback)
  }

  static getRequestId(): string {
    return this.get('requestId') || 'unknown'
  }

  static getUserId(): string | undefined {
    return this.get('userId')
  }

  static getSessionId(): string | undefined {
    return this.get('sessionId')
  }
}

// Middleware Ù„Ø¥Ø¶Ø§ÙØ© Context
export function withRequestContext(
  handler: (req: NextRequest) => Promise<NextResponse>
) {
  return async (req: NextRequest): Promise<NextResponse> => {
    const context = new Map<string, any>()
    
    const requestId = uuidv4()
    context.set('requestId', requestId)
    
    try {
      const session = await getServerSession(authOptions)
      if (session?.user) {
        const user = session.user as any
        if (user.id) {
          context.set('userId', user.id)
        }
        // âŒ session.id Ù…Ø´ Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ
        // Ù„Ùˆ Ù…Ø­ØªØ§Ø¬ sessionIdØŒ Ø¶ÙŠÙÙ‡ Ø¨Ù†ÙØ³Ùƒ ÙÙŠ JWT/session callback
      }
    } catch (error) {
      logger.warn({ error }, 'Failed to get session in request context')
    }
    
    context.set('userAgent', req.headers.get('user-agent'))
    context.set('ip', req.headers.get('x-forwarded-for') || req.headers.get('x-real-ip') || 'unknown')
    context.set('path', req.nextUrl.pathname)
    context.set('method', req.method)
    
    return RequestContext.run(context, async () => {
      logger.info({
        requestId,
        method: req.method,
        path: req.nextUrl.pathname,
        userId: RequestContext.getUserId()
      }, 'Request started')
      
      const startTime = Date.now()
      
      try {
        const response = await handler(req)
        
        const duration = Date.now() - startTime
        logger.info({
          requestId,
          durationMs: duration,
          status: response.status,
          path: req.nextUrl.pathname,
          userId: RequestContext.getUserId()
        }, 'Request completed')
        
        response.headers.set('X-Request-ID', requestId)
        return response
      } catch (error) {
        const duration = Date.now() - startTime
        logger.error({
          requestId,
          durationMs: duration,
          path: req.nextUrl.pathname,
          userId: RequestContext.getUserId(),
          error: error instanceof Error ? error.message : String(error)
        }, 'Request failed')
        
        throw error
      }
    })
  }
}
import { 
  SlotStatus as PrismaSlotStatus,
  BookingStatus as PrismaBookingStatus,
  PaymentStatus as PrismaPaymentStatus,
  FieldStatus as PrismaFieldStatus,
  FieldType as PrismaFieldType,
  NotificationType as PrismaNotificationType,
  Role as PrismaRole,
  SkillLevel as PrismaSkillLevel,
  AuditAction as PrismaAuditAction
} from '@prisma/client'

// Re-export Ù…Ù† Prisma
export const SLOT_STATUS = PrismaSlotStatus
export const BOOKING_STATUS = PrismaBookingStatus
export const PAYMENT_STATUS = PrismaPaymentStatus
export const FIELD_STATUS = PrismaFieldStatus
export const FIELD_TYPES = PrismaFieldType
export const NOTIFICATION_TYPE = PrismaNotificationType
export const USER_ROLES = PrismaRole
export const SKILL_LEVELS = PrismaSkillLevel
export const AUDIT_ACTIONS = PrismaAuditAction

// Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹Ø±ÙŠÙ Ù„Ù„ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù‚Ø¯ÙŠÙ…
export const TOKEN_TYPES = {
  EMAIL_VERIFICATION: 'EMAIL_VERIFICATION',
  PASSWORD_RESET: 'PASSWORD_RESET',
  REFRESH_TOKEN: 'REFRESH_TOKEN'
} as const

export const ERROR_CODES = {
  // Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  AUTHENTICATION_ERROR: 'AUTHENTICATION_ERROR',
  AUTHORIZATION_ERROR: 'AUTHORIZATION_ERROR',
  NOT_FOUND: 'NOT_FOUND',
  CONFLICT: 'CONFLICT',
  RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',
  TOKEN_EXPIRED: 'TOKEN_EXPIRED',
  INVALID_TOKEN: 'INVALID_TOKEN',
  SERVER_ERROR: 'SERVER_ERROR',
  
  // Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…Ù„Ø§Ø¹Ø¨
  FIELD_NOT_FOUND: 'FIELD_NOT_FOUND',
  FIELD_CLOSED: 'FIELD_CLOSED',
  FIELD_MAINTENANCE: 'FIELD_MAINTENANCE',
  
  // Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯
  SLOT_NOT_FOUND: 'SLOT_NOT_FOUND',
  SLOT_ALREADY_BOOKED: 'SLOT_ALREADY_BOOKED',
  SLOT_UNAVAILABLE: 'SLOT_UNAVAILABLE',
  SLOT_LOCKED_BY_OTHER: 'SLOT_LOCKED_BY_OTHER',
  SLOT_CANNOT_BE_LOCKED: 'SLOT_CANNOT_BE_LOCKED',
  SLOT_LOCK_EXPIRED: 'SLOT_LOCK_EXPIRED',
  
  // Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª
  BOOKING_NOT_FOUND: 'BOOKING_NOT_FOUND',
  BOOKING_NOT_OWNED: 'BOOKING_NOT_OWNED',
  BOOKING_INVALID_STATE: 'BOOKING_INVALID_STATE',
  BOOKING_IN_PROGRESS: 'BOOKING_IN_PROGRESS',
  BOOKING_EXPIRED: 'BOOKING_EXPIRED',
  BOOKING_LIMIT_EXCEEDED: 'BOOKING_LIMIT_EXCEEDED',
  
  // Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø¯ÙØ¹
  PAYMENT_ALREADY_PROCESSED: 'PAYMENT_ALREADY_PROCESSED',
  PAYMENT_FAILED: 'PAYMENT_FAILED',
  DUPLICATE_PAYMENT: 'DUPLICATE_PAYMENT',
  PAYMENT_NOT_FOUND: 'PAYMENT_NOT_FOUND',
  
  // Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„ÙˆÙ‚Øª
  TIME_IN_PAST: 'TIME_IN_PAST',
  TIME_TOO_CLOSE: 'TIME_TOO_CLOSE',
  INVALID_DATE: 'INVALID_DATE',
  
  // Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„ØªØ­Ù‚Ù‚
  INVALID_INPUT: 'INVALID_INPUT',
  MISSING_FIELD: 'MISSING_FIELD',
  
  // Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø©
  UNAUTHORIZED: 'UNAUTHORIZED',
  INVALID_CREDENTIALS: 'INVALID_CREDENTIALS',
  SESSION_EXPIRED: 'SESSION_EXPIRED',
  
  // Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù†Ø¸Ø§Ù…
  INTERNAL_ERROR: 'INTERNAL_ERROR',
  SERVICE_UNAVAILABLE: 'SERVICE_UNAVAILABLE'
} as const

export const PASSWORD_POLICY = {
  MIN_LENGTH: 8,
  REQUIRE_UPPERCASE: true,
  REQUIRE_LOWERCASE: true,
  REQUIRE_NUMBER: true,
  REQUIRE_SPECIAL_CHAR: true
} as const

export const RATE_LIMITS = {
  LOGIN: {
    WINDOW_MS: 15 * 60 * 1000,
    MAX_ATTEMPTS: 5
  },
  REGISTER: {
    WINDOW_MS: 60 * 60 * 1000,
    MAX_ATTEMPTS: 3
  },
  FORGOT_PASSWORD: {
    WINDOW_MS: 60 * 60 * 1000,
    MAX_ATTEMPTS: 3
  }
} as const

// Types Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙÙŠ TypeScript
export type SlotStatus = PrismaSlotStatus
export type BookingStatus = PrismaBookingStatus
export type PaymentStatus = PrismaPaymentStatus
export type FieldStatus = PrismaFieldStatus
export type FieldType = PrismaFieldType
export type NotificationType = PrismaNotificationType
export type UserRole = PrismaRole
export type SkillLevel = PrismaSkillLevel
export type TokenType = typeof TOKEN_TYPES[keyof typeof TOKEN_TYPES]
export type ErrorCode = typeof ERROR_CODES[keyof typeof ERROR_CODES]
// lib/shared/api/api-error-handler.ts
import { NextResponse } from 'next/server'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { ERROR_CODES } from '@/lib/core/errors/error-codes'

export function apiErrorHandler(error: unknown): NextResponse {
  console.error('API Error:', error)

  // Handle DomainError
  if (error instanceof DomainError) {
    const status = getHttpStatus(error.code)
    return NextResponse.json(
      {
        error: true,
        code: ERROR_CODES[error.code],
        message: error.message,
        details: error.details
      },
      { status }
    )
  }

  // Handle Zod validation errors
  if (error instanceof Error && error.name === 'ZodError') {
    return NextResponse.json(
      {
        error: true,
        code: 'VALIDATION_ERROR',
        message: 'Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ§Ù„Ø­Ø©',
        details: error.message
      },
      { status: 400 }
    )
  }

  // Handle Prisma errors
  if (error instanceof Error && error.name.includes('Prisma')) {
    return NextResponse.json(
      {
        error: true,
        code: 'DATABASE_ERROR',
        message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª'
      },
      { status: 500 }
    )
  }

  // Default error
  return NextResponse.json(
    {
      error: true,
      code: 'INTERNAL_SERVER_ERROR',
      message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹'
    },
    { status: 500 }
  )
}

function getHttpStatus(errorCode: keyof typeof ERROR_CODES): number {
  const code = ERROR_CODES[errorCode]
  
  if (code.startsWith('AUTH')) return 401
  if (code.startsWith('VAL')) return 400
  if (code.startsWith('SLOT') || code.startsWith('BOOK') || code.startsWith('PAY')) return 400
  if (code.startsWith('FIELD')) return 404
  return 500
}
// lib/infrastructure/security/password.ts
import bcrypt from 'bcryptjs'

export async function hashPassword(password: string): Promise<string> {
  const salt = await bcrypt.genSalt(12)
  return bcrypt.hash(password, salt)
}

export async function comparePassword(
  rawPassword: string, 
  hashedPassword: string
): Promise<boolean> {
  if (!hashedPassword) return false
  return bcrypt.compare(rawPassword, hashedPassword)
}
//lib/infrastructure/payments/providers/paymob.ts
import axios from 'axios'
import { ENV } from '@/lib/shared/env/env'
import { paymentLogger } from '@/lib/shared/logger'

const PAYMOB_BASE_URL = 'https://accept.paymob.com/api'

export interface PaymobOrder {
  id: number
  amount_cents: number
  currency: string
  merchant_order_id: string
}

export interface PaymobPaymentKey {
  token: string
  orderId: number
}

export interface PaymobBillingData {
  apartment?: string
  email: string
  floor?: string
  first_name: string
  street?: string
  building?: string
  phone_number: string
  shipping_method?: string
  postal_code?: string
  city?: string
  country?: string
  last_name?: string
  state?: string
}

export class PaymobService {
  private apiKey: string
  private integrationId: string
  private hmacSecret: string

  constructor() {
    this.apiKey = ENV.PAYMOB_API_KEY || ''
    this.integrationId = ENV.PAYMOB_INTEGRATION_ID || ''
    this.hmacSecret = ENV.PAYMOB_HMAC_SECRET || ''
  }

  // 1. Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Authentication Token
  async getAuthToken(): Promise<string> {
    try {
      paymentLogger.info({ 
        msg: 'Requesting Paymob auth token' 
      })
      
      const response = await axios.post(`${PAYMOB_BASE_URL}/auth/tokens`, {
        api_key: this.apiKey
      })
      
      paymentLogger.info({ 
        msg: 'Paymob auth token received' 
      })
      return response.data.token
    } catch (error: any) {
      paymentLogger.error({ 
        msg: 'Error getting Paymob auth token',
        error: error.message 
      })
      throw new Error('ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø®Ø¯Ù…Ø© Ø§Ù„Ø¯ÙØ¹')
    }
  }

  // 2. Ø¥Ù†Ø´Ø§Ø¡ Order ÙÙŠ Paymob
  async createOrder({
    amount,
    currency = 'EGP',
    bookingId,
    userId
  }: {
    amount: number
    currency?: string
    bookingId: string
    userId: string
  }): Promise<PaymobOrder> {
    try {
      const authToken = await this.getAuthToken()
      
      paymentLogger.info({ 
        msg: 'Creating Paymob order',
        bookingId, 
        userId, 
        amount 
      })
      
      const response = await axios.post(
        `${PAYMOB_BASE_URL}/ecommerce/orders`,
        {
          auth_token: authToken,
          delivery_needed: 'false',
          amount_cents: amount * 100,
          currency,
          items: [],
          merchant_order_id: bookingId
        },
        { timeout: 10000 }
      )

      paymentLogger.info({ 
        msg: 'Paymob order created',
        orderId: response.data.id,
        bookingId 
      })

      return response.data
    } catch (error: any) {
      paymentLogger.error({ 
        msg: 'Error creating Paymob order',
        error: error.message,
        bookingId,
        amount
      })
      throw error
    }
  }

  // 3. Ø¥Ù†Ø´Ø§Ø¡ Payment Key Ù„ÙØªØ­ Iframe
  async getPaymentKey({
    orderId,
    amount,
    billingData,
    bookingId
  }: {
    orderId: string | number
    amount: number
    billingData: PaymobBillingData
    bookingId: string
  }): Promise<string> {
    try {
      const authToken = await this.getAuthToken()
      
      paymentLogger.info({ 
        msg: 'Getting Paymob payment key',
        orderId, 
        bookingId 
      })
      
      const response = await axios.post(
        `${PAYMOB_BASE_URL}/acceptance/payment_keys`,
        {
          auth_token: authToken,
          amount_cents: amount * 100,
          expiration: 3600,
          order_id: orderId,
          billing_data: billingData,
          currency: 'EGP',
          integration_id: this.integrationId,
          lock_order_when_paid: 'false',
          extra: {
            booking_id: bookingId
          }
        },
        { timeout: 10000 }
      )

      paymentLogger.info({ 
        msg: 'Paymob payment key received',
        orderId 
      })
      return response.data.token
    } catch (error: any) {
      paymentLogger.error({ 
        msg: 'Error getting Paymob payment key',
        error: error.message,
        orderId
      })
      throw error
    }
  }

  // 4. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù€ HMAC (Ù„Ù€ Webhook)
  verifyHMAC(data: any, receivedHMAC: string): boolean {
    try {
      const { 
        amount_cents, created_at, currency, error_occured, has_parent_transaction, 
        id, integration_id, is_3d_secure, is_auth, is_capture, is_refunded, 
        is_standalone_payment, is_voided, order, owner, pending, source_data, success 
      } = data

      const orderId = order?.id || ''
      const pan = source_data?.pan || ''
      const sub_type = source_data?.sub_type || ''
      const type = source_data?.type || ''

      const stringToHash = 
        amount_cents + 
        created_at + 
        currency + 
        error_occured + 
        has_parent_transaction + 
        id + 
        integration_id + 
        is_3d_secure + 
        is_auth + 
        is_capture + 
        is_refunded + 
        is_standalone_payment + 
        is_voided + 
        orderId + 
        owner + 
        pending + 
        pan + 
        sub_type + 
        type + 
        success

      const crypto = require('crypto')
      const calculatedHMAC = crypto
        .createHmac('sha512', this.hmacSecret)
        .update(stringToHash)
        .digest('hex')

      const isValid = calculatedHMAC === receivedHMAC
      
      paymentLogger.info({ 
        msg: 'HMAC verification',
        isValid,
        orderId: data.order?.id 
      })
      
      return isValid
    } catch (error: any) {
      paymentLogger.error({ 
        msg: 'HMAC verification error',
        error: error.message 
      })
      return false
    }
  }

  // 5. Mock mode Ù„Ù„ØªÙ†Ù…ÙŠØ©
  isMockMode(): boolean {
    return ENV.NODE_ENV !== 'production' || !this.apiKey
  }

  // 6. Ø¥Ù†Ø´Ø§Ø¡ order ÙˆÙ‡Ù…ÙŠ Ù„Ù„ØªÙ†Ù…ÙŠØ©
  async createMockOrder(params: {
    amount: number
    currency: string
    bookingId: string
  }): Promise<PaymobOrder> {
    paymentLogger.info({ 
      msg: 'Creating mock Paymob order',
      ...params 
    })
    
    return {
      id: Date.now(),
      amount_cents: params.amount * 100,
      currency: params.currency,
      merchant_order_id: params.bookingId
    }
  }

  // 7. Ù…ÙØªØ§Ø­ Ø¯ÙØ¹ ÙˆÙ‡Ù…ÙŠ Ù„Ù„ØªÙ†Ù…ÙŠØ©
  async getMockPaymentKey(params: {
    orderId: number
  }): Promise<string> {
    paymentLogger.info({ 
      msg: 'Creating mock payment key',
      ...params 
    })
    return `mock_token_${Date.now()}_${params.orderId}`
  }
}

export const paymobService = new PaymobService()
// lib/infrastructure/payments/providers/index.ts
export { paymobService } from './paymob'
export { paymobHmacVerifier } from './hmac-verifier'

// Re-export types
export type {
  PaymobOrder,
  PaymobPaymentKey,
  PaymobBillingData
} from './paymob'
// lib/infrastructure/payments/providers/hmac-verifier.ts
import crypto from 'crypto'
import { ENV } from '@/lib/shared/env/env'
import { paymentLogger } from '@/lib/shared/logger'

export class PaymobHmacVerifier {
  private readonly hmacSecret: string

  constructor() {
    this.hmacSecret = ENV.PAYMOB_HMAC_SECRET || ''
    
    if (!this.hmacSecret) {
      paymentLogger.warn({
        msg: 'PAYMOB_HMAC_SECRET is not set. HMAC verification will fail.'
      })
    }
  }

  verify(data: any, receivedHmac: string): boolean {
    try {
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…ÙØªØ§Ø­ Ø§Ù„Ø³Ø±ÙŠ
      if (!this.hmacSecret) {
        paymentLogger.error({
          msg: 'HMAC verification failed - secret not configured'
        })
        return false
      }

      const orderedData = this.orderData(data)
      const dataString = JSON.stringify(orderedData)
      
      const calculatedHmac = crypto
        .createHmac('sha512', this.hmacSecret)
        .update(dataString)
        .digest('hex')
      
      const isValid = crypto.timingSafeEqual(
        Buffer.from(calculatedHmac, 'hex'),
        Buffer.from(receivedHmac, 'hex')
      )

      paymentLogger.info({
        msg: 'HMAC verification completed',
        isValid,
        orderId: data.order?.id 
      })
      
      return isValid
    } catch (error: any) {
      paymentLogger.error({
        msg: 'HMAC verification error',
        error: error.message,
        stack: error.stack
      })
      return false
    }
  }

  isFresh(timestamp: number, maxAgeSeconds: number = 300): boolean {
    const now = Math.floor(Date.now() / 1000)
    const age = now - timestamp
    
    const isFresh = age <= maxAgeSeconds && age >= 0
    
    paymentLogger.debug({
      msg: 'Timestamp freshness check',
      timestamp,
      now,
      age,
      maxAgeSeconds,
      isFresh
    })
    
    return isFresh
  }

  private orderData(data: any): any {
    const ordered: any = {}
    
    const fields = [
      'amount_cents',
      'created_at',
      'currency',
      'error_occured',
      'has_parent_transaction',
      'id',
      'integration_id',
      'is_3d_secure',
      'is_auth',
      'is_capture',
      'is_refunded',
      'is_standalone_payment',
      'is_voided',
      'order',
      'owner',
      'pending',
      'source_data',
      'success',
    ]

    fields.forEach(field => {
      if (data[field] !== undefined) {
        ordered[field] = data[field]
      }
    })
    
    return ordered
  }

  // Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªÙƒÙˆÙŠÙ† Ø§Ù„Ù€ HMAC
  testConfiguration(): boolean {
    const testData = { test: 'data' }
    const testHmac = 'test-hmac'
    
    try {
      const result = this.verify(testData, testHmac)
      
      paymentLogger.info({
        msg: 'HMAC configuration test',
        hasSecret: !!this.hmacSecret,
        testResult: result // Ù…Ù† Ø§Ù„Ù…ØªÙˆÙ‚Ø¹ Ø£Ù† ØªÙƒÙˆÙ† false Ù„Ø£Ù† HMAC ØºÙŠØ± ØµØ­ÙŠØ­
      })
      
      return !!this.hmacSecret
    } catch (error: any) {
      paymentLogger.error({
        msg: 'HMAC configuration test failed',
        error: error.message
      })
      return false
    }
  }
}

export const paymobHmacVerifier = new PaymobHmacVerifier()
// lib/infrastructure/notifications/notification-service.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { logger } from '@/lib/shared/logger'
import { NotificationType as PrismaNotificationType } from '@prisma/client'

// âœ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Prisma enum Ù…Ø¨Ø§Ø´Ø±Ø©
export type NotificationType = PrismaNotificationType

export interface NotificationParams {
  userId: string
  type: NotificationType
  title: string
  message: string
  relatedId?: string
  data?: any
  channel?: 'APP' | 'EMAIL' | 'SMS'
}

export class NotificationService {
  async send(params: NotificationParams): Promise<void> {
    try {
      await prisma.notification.create({
        data: {
          userId: params.userId,
          type: params.type,
          title: params.title,
          message: params.message,
          bookingId: params.data?.bookingId || null,
          data: params.data || {},
          isRead: false,
          isSent: true,
          sentVia: params.channel ? [params.channel] : ['APP']
        }
      })

      if (params.channel) {
        switch (params.channel) {
          case 'EMAIL':
            await this.sendEmail(params)
            break
          case 'SMS':
            await this.sendSMS(params)
            break
        }
      }

      logger.info({
        msg: 'Notification sent successfully',
        userId: params.userId,
        type: params.type
      })
    } catch (error: any) {
      logger.error({
        msg: 'Failed to send notification',
        error: error.message,
        userId: params.userId
      })
    }
  }

  async sendEmail(params: NotificationParams): Promise<void> {
    logger.info({
      msg: 'Email notification would be sent',
      userId: params.userId,
      email: params.data?.email
    })
  }

  async sendSMS(params: NotificationParams): Promise<void> {
    logger.info({
      msg: 'SMS notification would be sent',
      userId: params.userId,
      phone: params.data?.phone
    })
  }

  async getUserNotifications(userId: string, limit: number = 20) {
    try {
      return await prisma.notification.findMany({
        where: { 
          userId,
          isSent: true
        },
        orderBy: { createdAt: 'desc' },
        take: limit
      })
    } catch (error: any) {
      logger.error({
        msg: 'Failed to get user notifications',
        error: error.message,
        userId
      })
      return []
    }
  }

  async markAsRead(notificationId: string, userId: string) {
    try {
      return await prisma.notification.update({
        where: { 
          id: notificationId,
          userId
        },
        data: { 
          isRead: true,
          readAt: new Date()
        }
      })
    } catch (error: any) {
      logger.error({
        msg: 'Failed to mark notification as read',
        error: error.message,
        notificationId,
        userId
      })
      throw error
    }
  }

  async markAllAsRead(userId: string) {
    try {
      return await prisma.notification.updateMany({
        where: { 
          userId,
          isRead: false
        },
        data: { 
          isRead: true,
          readAt: new Date()
        }
      })
    } catch (error: any) {
      logger.error({
        msg: 'Failed to mark all notifications as read',
        error: error.message,
        userId
      })
      throw error
    }
  }

  async deleteNotification(notificationId: string, userId: string) {
    try {
      return await prisma.notification.delete({
        where: { 
          id: notificationId,
          userId
        }
      })
    } catch (error: any) {
      logger.error({
        msg: 'Failed to delete notification',
        error: error.message,
        notificationId,
        userId
      })
      throw error
    }
  }
}

export const notificationService = new NotificationService()
// lib/infrastructure/database/prisma.ts
import { PrismaClient } from '@prisma/client'

console.log('PrismaClient:', typeof PrismaClient)

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

// Ø§Ø³ØªØ®Ø¯Ù… Ø´Ø±Ø· ØªØ­Ù‚Ù‚ Ø¥Ø¶Ø§ÙÙŠ
let prismaInstance: PrismaClient

if (process.env.NODE_ENV === 'production') {
  prismaInstance = new PrismaClient()
} else {
  if (!globalForPrisma.prisma) {
    globalForPrisma.prisma = new PrismaClient({
      log: ['query', 'error', 'warn']
    })
  }
  prismaInstance = globalForPrisma.prisma
}

export const prisma = prismaInstance
export default prisma
// lib/infrastructure/auth/validators.ts
import { z } from 'zod'

export const emailSchema = z.string()
  .email('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ØºÙŠØ± ØµØ§Ù„Ø­')
  .min(1, 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù…Ø·Ù„ÙˆØ¨')
  .max(100, 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø·ÙˆÙŠÙ„ Ø¬Ø¯Ø§Ù‹')

export const passwordSchema = z.string()
  .min(6, 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† 6 Ø£Ø­Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„')
  .max(72, 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø·ÙˆÙŠÙ„Ø© Ø¬Ø¯Ø§Ù‹')

export const nameSchema = z.string()
  .min(2, 'Ø§Ù„Ø§Ø³Ù… ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø­Ø±ÙÙŠÙ† Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„')
  .max(100, 'Ø§Ù„Ø§Ø³Ù… Ø·ÙˆÙŠÙ„ Ø¬Ø¯Ø§Ù‹')
  .regex(/^[a-zA-Z\u0600-\u06FF\s]*$/, 'Ø§Ù„Ø§Ø³Ù… ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠØ­ØªÙˆÙŠ ÙÙ‚Ø· Ø¹Ù„Ù‰ Ø£Ø­Ø±Ù ÙˆÙ…Ø³Ø§ÙØ§Øª')

export const phoneSchema = z.string()
  .min(10, 'Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† 10 Ø£Ø±Ù‚Ø§Ù… Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„')
  .max(15, 'Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ Ø·ÙˆÙŠÙ„ Ø¬Ø¯Ø§Ù‹')
  .regex(/^[0-9+\-\s()]*$/, 'Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ ØºÙŠØ± ØµØ§Ù„Ø­')

export const ageSchema = z.number()
  .min(13, 'Ø§Ù„Ø¹Ù…Ø± ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† 13 Ø³Ù†Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„')
  .max(100, 'Ø§Ù„Ø¹Ù…Ø± ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† 100 Ø³Ù†Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£ÙƒØ«Ø±')

export const skillLevelSchema = z.enum(['WEAK', 'AVERAGE', 'GOOD', 'EXCELLENT', 'LEGENDARY'])

export const registerSchema = z.object({
  name: nameSchema,
  email: emailSchema,
  password: passwordSchema,
  confirmPassword: z.string(),
  phoneNumber: phoneSchema,
  age: ageSchema,
  description: z.string().max(500, 'Ø§Ù„ÙˆØµÙ Ø·ÙˆÙŠÙ„ Ø¬Ø¯Ø§Ù‹ (500 Ø­Ø±Ù ÙƒØ­Ø¯ Ø£Ù‚ØµÙ‰)').optional(),
  skillLevel: skillLevelSchema
}).refine(data => data.password === data.confirmPassword, {
  message: "ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± Ù…ØªØ·Ø§Ø¨Ù‚Ø©",
  path: ["confirmPassword"]
})

export const loginSchema = z.object({
  email: emailSchema,
  password: z.string().min(1, 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù…Ø·Ù„ÙˆØ¨Ø©')
})

export const updateProfileSchema = z.object({
  name: nameSchema.optional(),
  email: emailSchema.optional(),
  phoneNumber: phoneSchema.optional(),
  age: ageSchema.optional(),
  description: z.string().max(500).optional(),
  skillLevel: skillLevelSchema.optional()
}).refine(data => Object.keys(data).length > 0, {
  message: "ÙŠØ¬Ø¨ ØªÙ‚Ø¯ÙŠÙ… Ø­Ù‚Ù„ ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„"
})

export const changePasswordSchema = z.object({
  currentPassword: z.string().min(1, 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù…Ø·Ù„ÙˆØ¨Ø©'),
  newPassword: passwordSchema,
  confirmPassword: z.string()
}).refine(data => data.newPassword === data.confirmPassword, {
  message: "ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± Ù…ØªØ·Ø§Ø¨Ù‚Ø©",
  path: ["confirmPassword"]
})

export type RegisterInput = z.infer<typeof registerSchema>
export type LoginInput = z.infer<typeof loginSchema>
export type UpdateProfileInput = z.infer<typeof updateProfileSchema>
export type ChangePasswordInput = z.infer<typeof changePasswordSchema>
export type RegisterFormInput = RegisterInput & {
  skillLevel: 'WEAK' | 'AVERAGE' | 'GOOD' | 'EXCELLENT' | 'LEGENDARY'
}
// lib/infrastructure/auth/responses.ts
export interface ApiResponse<T = any> {
  success: boolean
  message: string
  data?: T
  errorCode?: string
  details?: any
  timestamp: string
  path?: string
}

export const successResponse = <T>(
  message: string, 
  data?: T,
  path?: string
): ApiResponse<T> => ({
  success: true,
  message,
  data,
  timestamp: new Date().toISOString(),
  path
})

export const errorResponse = (
  message: string,
  errorCode?: string,
  details?: any,
  path?: string
): ApiResponse => ({
  success: false,
  message,
  errorCode,
  details,
  timestamp: new Date().toISOString(),
  path
})

export const validationErrorResponse = (
  errors: any[],
  path?: string
): ApiResponse => ({
  success: false,
  message: 'Validation failed',
  errorCode: 'VALIDATION_ERROR',
  details: { errors },
  timestamp: new Date().toISOString(),
  path
})
import { z } from 'zod'
import { authLogger } from '@/lib/shared/logger'

export class AppError extends Error {
  constructor(
    public message: string,
    public statusCode: number = 500,
    public errorCode?: string,
    public details?: unknown
  ) {
    super(message)
    this.name = this.constructor.name
    Error.captureStackTrace(this, this.constructor)
    authLogger.error({ statusCode, errorCode, details }, `AppError: ${message}`)
  }
}

export class ValidationError extends AppError {
  constructor(message: string, details?: unknown) {
    super(message, 400, 'VALIDATION_ERROR', details)
  }
}

export class AuthenticationError extends AppError {
  constructor(message = 'Authentication required') {
    super(message, 401, 'AUTHENTICATION_ERROR')
  }
}

export class AuthorizationError extends AppError {
  constructor(message = 'Insufficient permissions') {
    super(message, 403, 'AUTHORIZATION_ERROR')
  }
}

export class NotFoundError extends AppError {
  constructor(resource = 'Resource') {
    super(`${resource} not found`, 404, 'NOT_FOUND')
  }
}

export class ConflictError extends AppError {
  constructor(message = 'Resource already exists') {
    super(message, 409, 'CONFLICT')
  }
}

export class RateLimitError extends AppError {
  constructor(message = 'Too many requests') {
    super(message, 429, 'RATE_LIMIT_EXCEEDED')
  }
}

export class TokenExpiredError extends AppError {
  constructor(message = 'Token has expired') {
    super(message, 401, 'TOKEN_EXPIRED')
  }
}

export class InvalidTokenError extends AppError {
  constructor(message = 'Invalid token') {
    super(message, 401, 'INVALID_TOKEN')
  }
}

// Error handler
export const handleError = (error: unknown): AppError => {
  if (error instanceof AppError) {
    return error
  }
  
  if (error instanceof z.ZodError) {
    return new ValidationError(
      'Validation failed',
      error.issues.map((e: z.ZodIssue) => ({
        path: e.path.join('.'),
        message: e.message
      }))
    )
  }
  
  authLogger.error({ error }, 'Unexpected error')
  
  return new AppError(
    'An unexpected error occurred',
    500,
    'INTERNAL_SERVER_ERROR'
  )
}
// lib/infrastructure/auth/auth-options.ts
import { NextAuthOptions } from 'next-auth'
import CredentialsProvider from 'next-auth/providers/credentials'
import GoogleProvider from 'next-auth/providers/google'
import { RateLimiterMemory } from 'rate-limiter-flexible'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { comparePassword } from '@/lib/infrastructure/security/password'
import { z } from 'zod'
import { authLogger } from '@/lib/shared/logger'
import { Role, SkillLevel } from '@prisma/client'
import { ENV } from '@/lib/shared/env/env'

// Rate Limiter
const loginRateLimiter = new RateLimiterMemory({
  points: 5,
  duration: 15 * 60,
})

const loginSchema = z.object({
  email: z.string().email('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ØºÙŠØ± ØµØ§Ù„Ø­'),
  password: z.string().min(1, 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù…Ø·Ù„ÙˆØ¨Ø©')
})

const normalizeEmail = (email: string): string => {
  return email.toLowerCase().trim()
}

export const authOptions: NextAuthOptions = {
  providers: [
    CredentialsProvider({
      name: 'credentials',
      credentials: {
        email: { label: 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ', type: 'email' },
        password: { label: 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±', type: 'password' }
      },
      async authorize(credentials) {
        try {
          await loginRateLimiter.consume(credentials?.email || 'unknown')
          
          const validated = loginSchema.parse(credentials)
          const normalizedEmail = normalizeEmail(validated.email)

          const user = await prisma.user.findUnique({
            where: { email: normalizedEmail }
          })

          if (!user) {
            authLogger.warn({ email: normalizedEmail }, 'User not found')
            throw new Error('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£Ùˆ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©')
          }

          if (!user.isActive) {
            authLogger.warn({ userId: user.id }, 'Inactive account attempt')
            throw new Error('Ø§Ù„Ø­Ø³Ø§Ø¨ ØºÙŠØ± Ù†Ø´Ø·')
          }

          if (user.lockedUntil && user.lockedUntil > new Date()) {
            authLogger.warn({ userId: user.id }, 'Locked account attempt')
            throw new Error('Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…Ø¤Ù‚Øª Ù…ØºÙ„Ù‚ØŒ Ø­Ø§ÙˆÙ„ Ù„Ø§Ø­Ù‚Ø§Ù‹')
          }

          if (!user.passwordHash) {
            authLogger.warn({ userId: user.id }, 'No password hash for credentials login')
            throw new Error('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£Ùˆ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©')
          }

          const isValid = await comparePassword(validated.password, user.passwordHash)
          
          if (!isValid) {
            await prisma.user.update({
              where: { id: user.id },
              data: {
                loginAttempts: { increment: 1 },
                ...(user.loginAttempts + 1 >= 5 ? {
                  lockedUntil: new Date(Date.now() + 15 * 60 * 1000)
                } : {})
              }
            })
            authLogger.warn({ userId: user.id }, 'Invalid password attempt')
            throw new Error('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£Ùˆ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©')
          }

          await prisma.user.update({
            where: { id: user.id },
            data: {
              loginAttempts: 0,
              lockedUntil: null,
              lastLoginAt: new Date()
            }
          })

          authLogger.info({ userId: user.id }, 'User authenticated successfully')
          
          return {
            id: user.id,
            name: user.name,
            email: user.email,
            role: user.role as Role,
            phoneNumber: user.phoneNumber,
            age: user.age,
            description: user.description,
            skillLevel: user.skillLevel as SkillLevel,
            isActive: user.isActive,
            isVerified: user.emailVerified,
            lastLogin: user.lastLoginAt
          }

        } catch (error: any) {
          if (error instanceof Error && error.message.includes('RateLimiter')) {
            authLogger.warn({ email: credentials?.email }, 'Rate limit exceeded')
            throw new Error('Ù„Ù‚Ø¯ ØªØ¬Ø§ÙˆØ²Øª Ø§Ù„Ø­Ø¯ Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡ Ù…Ù† Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª')
          }
          authLogger.error({ error }, 'Authentication error')
          throw new Error(error.message || 'ÙØ´Ù„ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„')
        }
      }
    }),

    GoogleProvider({
      clientId: ENV.GOOGLE_CLIENT_ID || '',
      clientSecret: ENV.GOOGLE_CLIENT_SECRET || '',
      authorization: {
        params: {
          prompt: "consent",
          access_type: "offline",
          response_type: "code",
          scope: "openid email profile"
        }
      },
      async profile(profile) {
        const normalizedEmail = normalizeEmail(profile.email)
        
        try {
          let user = await prisma.user.findUnique({
            where: { email: normalizedEmail }
          })

          if (!user) {
            user = await prisma.user.create({
              data: {
                email: normalizedEmail,
                name: profile.name || profile.email.split('@')[0],
                passwordHash: null,
                phoneNumber: null,
                age: null,
                description: null,
                skillLevel: 'AVERAGE',
                role: 'PLAYER',
                isActive: true,
                emailVerified: true,
                lastLoginAt: new Date()
              }
            })
            authLogger.info({ userId: user.id }, 'New OAuth user created')
          } else {
            await prisma.user.update({
              where: { id: user.id },
              data: { 
                lastLoginAt: new Date(),
                name: profile.name || user.name
              }
            })
          }

          if (!user.isActive) {
            authLogger.warn({ userId: user.id }, 'Inactive OAuth account')
            throw new Error('Ø§Ù„Ø­Ø³Ø§Ø¨ ØºÙŠØ± Ù†Ø´Ø·')
          }

          authLogger.info({ userId: user.id }, 'OAuth user authenticated')
          
          return {
            id: user.id,
            name: user.name,
            email: user.email,
            role: user.role as Role,
            phoneNumber: user.phoneNumber,
            age: user.age,
            description: user.description,
            skillLevel: user.skillLevel as SkillLevel,
            isActive: user.isActive,
            isVerified: user.emailVerified,
            lastLogin: user.lastLoginAt
          }
        } catch (error: any) {
          authLogger.error({ error }, 'OAuth profile error')
          throw error
        }
      }
    })
  ],

  session: {
    strategy: 'jwt',
    maxAge: 30 * 24 * 60 * 60,
  },

  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id
        token.role = (user as any).role
        token.phoneNumber = (user as any).phoneNumber
        token.age = (user as any).age
        token.description = (user as any).description
        token.skillLevel = (user as any).skillLevel
        token.isActive = (user as any).isActive
        token.isVerified = (user as any).isVerified
        token.lastLogin = (user as any).lastLogin
      }
      return token
    },

    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.id as string
        session.user.role = token.role as Role
        session.user.phoneNumber = token.phoneNumber as string | null
        session.user.age = token.age as number | null
        session.user.description = token.description as string | null
        session.user.skillLevel = token.skillLevel as SkillLevel
        session.user.isActive = token.isActive as boolean
        session.user.isVerified = token.isVerified as boolean
        session.user.lastLogin = token.lastLogin as Date | null
      }
      return session
    },

    async redirect({ url, baseUrl }) {
      if (url.startsWith('/')) {
        return `${baseUrl}${url}`
      } else if (new URL(url).origin === baseUrl) {
        return url
      }
      return baseUrl
    }
  },

  pages: {
    signIn: '/login',
    signOut: '/login',
    error: '/login'
  },

  debug: ENV.NODE_ENV === 'development',
  secret: ENV.NEXTAUTH_SECRET
}
// lib/domain/slots/read-model.ts
import { SLOT_STATUS } from '@/lib/shared/constants'  // âœ… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯
import { DomainError } from '@/lib/core/errors/domain-errors'  // âœ… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯

export type UISlotView = {
  id: string
  startTime: Date
  endTime: Date
  uiStatus: 'AVAILABLE' | 'LOCKED_ME' | 'LOCKED_OTHER' | 'BOOKED'
  originalStatus: string
  price: number
  deposit: number
  metadata?: {
    needsConfirmation?: boolean
    lockedUntil?: Date
    lockedByUserId?: string
  }
}

export class SlotReadModel {
  static toUISlot(dbSlot: any, currentUserId?: string | null): UISlotView {
    const now = new Date()
    const startTime = new Date(dbSlot.startTime)
    
    const dbStatus = this.normalizeDbStatus(dbSlot.status)
    
    let uiStatus: UISlotView['uiStatus']
    let needsConfirmation = false

    switch (dbStatus) {
      case SLOT_STATUS.BOOKED:
        uiStatus = 'BOOKED'
        break

      case SLOT_STATUS.TEMP_LOCKED:
        if (dbSlot.lockedByUserId === currentUserId) {
          uiStatus = 'LOCKED_ME'
        } else {
          uiStatus = 'LOCKED_OTHER'
        }
        break

      case SLOT_STATUS.AVAILABLE:
        uiStatus = 'AVAILABLE'
        const diffHours = (startTime.getTime() - now.getTime()) / (1000 * 60 * 60)
        if (diffHours < 24) {
          needsConfirmation = true
        }
        break

      default:
        throw new DomainError(
          'SLOT_NOT_FOUND', 
          `Ø­Ø§Ù„Ø© ØºÙŠØ± Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„Ø¹Ø±Ø¶: ${dbSlot.status}`
        )
    }

    return {
      id: dbSlot.id,
      startTime,
      endTime: new Date(dbSlot.endTime),
      uiStatus,
      originalStatus: dbSlot.status,
      price: dbSlot.price,
      deposit: dbSlot.deposit,
      metadata: {
        needsConfirmation,
        lockedUntil: dbSlot.lockedUntil ? new Date(dbSlot.lockedUntil) : undefined,
        lockedById: null
dbSlot.lockedByUserId
      }
    }
  }
  
  private static normalizeDbStatus(dbStatus: string): string {
    switch (dbStatus) {
      case SLOT_STATUS.AVAILABLE:
      case 'AVAILABLE_NEEDS_CONFIRM':
      case 'PENDING_CONFIRMATION':
        return SLOT_STATUS.AVAILABLE
      case SLOT_STATUS.TEMP_LOCKED:
        return SLOT_STATUS.TEMP_LOCKED
      case SLOT_STATUS.BOOKED:
        return SLOT_STATUS.BOOKED
      case SLOT_STATUS.UNAVAILABLE:
        return SLOT_STATUS.UNAVAILABLE
      default:
        return SLOT_STATUS.UNAVAILABLE
    }
  }

  static filterVisibleSlots(dbSlots: any[], currentUserId?: string | null): UISlotView[] {
    return dbSlots
      .map((slot: any) => this.toUISlot(slot, currentUserId)) // âœ… Ø£Ø¶Ù type Ù‡Ù†Ø§
      .filter(slot => ['AVAILABLE', 'LOCKED_ME', 'LOCKED_OTHER', 'BOOKED'].includes(slot.uiStatus))
  }

  static async getAvailableSlots(fieldId: string, date: Date, userId?: string): Promise<UISlotView[]> {
    const { prisma } = await import('@/lib/infrastructure/database/prisma')  // âœ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ
    
    const dayStart = new Date(date.getFullYear(), date.getMonth(), date.getDate())
    const dayEnd = new Date(dayStart.getTime() + 24 * 60 * 60 * 1000)

    const dbSlots = await prisma.slot.findMany({
      where: {
        fieldId,
        startTime: {
          gte: dayStart,
          lt: dayEnd
        }
      },
      include: {
        bookings: {
          where: {
            status: { in: ['CONFIRMED', 'PENDING_PAYMENT'] }
          }
        }
      }
    })

    const availableSlots = dbSlots.filter((slot: any) => {
      // Ø§Ø³ØªØ¨Ø¹Ø§Ø¯ Ø§Ù„Ø³Ù„Ø§Øª Ø§Ù„Ù…Ø­Ø¬ÙˆØ²Ø©
      const hasActiveBooking = slot.bookings.length > 0
      if (hasActiveBooking) return false
      
      // Ø§Ø³ØªØ¨Ø¹Ø§Ø¯ Ø§Ù„Ø³Ù„Ø§Øª ØºÙŠØ± Ø§Ù„Ù…ØªØ§Ø­Ø©
      if (slot.status === SLOT_STATUS.UNAVAILABLE) return false
      
      // Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ø³Ù„Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© Ø£Ùˆ Ø§Ù„Ù…Ù‚ÙÙˆÙ„Ø© Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
      if (slot.status === SLOT_STATUS.TEMP_LOCKED && slot.lockedByUserId !== userId) {
        return false
      }
      
      return true
    })

    return this.filterVisibleSlots(availableSlots, userId)
  }
}

export function getUISlots(slots: any[], userId?: string): UISlotView[] {
  return SlotReadModel.filterVisibleSlots(slots, userId)
}
// lib/domain/slots/time-slots/core-logic.ts
import { addMinutes, startOfDay, addDays, getHours, getMinutes } from 'date-fns'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { SLOT_STATUS, FIELD_STATUS } from '@/lib/shared/constants'
import { DomainError } from '@/lib/core/errors/domain-errors'

// âœ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ù…ÙˆØ­Ø¯Ø© Ø£Ùˆ ØªØ¹Ø±ÙŠÙÙ‡Ø§ Ù…Ø­Ù„ÙŠØ§Ù‹ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©
import type { Day, Slot, SlotStatus } from '@/lib/core/types'

const CONFIRMATION_WINDOW_HOURS = 24
const LOCK_DURATION_MINUTES = 5

function normalizeToMinute(date: Date): number {
  return Math.floor(date.getTime() / 60000) * 60000
}

export function canBookDirectly(start: Date): boolean {
  const diffMs = start.getTime() - Date.now()
  const diffHours = diffMs / (1000 * 60 * 60)
  return diffHours >= CONFIRMATION_WINDOW_HOURS
}

function normalizeDbStatus(status: string | null | undefined): SlotStatus {
  if (!status) return SLOT_STATUS.AVAILABLE
  switch (status) {
    case SLOT_STATUS.AVAILABLE:
    case SLOT_STATUS.TEMP_LOCKED:
    case SLOT_STATUS.BOOKED:
    case SLOT_STATUS.UNAVAILABLE:
      return status as SlotStatus
    case 'AVAILABLE_NEEDS_CONFIRM':
    case 'PENDING_CONFIRMATION':
      return SLOT_STATUS.AVAILABLE as SlotStatus
    default:
      return SLOT_STATUS.UNAVAILABLE as SlotStatus
  }
}

function resolveSlotStatus({
  field,
  slotStart,
  dbSlot,
  now
}: {
  field: any
  slotStart: Date
  dbSlot?: any
  now: Date
}): SlotStatus | null {
  const diffMs = slotStart.getTime() - now.getTime()
  const diffHours = diffMs / (1000 * 60 * 60)

  if (diffHours < 0) return null

  if (field.status !== FIELD_STATUS.OPEN && !dbSlot) {
    return SLOT_STATUS.UNAVAILABLE as SlotStatus
  }

  if (dbSlot) {
    const dbStatus = normalizeDbStatus(dbSlot.status)

    if (
      dbStatus === SLOT_STATUS.TEMP_LOCKED &&
      dbSlot.lockedUntil &&
      new Date(dbSlot.lockedUntil) > now
    ) {
      return SLOT_STATUS.TEMP_LOCKED as SlotStatus
    }

    if (dbStatus === SLOT_STATUS.BOOKED) {
      return SLOT_STATUS.BOOKED as SlotStatus
    }

    if (dbStatus === SLOT_STATUS.UNAVAILABLE) {
      return SLOT_STATUS.UNAVAILABLE as SlotStatus
    }
  }

  return SLOT_STATUS.AVAILABLE as SlotStatus
}

export async function generateSlotsForDay({
  fieldId,
  date,
  now
}: {
  fieldId: string
  date: Date
  now: Date
}) {
  const field = await prisma.field.findUnique({
    where: { id: fieldId }
  })

  if (!field) {
    throw new DomainError('FIELD_NOT_FOUND')
  }

  const dayStart = startOfDay(date)
  const dayEnd = addDays(dayStart, 1)

  const existingSlots = await prisma.slot.findMany({
    where: {
      fieldId,
      startTime: {
        gte: dayStart,
        lt: dayEnd
      }
    }
  })

  const slotsMap = new Map<number, any>(
    existingSlots.map((slot: any) => [
      normalizeToMinute(new Date(slot.startTime)),
      slot
    ])
  )

  const openH = getHours(field.openingTime)
  const openM = getMinutes(field.openingTime)
  const closeH = getHours(field.closingTime)
  const closeM = getMinutes(field.closingTime)

  let current = startOfDay(date)
  current.setHours(openH, openM, 0, 0)

  const end = startOfDay(date)
  end.setHours(closeH, closeM, 0, 0)

  const slots: Slot[] = []

  while (addMinutes(current, field.slotDurationMin) <= end) {
    const slotStart = new Date(current)
    const slotEnd = addMinutes(slotStart, field.slotDurationMin)

    const key = normalizeToMinute(slotStart)
    const dbSlot = slotsMap.get(key)

    const status = resolveSlotStatus({
      field,
      slotStart,
      dbSlot,
      now
    })

    if (status) {
      slots.push({
        id: dbSlot?.id ?? `${fieldId}-${slotStart.toISOString()}`,
        fieldId,
        startTime: slotStart,
        endTime: slotEnd,
        status,
        price: field.pricePerHour,
        deposit: field.depositPrice
      } as Slot)
    }

    current = slotEnd
  }

  return slots
}

export async function generateSlotsForRange({
  fieldId,
  startDate,
  endDate,
  now
}: {
  fieldId: string
  startDate: Date
  endDate: Date
  now: Date
}) {
  const allSlots: Slot[] = []
  let currentDate = startOfDay(startDate)

  while (currentDate <= endDate) {
    const daySlots = await generateSlotsForDay({
      fieldId,
      date: currentDate,
      now
    })

    allSlots.push(...daySlots)
    currentDate = addDays(currentDate, 1)
  }

  return allSlots
}

export async function lockSlot({
  slotId,
  userId
}: {
  slotId: string
  userId: string
}) {
  const now = new Date()

  return await prisma.$transaction(async (tx: any) => {
    const slot = await tx.slot.findUnique({
      where: { id: slotId }
    })

    if (!slot) {
      throw new DomainError('SLOT_NOT_FOUND')
    }

    const status = normalizeDbStatus(slot.status)
    const canLock = status === SLOT_STATUS.AVAILABLE

    if (!canLock) {
      throw new DomainError('SLOT_UNAVAILABLE')
    }

    await tx.slot.update({
      where: { id: slotId },
      data: {
        status: SLOT_STATUS.TEMP_LOCKED,
        lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES),
        lockedById: null
userId
      }
    })

    return { success: true }
  })
}

// âœ… ØªØ¹Ø¯ÙŠÙ„ generateNextDays Ù„ÙŠÙˆÙ„Ù‘Ø¯ ÙƒÙ„ Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
export function generateNextDays(count: number = 10): Day[] {
  const days: Day[] = []
  const today = startOfDay(new Date())

  for (let i = 0; i < count; i++) {
    const date = addDays(today, i)

    const weekday = date.toLocaleDateString('ar-EG', { weekday: 'long' })
    const dayNumber = date.toLocaleDateString('ar-EG', { day: 'numeric' })
    const monthName = date.toLocaleDateString('ar-EG', { month: 'long' })

    days.push({
      date: date.toISOString(),
      isWeekend: [5, 6].includes(date.getDay()), // Ø§Ù„Ø¬Ù…Ø¹Ø©/Ø§Ù„Ø³Ø¨Øª
      slotsAvailable: 0,
      slots: [],
      isToday: i === 0,
      isTomorrow: i === 1,
      weekday,
      dayNumber,
      monthName
    } as Day)
  }

  return days
}

export function generateNextTenDays(): Day[] {
 //lib/domain/slots/time-slots/booking-limits.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { startOfDay, addDays } from 'date-fns'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { BOOKING_STATUS } from '@/lib/shared/constants'

type BookingWithSlot = {
  slot: {
    startTime: Date
    endTime: Date
    durationMinutes: number | null
  }
}

export async function checkBookingLimits({
  userId,
  slotDate,
  slotDurationMin
}: {
  userId: string
  slotDate: Date
  slotDurationMin: number
}) {
  const dayStart = startOfDay(slotDate)
  const dayEnd = addDays(dayStart, 1)

  const dayOfWeek = dayStart.getDay()
  const weekStart = addDays(dayStart, -dayOfWeek)
  const weekEnd = addDays(weekStart, 7)

  const dailyBookings: BookingWithSlot[] = await prisma.booking.findMany({
    where: {
      userId,
      status: {
        in: [BOOKING_STATUS.CONFIRMED, BOOKING_STATUS.PENDING_PAYMENT]
      },
      slot: {
        startTime: { gte: dayStart, lt: dayEnd }
      }
    },
    include: {
      slot: {
        select: {
          startTime: true,
          endTime: true,
          durationMinutes: true
        }
      }
    }
  })

  const dailyMinutes = dailyBookings.reduce((sum: number, booking: BookingWithSlot) => {
    if (booking.slot.durationMinutes) {
      return sum + booking.slot.durationMinutes
    }
    const start = new Date(booking.slot.startTime)
    const end = new Date(booking.slot.endTime)
    const diffMinutes = Math.round((end.getTime() - start.getTime()) / (1000 * 60))
    return sum + diffMinutes
  }, 0)

  if (dailyMinutes + slotDurationMin > 120) {
    throw new DomainError('BOOKING_LIMIT_EXCEEDED', 'ÙˆØµÙ„Øª Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ø§Ù„ÙŠÙˆÙ…ÙŠ (Ø³Ø§Ø¹ØªÙŠÙ†)')
  }

  const weeklyBookings: BookingWithSlot[] = await prisma.booking.findMany({
    where: {
      userId,
      status: {
        in: [BOOKING_STATUS.CONFIRMED, BOOKING_STATUS.PENDING_PAYMENT]
      },
      slot: {
        startTime: { gte: weekStart, lt: weekEnd }
      }
    },
    include: {
      slot: {
        select: {
          startTime: true,
          endTime: true,
          durationMinutes: true
        }
      }
    }
  })

  const weeklyMinutes = weeklyBookings.reduce((sum: number, booking: BookingWithSlot) => {
    if (booking.slot.durationMinutes) {
      return sum + booking.slot.durationMinutes
    }
    const start = new Date(booking.slot.startTime)
    const end = new Date(booking.slot.endTime)
    const diffMinutes = Math.round((end.getTime() - start.getTime()) / (1000 * 60))
    return sum + diffMinutes
  }, 0)

  if (weeklyMinutes + slotDurationMin > 240) {
    throw new DomainError('BOOKING_LIMIT_EXCEEDED', 'ÙˆØµÙ„Øª Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ÙŠ (4 Ø³Ø§Ø¹Ø§Øª)')
  }

  return true
}
// lib/domain/guards/slot-guards.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { SLOT_STATUS } from '@/lib/shared/constants'
import { StateTransitionValidator } from '@/lib/application/services/booking-transitions'

export class SlotStateGuard {
  static async assertCanBeLocked(params: {
    slotId: string
    userId: string
    fieldId: string
  }) {
    const slot = await prisma.slot.findUnique({
      where: { id: params.slotId },
      include: { field: true }
    })

    if (!slot) {
      throw new DomainError('SLOT_NOT_FOUND')
    }

    if (slot.fieldId !== params.fieldId) {
      throw new DomainError('SLOT_NOT_FOUND', 'Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù„Ø§ ÙŠÙ†ØªÙ…ÙŠ Ù„Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ø¹Ø¨')
    }

    const now = new Date()

    if (slot.status === SLOT_STATUS.BOOKED) {
      throw new DomainError('SLOT_ALREADY_BOOKED')
    }

    // Ø¥ØµÙ„Ø§Ø­: Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©
    if (slot.status === SLOT_STATUS.UNAVAILABLE) {
      throw new DomainError('SLOT_UNAVAILABLE')
    }

    if (new Date(slot.startTime) <= now) {
      throw new DomainError('TIME_IN_PAST')
    }

    if (slot.status === SLOT_STATUS.TEMP_LOCKED && slot.lockedUntil && slot.lockedUntil > now) {
      if (slot.lockedByUserId === params.userId) {
        return { slot, canExtend: true }
      } else {
        throw new DomainError('SLOT_LOCKED_BY_OTHER')
      }
    }

    return { slot, canExtend: false }
  }

  static async assertIsLockedToUser(params: {
    slotId: string
    userId: string
  }) {
    const slot = await prisma.slot.findUnique({
      where: { id: params.slotId }
    })

    if (!slot) {
      throw new DomainError('SLOT_NOT_FOUND')
    }

    const now = new Date()

    // Ø¥ØµÙ„Ø§Ø­: Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© Ù…Ø¹ Ø§Ù„Ø«Ø§Ø¨Øª
    if (slot.status !== SLOT_STATUS.TEMP_LOCKED) {
      throw new DomainError('SLOT_CANNOT_BE_LOCKED', 'Ø§Ù„Ù…ÙˆØ¹Ø¯ ØºÙŠØ± Ù…Ù‚ÙÙˆÙ„')
    }

    if (!slot.lockedUntil || slot.lockedUntil <= now) {
      throw new DomainError('SLOT_LOCK_EXPIRED')
    }

    if (slot.lockedByUserId !== params.userId) {
      throw new DomainError('SLOT_LOCKED_BY_OTHER')
    }

    return slot
  }

  static async assertCanTransition(params: {
    slotId: string
    targetStatus: string
    userId?: string
  }) {
    const slot = await prisma.slot.findUnique({
      where: { id: params.slotId }
    })

    if (!slot) {
      throw new DomainError('SLOT_NOT_FOUND')
    }

    // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù€ validator Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ø§Ù„Ø°ÙŠ ÙŠØ±Ù…ÙŠ DomainError
    StateTransitionValidator.validateSlotTransition(
      slot.status,
      params.targetStatus,
      params.userId,
      slot
    )

    return slot
  }

  static async cleanupExpiredLocks() {
    const now = new Date()
    
    const result = await prisma.slot.updateMany({
      where: {
        status: SLOT_STATUS.TEMP_LOCKED,
        lockedUntil: { lt: now }
      },
      data: {
        status: SLOT_STATUS.AVAILABLE,
        lockedById: null,
        lockedUntil: null
      }
    })

    return result.count
  }
}

export const assertSlotCanLock = SlotStateGuard.assertCanBeLocked.bind(SlotStateGuard)
export const assertSlotLocked = SlotStateGuard.assertIsLockedToUser.bind(SlotStateGuard)
export const assertSlotTransition = SlotStateGuard.assertCanTransition.bind(SlotStateGuard)
// lib/domain/guards/payment-guards.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { 
  PAYMENT_STATUS, 
  PaymentStatus,   // âœ… Ø§Ù„Ù†ÙˆØ¹ Ø¬Ø§Ù‡Ø² Ù…Ù† constants
  BOOKING_STATUS
} from '@/lib/shared/constants'
import { StateTransitionValidator } from '@/lib/application/services/booking-transitions'

export class PaymentStateGuard {
  static async assertCanProcessPayment(params: {
    bookingId: string
    userId: string
  }) {
    const booking = await prisma.booking.findUnique({
      where: { id: params.bookingId },
      include: {
        slot: true,
        payments: {
          orderBy: { createdAt: 'desc' },
          take: 1
        }
      }
    })

    if (!booking) throw new DomainError('BOOKING_NOT_FOUND')
    if (booking.userId !== params.userId) throw new DomainError('BOOKING_NOT_OWNED')

    if (booking.status !== BOOKING_STATUS.DRAFT) {
      throw new DomainError(
        'BOOKING_INVALID_STATE',
        `Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„Ø¯ÙØ¹ Ù„Ø­Ø¬Ø² Ø¨Ø­Ø§Ù„Ø© ${booking.status}`
      )
    }

    if (booking.expiresAt && booking.expiresAt < new Date()) {
      throw new DomainError('BOOKING_EXPIRED')
    }

    if (booking.slot.status !== 'TEMP_LOCKED') {
      throw new DomainError('SLOT_LOCK_EXPIRED')
    }

    const lastPayment = booking.payments[0]
    if (lastPayment?.status === PAYMENT_STATUS.PAID) {
      throw new DomainError('PAYMENT_ALREADY_PROCESSED')
    }

    return { booking, lastPayment }
  }

  static async assertCanUpdatePayment(params: {
    paymentId: string
    targetStatus: PaymentStatus   // âœ… Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„ØµØ­ÙŠØ­
    orderId?: string
  }) {
    const payment = await prisma.payment.findUnique({
      where: { id: params.paymentId },
      include: { booking: true }
    })

    if (!payment) throw new DomainError('PAYMENT_NOT_FOUND')

    if (params.orderId) {
      const existingWithOrderId = await prisma.payment.findUnique({
        where: { orderId: params.orderId }
      })
      
      if (existingWithOrderId && existingWithOrderId.id !== payment.id) {
        throw new DomainError('DUPLICATE_PAYMENT', 'ØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… orderId Ù…Ø³Ø¨Ù‚Ø§Ù‹')
      }
    }

    const validation = StateTransitionValidator.validatePaymentTransition(
      payment.status,
      params.targetStatus,
      payment
    )

    if (!validation.allowed) {
      throw new DomainError('PAYMENT_FAILED', validation.reason)
    }

    return payment
  }

  static async assertWebhookValid(params: {
    orderId: string
    transactionId: string
    amount: number
  }) {
    const existingPayment = await prisma.payment.findUnique({
      where: { orderId: params.orderId }
    })

    if (existingPayment) {
      if (existingPayment.status === PAYMENT_STATUS.PAID) {
        throw new DomainError('PAYMENT_ALREADY_PROCESSED')
      }
      
      if (existingPayment.paymentId === params.transactionId) {
        throw new DomainError('DUPLICATE_PAYMENT', 'ØªÙ… Ù…Ø¹Ø§Ù„Ø¬Ø© Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ù…Ø³Ø¨Ù‚Ø§Ù‹')
      }
    }

    const payment = await prisma.payment.findFirst({
      where: { 
        orderId: params.orderId,
        status: PAYMENT_STATUS.PROCESSING
      },
      include: { 
        booking: {
          include: {
            slot: true,
            user: true
          }
        }
      }
    })

    if (!payment) {
      throw new DomainError('PAYMENT_NOT_FOUND', `Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¯ÙØ¹Ø© Ø¨ orderId: ${params.orderId}`)
    }

    if (payment.amount !== params.amount) {
      throw new DomainError(
        'PAYMENT_FAILED',
        `Ø§Ù„Ù…Ø¨Ù„Øº ØºÙŠØ± Ù…ØªØ·Ø§Ø¨Ù‚: Ø§Ù„Ù…ØªÙˆÙ‚Ø¹ ${payment.amount}ØŒ Ø§Ù„Ù…Ø³ØªÙ„Ù… ${params.amount}`
      )
    }

    if (payment.booking.status !== BOOKING_STATUS.PENDING_PAYMENT) {
      throw new DomainError(
        'BOOKING_INVALID_STATE',
        `Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø¬Ø² ØºÙŠØ± Ù…Ù†Ø§Ø³Ø¨Ø©: ${payment.booking.status}`
      )
    }

    return payment
  }

  static async validatePaymentDetails(params: {
    paymentId: string
    userId: string
  }) {
    const payment = await prisma.payment.findUnique({
      where: { id: params.paymentId },
      include: { booking: true }
    })

    if (!payment) throw new DomainError('PAYMENT_NOT_FOUND')
    if (payment.booking.userId !== params.userId) throw new DomainError('BOOKING_NOT_OWNED')

    return payment
  }
}

// âœ… Bind Ø§Ù„Ø¯ÙˆØ§Ù„ Ø¹Ù„Ø´Ø§Ù† ØªØ³ØªØ®Ø¯Ù… Ø¨Ø³Ù‡ÙˆÙ„Ø©
export const assertPaymentCanProcess = PaymentStateGuard.assertCanProcessPayment.bind(PaymentStateGuard)
export const assertPaymentUpdate = PaymentStateGuard.assertCanUpdatePayment.bind(PaymentStateGuard)
export const assertWebhookValid = PaymentStateGuard.assertWebhookValid.bind(PaymentStateGuard)
export const validatePaymentDetails = PaymentStateGuard.validatePaymentDetails.bind(PaymentStateGuard)
// lib/domain/guards/index.ts
export { 
  BookingGuard,
  assertBooking,
  assertSlotLocked,
  assertSlotCanLock 
} from './booking-guards'

export { 
  SlotStateGuard,
  assertSlotTransition 
} from './slot-guards'

export { 
  PaymentStateGuard,
  assertPaymentCanProcess,
  assertPaymentUpdate,
  assertWebhookValid 
} from './payment-guards'
// lib/domain/guards/booking-guards.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { SLOT_STATUS, BOOKING_STATUS } from '@/lib/shared/constants'
import { StateTransitionValidator } from '@/lib/application/services/booking-transitions'

export class BookingGuard {
  static async assertBookingState(params: {
    bookingId: string
    expectedStatuses: BookingStatus[]
    userId?: string
    customCheck?: (booking: any) => Promise<void>
  }) {
    const booking = await prisma.booking.findUnique({
      where: { id: params.bookingId },
      include: { 
        slot: true, 
        field: true,
        payments: {
          orderBy: { createdAt: 'desc' },
          take: 1
        }
      }
    })

    if (!booking) {
      throw new DomainError('BOOKING_NOT_FOUND')
    }

    if (params.userId && booking.userId !== params.userId) {
      throw new DomainError('BOOKING_NOT_OWNED')
    }

    if (!params.expectedStatuses.includes(booking.status as BookingStatus)) {
      throw new DomainError(
        'BOOKING_INVALID_STATE',
        `Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© (${booking.status}) Ù„Ø§ ØªØ³Ù…Ø­ Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©. ` +
        `Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ù…Ø³Ù…ÙˆØ­Ø©: ${params.expectedStatuses.join(', ')}`
      )
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© ØªØ¯ÙÙ‚ Ø§Ù„Ø­Ø§Ù„Ø§Øª
    try {
      const slotValidation = StateTransitionValidator.validateCompleteBookingFlow(
        booking.slot.status as SlotStatus,
        booking.status as BookingStatus,
        booking.paymentStatus as PaymentStatus
      )
    } catch (error: any) {
      throw new DomainError('BOOKING_INVALID_STATE', error.message)
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¢Ø®Ø± Ø¯ÙØ¹
    const lastPayment = booking.payments[0]
    if (lastPayment) {
      try {
        const paymentValidation = StateTransitionValidator.validatePaymentTransition(
          lastPayment.status as PaymentStatus,
          booking.paymentStatus as PaymentStatus,
          lastPayment
        )
      } catch (error: any) {
        throw new DomainError('PAYMENT_FAILED', error.message)
      }
    }

    if (params.customCheck) {
      await params.customCheck(booking)
    }

    return booking
  }

  static async assertSlotLockedToUser(params: {
    slotId: string
    userId: string
  }) {
    const slot = await prisma.slot.findUnique({
      where: { id: params.slotId },
      include: {
        field: {
          select: { id: true, name: true }
        }
      }
    })

    if (!slot) {
      throw new DomainError('SLOT_NOT_FOUND')
    }

    const now = new Date()

    if (slot.status !== SLOT_STATUS.TEMP_LOCKED) {
      throw new DomainError('SLOT_CANNOT_BE_LOCKED')
    }

    if (!slot.lockedUntil || slot.lockedUntil <= now) {
      throw new DomainError('SLOT_LOCK_EXPIRED')
    }

    if (slot.lockedByUserId !== params.userId) {
      throw new DomainError('SLOT_LOCKED_BY_OTHER', 
        `Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù…Ù‚ÙÙˆÙ„ Ø¨ÙˆØ§Ø³Ø·Ø© Ù…Ø³ØªØ®Ø¯Ù… Ø¢Ø®Ø±. Ø§Ù„Ù…Ù„Ø¹Ø¨: ${slot.field?.name || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}`
      )
    }

    return slot
  }

  static async assertSlotCanBeLocked(params: {
    slotId: string
    userId: string
  }) {
    const slot = await prisma.slot.findUnique({
      where: { id: params.slotId },
      include: {
        field: {
          select: { id: true, name: true, status: true }
        }
      }
    })

    if (!slot) {
      throw new DomainError('SLOT_NOT_FOUND')
    }

    const now = new Date()

    if (slot.field?.status !== 'OPEN') {
      throw new DomainError(
        'FIELD_NOT_FOUND',
        `Ø§Ù„Ù…Ù„Ø¹Ø¨ ${slot.field?.name || ''} ØºÙŠØ± Ù…ØªØ§Ø­ Ø­Ø§Ù„ÙŠØ§Ù‹`
      )
    }

    if (slot.status === SLOT_STATUS.BOOKED) {
      throw new DomainError('SLOT_ALREADY_BOOKED')
    }

    if (slot.status === SLOT_STATUS.UNAVAILABLE) {
      throw new DomainError('SLOT_UNAVAILABLE')
    }

    if (new Date(slot.startTime) <= now) {
      throw new DomainError('TIME_IN_PAST')
    }

    if (
      slot.status === SLOT_STATUS.TEMP_LOCKED &&
      slot.lockedUntil &&
      slot.lockedUntil > now
    ) {
      if (slot.lockedByUserId === params.userId) {
        return { slot, canExtend: true }
      } else {
        throw new DomainError('SLOT_LOCKED_BY_OTHER')
      }
    }

    return { slot, canExtend: false }
  }

  static async assertBookingLimits(params: {
    userId: string
    date: Date
    maxDailyBookings?: number
    maxWeeklyBookings?: number
  }) {
    const startOfDay = new Date(params.date)
    startOfDay.setHours(0, 0, 0, 0)
    
    const endOfDay = new Date(params.date)
    endOfDay.setHours(23, 59, 59, 999)

    const startOfWeek = new Date(params.date)
    startOfWeek.setDate(startOfWeek.getDate() - startOfWeek.getDay())
    startOfWeek.setHours(0, 0, 0, 0)
    
    const endOfWeek = new Date(startOfWeek)
    endOfWeek.setDate(endOfWeek.getDate() + 6)
    endOfWeek.setHours(23, 59, 59, 999)

    // Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
    const dailyBookings = await prisma.booking.count({
      where: {
        userId: params.userId,
        createdAt: {
          gte: startOfDay,
          lte: endOfDay
        },
        status: {
          in: [BOOKING_STATUS.CONFIRMED, BOOKING_STATUS.PENDING_PAYMENT]
        }
      }
    })

    // Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ÙŠØ©
    const weeklyBookings = await prisma.booking.count({
      where: {
        userId: params.userId,
        createdAt: {
          gte: startOfWeek,
          lte: endOfWeek
        },
        status: {
          in: [BOOKING_STATUS.CONFIRMED, BOOKING_STATUS.PENDING_PAYMENT]
        }
      }
    })

    const maxDaily = params.maxDailyBookings || 2
    const maxWeekly = params.maxWeeklyBookings || 5

    if (dailyBookings >= maxDaily) {
      throw new DomainError(
        'BOOKING_LIMIT_EXCEEDED',
        `ÙˆØµÙ„Øª Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø­Ø¬ÙˆØ²Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ© (${maxDaily})`
      )
    }

    if (weeklyBookings >= maxWeekly) {
      throw new DomainError(
        'BOOKING_LIMIT_EXCEEDED',
        `ÙˆØµÙ„Øª Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø­Ø¬ÙˆØ²Ø§Øª Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ÙŠØ© (${maxWeekly})`
      )
    }

    return { dailyBookings, weeklyBookings }
  }
}

export const assertBooking = BookingGuard.assertBookingState.bind(BookingGuard)
export const assertSlotLocked = BookingGuard.assertSlotLockedToUser.bind(BookingGuard)
export const assertSlotCanLock = BookingGuard.assertSlotCanBeLocked.bind(BookingGuard)
export const assertBookingLimits = BookingGuard.assertBookingLimits.bind(BookingGuard)
// lib/domain/booking/types.ts
import { 
  BookingStatus, 
  PaymentStatus 
} from '@/lib/shared/constants'  // âœ… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯

export interface BookingCreateInput {
  slotId: string
  fieldId: string
  userId: string
  idempotencyKey?: string
}

export interface BookingCreateResult {
  bookingId: string
  needsConfirmation: boolean
  idempotencyKey?: string
}

export interface BookingUpdateInput {
  bookingId: string
  status?: BookingStatus
  paymentStatus?: PaymentStatus
  paymentId?: string
  orderId?: string
}

export interface PaymentInitInput {
  bookingId: string
  amount: number
  currency?: string
  idempotencyKey?: string
}

export interface PaymentInitResult {
  paymentUrl: string
  orderId: string
  idempotencyKey?: string
}

export interface SlotLockInput {
  slotId: string
  userId: string
  fieldId: string
}

export interface SlotLockResult {
  success: boolean
  locked?: boolean
  extended?: boolean
  lockedUntil?: Date
}

// Response types for APIs
export interface ApiResponse<T = any> {
  success: boolean
  data?: T
  error?: {
    code: string
    message: string
    details?: any
  }
  pagination?: {
    page: number
    limit: number
    total: number
    totalPages: number
    hasMore: boolean
  }
}

// Webhook types
export interface PaymobWebhookPayload {
  obj: {
    id: number
    amount_cents: number
    success: boolean
    order: {
      id: number
      merchant_order_id: string
    }
    created_at: number
    currency: string
    source_data?: any
  }
}

export type BookingWithRelations = any // Ø³ÙŠØ­Ø¯Ø¯ Ù…Ù† Prisma
export type SlotWithRelations = any
// lib/core/types/index.ts
import { 
  SlotStatus,
  BookingStatus,
  FieldStatus,
  FieldType,
  PaymentStatus,
  NotificationType,
  UserRole,
  SkillLevel
} from '@/lib/shared/constants'

// Re-export Ø§Ù„Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
export type { 
  SlotStatus,
  BookingStatus,
  FieldStatus,
  FieldType,
  PaymentStatus,
  NotificationType,
  UserRole,
  SkillLevel
}

export interface User {
  id: string
  email: string
  name: string
  phoneNumber?: string | null
  avatarUrl?: string | null
  age?: number | null
  description?: string | null
  skillLevel?: SkillLevel
  role: UserRole
  isActive: boolean
  isVerified: boolean
  lastLogin?: Date | null
  createdAt: Date
  updatedAt: Date
}

export interface Field {
  id: string
  name: string
  description?: string | null
  location: string
  address?: string | null
  pricePerHour: number
  depositPrice: number
  mainImage?: string | null
  gallery: string[]
  type: FieldType
  status: FieldStatus
  openingTime: string
  closingTime: string
  slotDurationMin: number
  facilities: string[]
  capacity?: number | null
  rating?: number
  reviewCount?: number
  createdAt: Date
  updatedAt: Date
}

export interface Slot {
  id: string
  fieldId: string
  startTime: Date
  endTime: Date
  status: SlotStatus
  price: number
  deposit: number
  lockedUntil?: Date
  lockedById?: string
  isPeakHour: boolean
  discount: number
  createdAt: Date
  updatedAt: Date
}

export interface Booking {
  id: string
  userId: string
  fieldId: string
  slotId: string
  status: BookingStatus
  paymentStatus: PaymentStatus
  totalAmount: number
  depositPaid: number
  expiresAt?: Date
  confirmedAt?: Date
  cancelledAt?: Date
  completedAt?: Date
  createdAt: Date
  updatedAt: Date
  field?: Field
  slot?: Slot
  user?: User
}

export interface Payment {
  id: string
  bookingId: string
  amount: number
  currency: string
  gatewayId?: string
  orderId?: string
  transactionId?: string
  status: PaymentStatus
  metadata?: Record<string, any>
  receiptUrl?: string
  createdAt: Date
  updatedAt: Date
  paidAt?: Date
  refundedAt?: Date
}

// âœ… Day type Ù…ØªÙˆØ§ÙÙ‚ Ù…Ø¹ DaySelector
export interface Day {
  date: string
  isWeekend: boolean
  slotsAvailable: number
  slots?: Slot[]
  isToday?: boolean
  isTomorrow?: boolean
  weekday?: string
  dayNumber?: string
  monthName?: string
}

// âœ… SlotGridProps Ù…Ø¹ userId Ø§Ø®ØªÙŠØ§Ø±ÙŠ
export interface SlotGridProps {
  slots: Slot[]
  fieldId: string
  fieldName: string
  userId?: string
  onSlotSelect?: (slot: Slot) => void
}

// âœ… UI Types
export interface UISlot {
  id: string
  startTime: Date
  endTime: Date
  price: number
  deposit: number
  uiStatus: 'AVAILABLE' | 'LOCKED_ME' | 'LOCKED_OTHER' | 'BOOKED'
  needsConfirmation: boolean
  metadata?: {
    lockedUntil?: Date
    lockedByUserId?: string
  }
}

export interface SlotBookingModalProps {
  slot: UISlot
  fieldId: string
  fieldName: string
  onClose: () => void
}
// lib/core/errors/error-codes.ts
export const ERROR_CODES = {
  // Auth (1xx)
  UNAUTHORIZED: 'AUTH_001',
  INVALID_CREDENTIALS: 'AUTH_002',
  SESSION_EXPIRED: 'AUTH_003',
  
  // Validation (2xx)
  VALIDATION_ERROR: 'VAL_004', // âœ… Ø£Ø¶Ù Ù‡Ø°Ø§
  INVALID_INPUT: 'VAL_001',
  MISSING_FIELD: 'VAL_002',
  INVALID_DATE: 'VAL_003',
  
  // Slot (3xx)
  SLOT_NOT_FOUND: 'SLOT_001',
  SLOT_UNAVAILABLE: 'SLOT_002',
  SLOT_LOCKED_BY_OTHER: 'SLOT_003',
  SLOT_LOCK_EXPIRED: 'SLOT_004',
  SLOT_ALREADY_BOOKED: 'SLOT_005',
  SLOT_CANNOT_BE_LOCKED: 'SLOT_006',
  
  // Booking (4xx)
  BOOKING_NOT_FOUND: 'BOOK_001',
  BOOKING_NOT_OWNED: 'BOOK_002',
  BOOKING_INVALID_STATE: 'BOOK_003',
  BOOKING_LIMIT_EXCEEDED: 'BOOK_004',
  BOOKING_EXPIRED: 'BOOK_005',
  BOOKING_IN_PROGRESS: 'BOOK_006',
  
  // Payment (5xx)
  PAYMENT_ALREADY_PROCESSED: 'PAY_001',
  PAYMENT_FAILED: 'PAY_002',
  DUPLICATE_PAYMENT: 'PAY_003',
  PAYMENT_NOT_FOUND: 'PAY_004',
  
  // Time (6xx)
  TIME_IN_PAST: 'TIME_001',
  TIME_TOO_CLOSE: 'TIME_002',
  
  // Field (7xx)
  FIELD_NOT_FOUND: 'FIELD_001',
  FIELD_CLOSED: 'FIELD_002',
  FIELD_MAINTENANCE: 'FIELD_003',
  
  // System (9xx)
  INTERNAL_ERROR: 'SYS_001',
  RATE_LIMITED: 'SYS_002',
  SERVICE_UNAVAILABLE: 'SYS_003'
} as const

export type ErrorCode = typeof ERROR_CODES[keyof typeof ERROR_CODES]
export type ErrorCodeKey = keyof typeof ERROR_CODES
import { ERROR_CODES, type ErrorCode } from '@/lib/shared/constants'

const ERROR_MESSAGES: Record<ErrorCode, string> = {
  // Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
  VALIDATION_ERROR: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª',
  AUTHENTICATION_ERROR: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø©',
  AUTHORIZATION_ERROR: 'ØºÙŠØ± Ù…ØµØ±Ø­',
  NOT_FOUND: 'ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯',
  CONFLICT: 'ØªØ¹Ø§Ø±Ø¶',
  RATE_LIMIT_EXCEEDED: 'ØªÙ… ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ Ø§Ù„Ù…Ø³Ù…ÙˆØ­',
  TOKEN_EXPIRED: 'Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø±Ù…Ø²',
  INVALID_TOKEN: 'Ø±Ù…Ø² ØºÙŠØ± ØµØ§Ù„Ø­',
  SERVER_ERROR: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…',
  
  // Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…Ù„Ø§Ø¹Ø¨
  FIELD_NOT_FOUND: 'Ø§Ù„Ù…Ù„Ø¹Ø¨ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯',
  FIELD_CLOSED: 'Ø§Ù„Ù…Ù„Ø¹Ø¨ Ù…ØºÙ„Ù‚ Ø­Ø§Ù„ÙŠØ§Ù‹',
  FIELD_MAINTENANCE: 'Ø§Ù„Ù…Ù„Ø¹Ø¨ ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©',
  
  // Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯
  SLOT_NOT_FOUND: 'Ø§Ù„Ù…ÙˆØ¹Ø¯ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯',
  SLOT_ALREADY_BOOKED: 'Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù…Ø­Ø¬ÙˆØ² Ø¨Ø§Ù„ÙØ¹Ù„',
  SLOT_UNAVAILABLE: 'Ø§Ù„Ù…ÙˆØ¹Ø¯ ØºÙŠØ± Ù…ØªØ§Ø­ Ù„Ù„Ø­Ø¬Ø²',
  SLOT_LOCKED_BY_OTHER: 'Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù…Ù‚ÙÙˆÙ„ Ù…Ø¤Ù‚ØªØ§Ù‹',
  SLOT_CANNOT_BE_LOCKED: 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ù‚ÙÙ„ Ù‡Ø°Ø§ Ø§Ù„Ù…ÙˆØ¹Ø¯',
  SLOT_LOCK_EXPIRED: 'Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù‚ÙÙ„',
  
  // Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª
  BOOKING_NOT_FOUND: 'Ø§Ù„Ø­Ø¬Ø² ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯',
  BOOKING_NOT_OWNED: 'ØºÙŠØ± Ù…ØµØ±Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù‡Ø°Ø§ Ø§Ù„Ø­Ø¬Ø²',
  BOOKING_INVALID_STATE: 'Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„Ø§ ØªØ³Ù…Ø­ Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©',
  BOOKING_IN_PROGRESS: 'Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø·Ù„Ø¨',
  BOOKING_EXPIRED: 'Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø­Ø¬Ø²',
  BOOKING_LIMIT_EXCEEDED: 'ÙˆØµÙ„Øª Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø­Ø¬Ø²',
  
  // Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø¯ÙØ¹
  PAYMENT_ALREADY_PROCESSED: 'ØªÙ… Ø¯ÙØ¹ Ù‡Ø°Ø§ Ø§Ù„Ø­Ø¬Ø² Ù…Ø³Ø¨Ù‚Ø§Ù‹',
  PAYMENT_FAILED: 'ÙØ´Ù„ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¯ÙØ¹',
  DUPLICATE_PAYMENT: 'ØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… orderId Ù…Ø³Ø¨Ù‚Ø§Ù‹',
  PAYMENT_NOT_FOUND: 'Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¯ÙØ¹ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©',
  
  // Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„ÙˆÙ‚Øª
  TIME_IN_PAST: 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø¬Ø² ÙˆÙ‚Øª Ù…Ø¶Ù‰',
  TIME_TOO_CLOSE: 'Ø§Ù„ÙˆÙ‚Øª Ù‚Ø±ÙŠØ¨ Ø¬Ø¯Ø§Ù‹',
  INVALID_DATE: 'ØªØ§Ø±ÙŠØ® ØºÙŠØ± ØµØ§Ù„Ø­',
  
  // Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„ØªØ­Ù‚Ù‚
  INVALID_INPUT: 'Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ§Ù„Ø­Ø©',
  MISSING_FIELD: 'Ø­Ù‚Ù„ Ù…Ø·Ù„ÙˆØ¨',
  
  // Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø©
  UNAUTHORIZED: 'ØºÙŠØ± Ù…ØµØ±Ø­',
  INVALID_CREDENTIALS: 'Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„ ØºÙŠØ± ØµØ­ÙŠØ­Ø©',
  SESSION_EXPIRED: 'Ø§Ù†ØªÙ‡Øª Ø§Ù„Ø¬Ù„Ø³Ø©ØŒ ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰',
  
  // Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù†Ø¸Ø§Ù…
  INTERNAL_ERROR: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹',
  SERVICE_UNAVAILABLE: 'Ø§Ù„Ø®Ø¯Ù…Ø© ØºÙŠØ± Ù…ØªØ§Ø­Ø© Ø­Ø§Ù„ÙŠØ§Ù‹'
} as const

export class DomainError extends Error {
  constructor(
    public code: ErrorCode,
    message?: string,
    public details?: any
  ) {
    super(message || ERROR_MESSAGES[code] || 'Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
    this.name = 'DomainError'
    
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, DomainError)
    }
  }
  
  toResponse() {
    return {
      error: true,
      code: ERROR_CODES[this.code],
      message: this.message,
      details: this.details,
      timestamp: new Date().toISOString()
    }
  }
  
  toJSON() {
    return this.toResponse()
  }
}

export function errorResponse(error: unknown) {
  if (error instanceof DomainError) {
    const status = getStatusCode(error.code)
    return {
      status,
      body: error.toResponse()
    }
  }
  
  console.error('Unhandled error:', error)
  
  return {
    status: 500,
    body: {
      error: true,
      code: ERROR_CODES.INTERNAL_ERROR,
      message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹',
      timestamp: new Date().toISOString()
    }
  }
}

function getStatusCode(code: ErrorCode): number {
  const codeStr = ERROR_CODES[code]
  
  if (!codeStr) return 500
  
  // Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø©
  if (code === 'AUTHENTICATION_ERROR' || 
      code === 'AUTHORIZATION_ERROR' || 
      code === 'UNAUTHORIZED' ||
      code === 'INVALID_CREDENTIALS' ||
      code === 'SESSION_EXPIRED') {
    return 401
  }
  
  // Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„ØªØ­Ù‚Ù‚
  if (code === 'VALIDATION_ERROR' || 
      code === 'INVALID_INPUT' ||
      code === 'MISSING_FIELD' ||
      code === 'INVALID_DATE') {
    return 400
  }
  
  // Ø£Ø®Ø·Ø§Ø¡ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©
  if (code === 'NOT_FOUND' ||
      code === 'FIELD_NOT_FOUND' ||
      code === 'SLOT_NOT_FOUND' ||
      code === 'BOOKING_NOT_FOUND' ||
      code === 'PAYMENT_NOT_FOUND') {
    return 404
  }
  
  // ØªØ¹Ø§Ø±Ø¶Ø§Øª
  if (code === 'CONFLICT' ||
      code === 'SLOT_ALREADY_BOOKED' ||
      code === 'PAYMENT_ALREADY_PROCESSED' ||
      code === 'DUPLICATE_PAYMENT') {
    return 409
  }
  
  return 400
}
// lib/application/services/booking-transitions.ts
import { 
  SLOT_STATUS, 
  BOOKING_STATUS, 
  PAYMENT_STATUS 
} from '@/lib/shared/constants'
import { DomainError } from '@/lib/core/errors/domain-errors'

export class StateTransitionValidator {
  // Slot transitions
  static canTransitionSlot(
    currentStatus: string,
    targetStatus: string,
    userId?: string,
    slotData?: any
  ): { allowed: boolean; reason?: string } {
    
    const allowedTransitions: Record<string, string[]> = {
      [SLOT_STATUS.AVAILABLE]: [
        SLOT_STATUS.TEMP_LOCKED,
        SLOT_STATUS.UNAVAILABLE
      ],
      [SLOT_STATUS.TEMP_LOCKED]: [
        SLOT_STATUS.AVAILABLE, // timeout or manual release
        SLOT_STATUS.BOOKED     // after payment success
      ],
      [SLOT_STATUS.BOOKED]: [
        SLOT_STATUS.AVAILABLE  // admin only
      ],
      [SLOT_STATUS.UNAVAILABLE]: [
        SLOT_STATUS.AVAILABLE  // admin only
      ]
    }

    if (!allowedTransitions[currentStatus]?.includes(targetStatus)) {
      return {
        allowed: false,
        reason: `ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ø§Ù„ØªØ­ÙˆÙ„ Ù…Ù† ${currentStatus} Ø¥Ù„Ù‰ ${targetStatus}`
      }
    }

    // Additional checks
    if (currentStatus === SLOT_STATUS.TEMP_LOCKED && targetStatus === SLOT_STATUS.AVAILABLE) {
      if (slotData?.lockedByUserId && slotData.lockedByUserId !== userId) {
        return {
          allowed: false,
          reason: 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ù„ØºØ§Ø¡ Ù‚ÙÙ„ Ù…ÙˆØ¹Ø¯ Ù…Ù‚ÙÙˆÙ„ Ø¨ÙˆØ§Ø³Ø·Ø© Ù…Ø³ØªØ®Ø¯Ù… Ø¢Ø®Ø±'
        }
      }
    }

    if (currentStatus === SLOT_STATUS.BOOKED && targetStatus === SLOT_STATUS.AVAILABLE) {
      // Only admin can release booked slots
      if (userId && !this.isAdmin(userId)) {
        return {
          allowed: false,
          reason: 'ÙÙ‚Ø· Ø§Ù„Ù…Ø¯ÙŠØ± ÙŠÙ…ÙƒÙ†Ù‡ Ø¥Ù„ØºØ§Ø¡ Ø­Ø¬Ø² Ù…ÙˆØ¹Ø¯'
        }
      }
    }

    return { allowed: true }
  }

  // Helper method that throws DomainError
  static validateSlotTransition(
    currentStatus: string,
    targetStatus: string,
    userId?: string,
    slotData?: any
  ) {
    const validation = this.canTransitionSlot(currentStatus, targetStatus, userId, slotData)
    
    if (!validation.allowed) {
      throw new DomainError(
        'SLOT_CANNOT_BE_LOCKED',
        validation.reason
      )
    }
    
    return validation
  }

  // Booking transitions
  static canTransitionBooking(
    currentStatus: string,
    targetStatus: string,
    userId?: string,
    bookingData?: any
  ): { allowed: boolean; reason?: string } {
    
    const allowedTransitions: Record<string, string[]> = {
      [BOOKING_STATUS.DRAFT]: [
        BOOKING_STATUS.PENDING_PAYMENT,
        BOOKING_STATUS.EXPIRED,
        BOOKING_STATUS.CANCELLED
      ],
      [BOOKING_STATUS.PENDING_PAYMENT]: [
        BOOKING_STATUS.CONFIRMED,
        BOOKING_STATUS.FAILED,
        BOOKING_STATUS.CANCELLED
      ],
      [BOOKING_STATUS.CONFIRMED]: [
        BOOKING_STATUS.CANCELLED // with refund logic
      ],
      [BOOKING_STATUS.CANCELLED]: [],
      [BOOKING_STATUS.FAILED]: [],
      [BOOKING_STATUS.EXPIRED]: []
    }

    if (!allowedTransitions[currentStatus]?.includes(targetStatus)) {
      return {
        allowed: false,
        reason: `ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ ØªØºÙŠÙŠØ± Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø¬Ø² Ù…Ù† ${currentStatus} Ø¥Ù„Ù‰ ${targetStatus}`
      }
    }

    // Ownership check
    if (bookingData?.userId && userId && bookingData.userId !== userId) {
      if (!this.isAdmin(userId)) {
        return {
          allowed: false,
          reason: 'Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ ØªØ¹Ø¯ÙŠÙ„ Ø­Ø¬Ø² Ù…Ø³ØªØ®Ø¯Ù… Ø¢Ø®Ø±'
        }
      }
    }

    return { allowed: true }
  }

  // Helper method that throws DomainError for bookings
  static validateBookingTransition(
    currentStatus: string,
    targetStatus: string,
    userId?: string,
    bookingData?: any
  ) {
    const validation = this.canTransitionBooking(currentStatus, targetStatus, userId, bookingData)
    
    if (!validation.allowed) {
      throw new DomainError(
        'BOOKING_INVALID_STATE',
        validation.reason
      )
    }
    
    return validation
  }

  // Payment transitions
  static canTransitionPayment(
    currentStatus: string,
    targetStatus: string,
    _paymentData?: any
  ): { allowed: boolean; reason?: string } {
    
    const allowedTransitions: Record<string, string[]> = {
      [PAYMENT_STATUS.PENDING]: [
        PAYMENT_STATUS.PROCESSING,
        PAYMENT_STATUS.FAILED
      ],
      [PAYMENT_STATUS.PROCESSING]: [
        PAYMENT_STATUS.PAID,
        PAYMENT_STATUS.FAILED
      ],
      [PAYMENT_STATUS.PAID]: [
        PAYMENT_STATUS.REFUNDED
      ],
      [PAYMENT_STATUS.FAILED]: [
        PAYMENT_STATUS.PROCESSING // retry
      ],
      [PAYMENT_STATUS.REFUNDED]: []
    }

    if (!allowedTransitions[currentStatus]?.includes(targetStatus)) {
      return {
        allowed: false,
        reason: `ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ ØªØºÙŠÙŠØ± Ø­Ø§Ù„Ø© Ø§Ù„Ø¯ÙØ¹ Ù…Ù† ${currentStatus} Ø¥Ù„Ù‰ ${targetStatus}`
      }
    }

    return { allowed: true }
  }

  // Helper method that throws DomainError for payments
  static validatePaymentTransition(
    currentStatus: string,
    targetStatus: string,
    paymentData?: any
  ) {
    const validation = this.canTransitionPayment(currentStatus, targetStatus, paymentData)
    
    if (!validation.allowed) {
      throw new DomainError(
        'PAYMENT_FAILED',
        validation.reason
      )
    }
    
    return validation
  }

  // Helper to validate complete flow
  static validateBookingFlow(
    slotStatus: string,
    bookingStatus: string,
    paymentStatus: string
  ): string[] {
    const errors: string[] = []

    // Valid state combinations
    const validCombinations = [
      // Draft booking on locked slot
      { slot: SLOT_STATUS.TEMP_LOCKED, booking: BOOKING_STATUS.DRAFT, payment: PAYMENT_STATUS.PENDING },
      
      // Payment in progress
      { slot: SLOT_STATUS.TEMP_LOCKED, booking: BOOKING_STATUS.PENDING_PAYMENT, payment: PAYMENT_STATUS.PROCESSING },
      
      // Confirmed
      { slot: SLOT_STATUS.BOOKED, booking: BOOKING_STATUS.CONFIRMED, payment: PAYMENT_STATUS.PAID },
      
      // Failed/Cancelled
      { slot: SLOT_STATUS.AVAILABLE, booking: BOOKING_STATUS.FAILED, payment: PAYMENT_STATUS.FAILED },
      { slot: SLOT_STATUS.AVAILABLE, booking: BOOKING_STATUS.CANCELLED, payment: PAYMENT_STATUS.REFUNDED },
      { slot: SLOT_STATUS.AVAILABLE, booking: BOOKING_STATUS.EXPIRED, payment: PAYMENT_STATUS.FAILED }
    ]

    const isValid = validCombinations.some(combo => 
      combo.slot === slotStatus && 
      combo.booking === bookingStatus && 
      combo.payment === paymentStatus
    )

    if (!isValid) {
      errors.push(`Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ø­Ø§Ù„Ø§Øª ØºÙŠØ± ØµØ§Ù„Ø­Ø©: Slot=${slotStatus}, Booking=${bookingStatus}, Payment=${paymentStatus}`)
    }

    return errors
  }

  // Helper method that throws DomainError for complete flow
  static validateCompleteBookingFlow(
    slotStatus: string,
    bookingStatus: string,
    paymentStatus: string
  ) {
    const errors = this.validateBookingFlow(slotStatus, bookingStatus, paymentStatus)
    
    if (errors.length > 0) {
      throw new DomainError(
        'BOOKING_INVALID_STATE',
        errors.join(' | ')
      )
    }
    
    return { valid: true }
  }

  private static isAdmin(_userId: string): boolean {
    // TODO: Implement admin check from database
    // For now, return false
    return false
  }
}
// lib/application/services/booking-orchestrator.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { addMinutes } from 'date-fns'
import { 
  SLOT_STATUS, 
  BOOKING_STATUS, 
  PAYMENT_STATUS 
} from '@/lib/shared/constants'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { IdempotencyGuard } from '@/lib/application/idempotency/idempotency-guard'
import { checkBookingLimits } from '@/lib/domain/slots/time-slots/booking-limits'
import { notificationService } from '@/lib/infrastructure/notifications/notification-service'
import { paymobService } from '@/lib/infrastructure/payments/providers'
import { bookingLogger } from '@/lib/shared/logger'
import type { 
  BookingCreateInput, 
  BookingCreateResult,
  PaymentInitInput,
  PaymentInitResult
} from '@/lib/domain/booking/types'
import { ENV } from '@/lib/shared/env/env'

export class BookingOrchestrator {
  /**
   * ğŸ« 1. Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø¬Ø² Ø¬Ø¯ÙŠØ¯
   */
  static async createBooking(input: BookingCreateInput): Promise<BookingCreateResult> {
    const startTime = Date.now()
    const requestId = `booking_create_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

    bookingLogger.info({
      msg: 'Creating booking',
      requestId,
      userId: input.userId,
      slotId: input.slotId,
      fieldId: input.fieldId,
      idempotencyKey: input.idempotencyKey
    })

    try {
      // ğŸ” Idempotency check
      if (input.idempotencyKey) {
        const check = await IdempotencyGuard.check(
          input.idempotencyKey,
          input.userId,
          'booking:create',
          { slotId: input.slotId, fieldId: input.fieldId }
        )

        if (!check.shouldProceed) {
          if (check.response) {
            bookingLogger.info({
              msg: 'Idempotent response returned',
              requestId
            })
            return check.response as BookingCreateResult
          }
          throw new DomainError('BOOKING_IN_PROGRESS', 'Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø·Ù„Ø¨')
        }
      }

      const result = await prisma.$transaction(async (tx: any) => {
        // 1. ğŸ” ØªØ£ÙƒØ¯ Ø£Ù† Slot Ù…Ù‚ÙÙˆÙ„Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const slot = await tx.slot.findUnique({
          where: {
            id: input.slotId,
            fieldId: input.fieldId,
            status: SLOT_STATUS.TEMP_LOCKED,
            lockedById: input.userId, // âœ… ØªØµØ­ÙŠØ­: ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† userId Ù†ÙØ³Ù‡Ø§
            lockedUntil: { gt: new Date() }
          },
          include: { field: true }
        })

        if (!slot) {
          throw new DomainError('SLOT_NOT_FOUND', 'Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù„Ù… ÙŠØ¹Ø¯ Ù…ØªØ§Ø­Ø§Ù‹ Ø£Ùˆ Ø§Ù†ØªÙ‡Ù‰ Ù‚ÙÙ„Ù‡')
        }

        // 2. ğŸ“ ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø­Ø¬Ø²
        await checkBookingLimits({
          userId: input.userId,
          slotDate: new Date(slot.startTime),
          slotDurationMin: slot.durationMinutes || 60
        })

        // 3. ğŸ« Ø¥Ù†Ø´Ø§Ø¡ Booking
        const booking = await tx.booking.create({
          data: {
            userId: input.userId,
            fieldId: input.fieldId,
            slotId: input.slotId,
            status: BOOKING_STATUS.DRAFT,
            paymentStatus: PAYMENT_STATUS.PENDING,
            totalAmount: slot.price,
            expiresAt: addMinutes(new Date(), 10),
            idempotencyKey: input.idempotencyKey || null
          }
        })

        const result: BookingCreateResult = {
          bookingId: booking.id,
          needsConfirmation: !this.canBookDirectly(new Date(slot.startTime))
        }

        // ğŸ’¾ Ø­ÙØ¸ Ù„Ù„Ù€ Idempotency
        if (input.idempotencyKey) {
          await IdempotencyGuard.saveResponse(
            input.idempotencyKey,
            input.userId,
            'booking:create',
            result,
            { slotId: input.slotId, fieldId: input.fieldId },
            60
          )
        }

        bookingLogger.info({
          msg: 'Booking created successfully',
          requestId,
          bookingId: booking.id,
          durationMs: Date.now() - startTime
        })

        return result
      })

      return result

    } catch (error: any) {
      bookingLogger.error({
        msg: 'Booking creation failed',
        requestId,
        error: error.message,
        userId: input.userId,
        durationMs: Date.now() - startTime
      })
      
      if (error instanceof DomainError) {
        throw error
      }
      throw new DomainError('INTERNAL_ERROR', 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø¬Ø²')
    }
  }

  /**
   * ğŸ’³ 2. Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¯ÙØ¹
   */
  static async initiatePayment(input: PaymentInitInput & { userId: string }): Promise<PaymentInitResult> {
    const startTime = Date.now()
    const requestId = `payment_init_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

    bookingLogger.info({
      msg: 'Initiating payment',
      requestId,
      bookingId: input.bookingId,
      userId: input.userId,
      amount: input.amount
    })

    try {
      // 1. ğŸ” Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Booking
      const booking = await prisma.booking.findUnique({
        where: { id: input.bookingId },
        include: { 
          slot: true,
          field: true,
          user: true
        }
      })

      if (!booking) {
        throw new DomainError('BOOKING_NOT_FOUND')
      }

      // 2. ğŸ” Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ù„ÙƒÙŠØ©
      if (booking.userId !== input.userId) {
        throw new DomainError('BOOKING_NOT_OWNED')
      }

      // 3. ğŸ” Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø¬Ø²
      if (booking.status !== BOOKING_STATUS.DRAFT) {
        throw new DomainError(
          'BOOKING_INVALID_STATE',
          `Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„Ø¯ÙØ¹ Ù„Ø­Ø¬Ø² Ø¨Ø­Ø§Ù„Ø© ${booking.status}`
        )
      }

      // 4. â° Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©
      if (booking.expiresAt && booking.expiresAt < new Date()) {
        throw new DomainError('BOOKING_EXPIRED')
      }

      // 5. ğŸ” Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Slot Ù„Ø§ ØªØ²Ø§Ù„ Ù…Ù‚ÙÙˆÙ„Ø©
      if (booking.slot.status !== SLOT_STATUS.TEMP_LOCKED) {
        throw new DomainError('SLOT_LOCK_EXPIRED')
      }

      // 6. ğŸ’³ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¯ÙØ¹ Ø³Ø§Ø¨Ù‚ Ù†Ø§Ø¬Ø­
      const lastPayment = await prisma.payment.findFirst({
        where: { bookingId: input.bookingId },
        orderBy: { createdAt: 'desc' }
      })

      if (lastPayment?.status === PAYMENT_STATUS.PAID) {
        throw new DomainError('PAYMENT_ALREADY_PROCESSED')
      }

      // 7. ğŸ” Idempotency Ù„Ù„Ø¯ÙØ¹
      const idempotencyKey = input.idempotencyKey || IdempotencyGuard.generateKey('payment')
      
      const check = await IdempotencyGuard.check(
        idempotencyKey,
        input.userId,
        'payment:initiate',
        { bookingId: input.bookingId, amount: input.amount }
      )

      if (!check.shouldProceed) {
        if (check.response) {
          bookingLogger.info({
            msg: 'Idempotent payment response',
            requestId
          })
          return check.response as PaymentInitResult
        }
        throw new DomainError('BOOKING_IN_PROGRESS')
      }

      const result = await prisma.$transaction(async (tx: any) => {
        // 8. ğŸ“¦ Ø¥Ù†Ø´Ø§Ø¡ Order ÙÙŠ Paymob
        let orderId: string
        let paymentToken: string

        if (paymobService.isMockMode()) {
          const mockOrder = await paymobService.createMockOrder({
            amount: input.amount,
            currency: input.currency || 'EGP',
            bookingId: input.bookingId
          })
          orderId = mockOrder.id.toString()
          paymentToken = await paymobService.getMockPaymentKey({ orderId: mockOrder.id })
        } else {
          const order = await paymobService.createOrder({
            amount: input.amount,
            currency: input.currency || 'EGP',
            bookingId: input.bookingId,
            userId: input.userId
          })
          orderId = order.id.toString()
          
          // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙÙˆØ§ØªÙŠØ±
          const billingData = {
            apartment: "NA",
            email: booking.user.email,
            floor: "NA",
            first_name: booking.user.name?.split(' ')[0] || "Ø¹Ù…ÙŠÙ„",
            street: "NA",
            building: "NA",
            phone_number: booking.user.phoneNumber || "01000000000", // âœ… ØªØµØ­ÙŠØ­: phoneNumber Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† phone
            shipping_method: "NA",
            postal_code: "NA",
            city: "NA",
            country: "NA",
            last_name: booking.user.name?.split(' ').slice(1).join(' ') || "Ù…Ø³ØªØ®Ø¯Ù…",
            state: "NA"
          }

          paymentToken = await paymobService.getPaymentKey({
            orderId: order.id,
            amount: input.amount,
            billingData,
            bookingId: input.bookingId
          })
        }

        // 9. ğŸ’³ Ø¥Ù†Ø´Ø§Ø¡ Payment
        const payment = await tx.payment.create({
          data: {
            bookingId: input.bookingId,
            amount: input.amount,
            currency: input.currency || 'EGP',
            paymentId: `pay_${orderId}`,
            orderId: orderId,
            status: PAYMENT_STATUS.PROCESSING
          }
        })

        // 10. ğŸ”„ ØªØ­Ø¯ÙŠØ« Booking
        await tx.booking.update({
          where: { id: input.bookingId },
          data: {
            status: BOOKING_STATUS.PENDING_PAYMENT,
            paymentStatus: PAYMENT_STATUS.PROCESSING,
            paymentId: payment.id,
            orderId: orderId
          }
        })

        const result: PaymentInitResult = {
          paymentUrl: paymobService.isMockMode() 
            ? `/payment/mock/${orderId}` 
            : `https://accept.paymob.com/api/acceptance/iframes/${ENV.PAYMOB_IFRAME_ID || 'default'}?payment_token=${paymentToken}`,
          orderId,
          idempotencyKey
        }

        // ğŸ’¾ Ø­ÙØ¸ Ù„Ù„Ù€ Idempotency
        await IdempotencyGuard.saveResponse(
          idempotencyKey,
          input.userId,
          'payment:initiate',
          result,
          { bookingId: input.bookingId, amount: input.amount },
          30
        )

        bookingLogger.info({
          msg: 'Payment initiated successfully',
          requestId,
          orderId,
          paymentId: payment.id,
          durationMs: Date.now() - startTime
        })

        return result
      })

      return result

    } catch (error: any) {
      bookingLogger.error({
        msg: 'Payment initiation failed',
        requestId,
        error: error.message,
        bookingId: input.bookingId,
        durationMs: Date.now() - startTime
      })
      
      if (error instanceof DomainError) {
        throw error
      }
      throw new DomainError('INTERNAL_ERROR', 'ÙØ´Ù„ ÙÙŠ Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¯ÙØ¹')
    }
  }

  /**
   * âœ… 3. Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ø­Ø¬Ø² Ø¨Ø¹Ø¯ Ø§Ù„Ø¯ÙØ¹
   */
  static async completeBooking(params: {
    bookingId: string
    success: boolean
    paymentDetails: {
      transactionId: string
      orderId: string
      amount: number
      currency: string
    }
  }) {
    const startTime = Date.now()
    const requestId = `complete_booking_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

    bookingLogger.info({
      msg: 'Completing booking',
      requestId,
      bookingId: params.bookingId,
      success: params.success,
      orderId: params.paymentDetails.orderId
    })

    let booking: any

    try {
      // Transaction Ù„Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø­Ø±Ø¬Ø©
      await prisma.$transaction(async (tx: any) => {
        booking = await tx.booking.findUnique({
          where: { id: params.bookingId },
          include: { 
            slot: true, 
            field: true, 
            user: true 
          }
        })

        if (!booking) {
          throw new DomainError('BOOKING_NOT_FOUND')
        }

        // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† payment Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… orderId Ø£ÙˆÙ„Ø§Ù‹
        const existingPayment = await tx.payment.findFirst({
          where: { orderId: params.paymentDetails.orderId }
        })

        if (existingPayment) {
          if (existingPayment.status === PAYMENT_STATUS.PAID) {
            throw new DomainError('PAYMENT_ALREADY_PROCESSED')
          }
          
          if (existingPayment.bookingId !== params.bookingId) {
            throw new DomainError('DUPLICATE_PAYMENT', 'ØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… orderId ÙÙŠ Ø­Ø¬Ø² Ø¢Ø®Ø±')
          }
        }

        if (params.success) {
          // âœ… Ù†Ø¬Ø§Ø­ Ø§Ù„Ø¯ÙØ¹
          await tx.booking.update({
            where: { id: params.bookingId },
            data: {
              status: BOOKING_STATUS.CONFIRMED,
              paymentStatus: PAYMENT_STATUS.PAID
            }
          })

          await tx.slot.update({
            where: { id: booking.slotId },
            data: {
              status: SLOT_STATUS.BOOKED,
              lockedById: null,
              lockedUntil: null
            }
          })

          await tx.payment.updateMany({
            where: { bookingId: params.bookingId },
            data: {
              status: PAYMENT_STATUS.PAID,
              paymentId: params.paymentDetails.transactionId,
              metadata: params.paymentDetails
            }
          })

          bookingLogger.info({
            msg: 'Payment succeeded',
            requestId,
            bookingId: params.bookingId,
            transactionId: params.paymentDetails.transactionId
          })

        } else {
          // âŒ ÙØ´Ù„ Ø§Ù„Ø¯ÙØ¹
          await tx.booking.update({
            where: { id: params.bookingId },
            data: {
              status: BOOKING_STATUS.FAILED,
              paymentStatus: PAYMENT_STATUS.FAILED
            }
          })

          await tx.slot.update({
            where: { id: booking.slotId },
            data: { 
              status: SLOT_STATUS.AVAILABLE,
              lockedById: null,
              lockedUntil: null
            }
          })

          await tx.payment.updateMany({
            where: { bookingId: params.bookingId },
            data: {
              status: PAYMENT_STATUS.FAILED,
              metadata: params.paymentDetails
            }
          })

          bookingLogger.warn({
            msg: 'Payment failed',
            requestId,
            bookingId: params.bookingId
          })
        }
      })

      // âœ… Ø¥Ø±Ø³Ø§Ù„ Notifications Ø®Ø§Ø±Ø¬ Transaction
      await this.sendPostTransactionNotifications(booking, params.success, params.paymentDetails)

      bookingLogger.info({
        msg: 'Booking completed successfully',
        requestId,
        bookingId: params.bookingId,
        durationMs: Date.now() - startTime
      })

      return { success: true }

    } catch (error: any) {
      bookingLogger.error({
        msg: 'Booking completion failed',
        requestId,
        error: error.message,
        bookingId: params.bookingId,
        durationMs: Date.now() - startTime
      })
      
      if (error instanceof DomainError) {
        throw error
      }
      throw new DomainError('INTERNAL_ERROR', 'ÙØ´Ù„ ÙÙŠ Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ø­Ø¬Ø²')
    }
  }

  /**
   * ğŸ§¹ 4. ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ©
   */
  static async cleanupExpiredBookings() {
    const startTime = Date.now()
    const jobId = `cleanup_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

    bookingLogger.info({
      msg: 'Starting expired bookings cleanup',
      jobId
    })

    try {
      const now = new Date()
      
      const expiredBookings = await prisma.booking.findMany({
        where: {
          status: BOOKING_STATUS.DRAFT,
          expiresAt: { lt: now }
        },
        include: { slot: true }
      })

      bookingLogger.info({
        msg: `Found ${expiredBookings.length} expired bookings`,
        jobId
      })

      let cleaned = 0

      for (const booking of expiredBookings) {
        try {
          await prisma.$transaction(async (tx: any) => {
            await tx.booking.update({
              where: { id: booking.id },
              data: {
                status: BOOKING_STATUS.EXPIRED,
                paymentStatus: PAYMENT_STATUS.FAILED
              }
            })

            await tx.slot.update({
              where: { id: booking.slotId },
              data: { 
                status: SLOT_STATUS.AVAILABLE,
                lockedById: null,
                lockedUntil: null
              }
            })

            cleaned++
          })

          // Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
          await notificationService.send({
            userId: booking.userId,
            type: 'BOOKING_EXPIRED',
            title: 'Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø­Ø¬Ø²',
            message: 'Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø­Ø¬Ø²ÙƒØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰',
            relatedId: booking.id
          })

        } catch (error: any) {
          bookingLogger.error({
            msg: `Failed to clean up booking ${booking.id}`,
            jobId,
            error: error.message
          })
        }
      }

      bookingLogger.info({
        msg: 'Cleanup completed',
        jobId,
        cleaned,
        durationMs: Date.now() - startTime
      })

      return { success: true, cleaned }

    } catch (error: any) {
      bookingLogger.error({
        msg: 'Cleanup job failed',
        jobId,
        error: error.message,
        durationMs: Date.now() - startTime
      })
      
      return { success: false, error: error.message }
    }
  }

  /**
   * ğŸ”“ 5. ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³Ù„Ø§Øª Ø§Ù„Ù…Ù‚ÙÙˆÙ„Ø© Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ©
   */
  static async cleanupExpiredLocks() {
    const startTime = Date.now()
    const jobId = `unlock_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

    bookingLogger.info({
      msg: 'Starting expired locks cleanup',
      jobId
    })

    try {
      const now = new Date()
      
      const result = await prisma.slot.updateMany({
        where: {
          status: SLOT_STATUS.TEMP_LOCKED,
          lockedUntil: { lt: now }
        },
        data: {
          status: SLOT_STATUS.AVAILABLE,
          lockedById: null,
          lockedUntil: null
        }
      })

      bookingLogger.info({
        msg: 'Locks cleanup completed',
        jobId,
        unlockedSlots: result.count,
        durationMs: Date.now() - startTime
      })

      return { success: true, unlockedSlots: result.count }

    } catch (error: any) {
      bookingLogger.error({
        msg: 'Locks cleanup failed',
        jobId,
        error: error.message,
        durationMs: Date.now() - startTime
      })
      
      return { success: false, error: error.message }
    }
  }

  /**
   * ğŸ”’ Private helpers
   */

  private static async sendPostTransactionNotifications(
    booking: any,
    success: boolean,
    paymentDetails: any
  ): Promise<void> {
    try {
      if (success) {
        await notificationService.send({
          userId: booking.userId,
          type: 'PAYMENT_SUCCESS',
          title: 'ØªÙ… Ø§Ù„Ø¯ÙØ¹ Ø¨Ù†Ø¬Ø§Ø­',
          message: `ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø­Ø¬Ø²Ùƒ ÙÙŠ ${booking.field.name} Ø¨ØªØ§Ø±ÙŠØ® ${new Date(booking.slot.startTime).toLocaleDateString('ar-EG')}`,
          relatedId: booking.id,
          data: {
            amount: paymentDetails.amount,
            fieldName: booking.field.name,
            date: booking.slot.startTime
          }
        })
      } else {
        await notificationService.send({
          userId: booking.userId,
          type: 'PAYMENT_FAILED',
          title: 'ÙØ´Ù„ Ø§Ù„Ø¯ÙØ¹',
          message: 'ÙØ´Ù„Øª Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¯ÙØ¹ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰',
          relatedId: booking.id
        })
      }
    } catch (error: any) {
      bookingLogger.error({
        msg: 'Failed to send notifications',
        error: error.message,
        bookingId: booking.id
      })
      // Ù„Ø§ ØªØ±Ù…ÙŠ error - notifications ÙØ´Ù„Øª Ù„ÙƒÙ† Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ù†Ø¬Ø­Øª
    }
  }

  private static canBookDirectly(start: Date): boolean {
    const diffMs = start.getTime() - Date.now()
    const diffHours = diffMs / (1000 * 60 * 60)
    return diffHours >= 24
  }
}

export const bookingOrchestrator = new BookingOrchestrator()
// lib/application/jobs/unlock-slots.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { SLOT_STATUS, BOOKING_STATUS } from '@/lib/shared/constants'
import { bookingLogger } from '@/lib/shared/logger'
import { DomainError } from '@/lib/core/errors/domain-errors'

export async function unlockSlotsJob() {
  const jobId = `unlock_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  bookingLogger.info({ 
    msg: 'ğŸ”“ Starting unlock slots job...',
    jobId 
  })
  
  const now = new Date()
  let unlockedCount = 0
  let orphanedCount = 0
  let errorsCount = 0

  try {
    const expiredSlots = await prisma.slot.findMany({
      where: {
        status: SLOT_STATUS.TEMP_LOCKED,
        lockedUntil: { lt: now }
      },
      include: {
        lockedByUser: { select: { id: true, email: true, name: true } },
        field: { select: { id: true, name: true } }
      }
    })

    bookingLogger.info({ 
      msg: `ğŸ“Š Found ${expiredSlots.length} expired locked slots`,
      jobId,
      count: expiredSlots.length 
    })

    if (expiredSlots.length > 0) {
      bookingLogger.debug({
        msg: 'ğŸ“ Expired slots details:',
        jobId,
        slots: expiredSlots.map((slot: any) => ({
          id: slot.id,
          startTime: slot.startTime,
          userId: slot.lockedByUserId,
          userEmail: slot.lockedByUser?.email,
          fieldName: slot.field?.name,
          lockedUntil: slot.lockedUntil
        }))
      })
    }

    const result = await prisma.slot.updateMany({
      where: { status: SLOT_STATUS.TEMP_LOCKED, lockedUntil: { lt: now } },
      data: { status: SLOT_STATUS.AVAILABLE, lockedById: null, lockedUntil: null }
    })

    unlockedCount = result.count
    
    bookingLogger.info({ 
      msg: `ğŸ”“ Unlocked ${unlockedCount} expired slots`,
      jobId,
      unlockedCount 
    })

    const orphanedSlots = await prisma.slot.findMany({
      where: {
        status: SLOT_STATUS.TEMP_LOCKED,
        bookings: {
          none: {
            status: { in: [BOOKING_STATUS.DRAFT, BOOKING_STATUS.PENDING_PAYMENT] }
          }
        }
      },
      include: { field: { select: { id: true, name: true } } }
    })

    if (orphanedSlots.length > 0) {
      bookingLogger.warn({
        msg: `âš ï¸ Found ${orphanedSlots.length} orphaned locked slots`,
        jobId,
        orphanedCount: orphanedSlots.length,
        orphanedSlots: orphanedSlots.map((s: any) => ({
          id: s.id,
          field: s.field?.name,
          startTime: s.startTime
        }))
      })
      
      const orphanedResult = await prisma.slot.updateMany({
        where: { id: { in: orphanedSlots.map((s: any) => s.id) } },
        data: { status: SLOT_STATUS.AVAILABLE, lockedById: null, lockedUntil: null }
      })

      orphanedCount = orphanedResult.count
      
      bookingLogger.info({ 
        msg: `ğŸ”„ Unlocked ${orphanedCount} orphaned slots`,
        jobId,
        orphanedCount 
      })
    }

    const totalUnlocked = unlockedCount + orphanedCount
    const jobDuration = Date.now() - now.getTime()
    
    bookingLogger.info({
      msg: 'âœ… Unlock slots job completed',
      jobId,
      durationMs: jobDuration,
      stats: {
        expiredSlotsFound: expiredSlots.length,
        unlockedExpiredSlots: unlockedCount,
        orphanedSlotsFound: orphanedSlots.length,
        unlockedOrphanedSlots: orphanedCount,
        totalUnlocked,
        errors: errorsCount
      }
    })

    return {
      success: true,
      stats: {
        unlockedSlots: totalUnlocked,
        orphanedSlots: orphanedCount,
        expiredSlots: expiredSlots.length,
        timestamp: now.toISOString(),
        durationMs: jobDuration
      }
    }

  } catch (error: any) {
    bookingLogger.error({
      msg: 'âŒ Fatal error in unlock slots job',
      jobId,
      error: error.message,
      stack: error.stack
    })
    
    throw new DomainError('INTERNAL_ERROR', `Job failed: ${error.message}`)
  }
}

export async function runUnlockSlotsJob() {
  const requestId = `run_unlock_${Date.now()}`
  
  try {
    bookingLogger.info({ 
      msg: 'Starting scheduled unlock slots job',
      requestId 
    })
    
    const result = await unlockSlotsJob()
    
    bookingLogger.info({ 
      msg: 'âœ… Scheduled unlock slots job completed',
      requestId,
      result 
    })
    
    return result
  } catch (error: any) {
    bookingLogger.error({ 
      msg: 'âŒ Scheduled unlock slots job failed',
      requestId,
      error: error.message,
      stack: error.stack 
    })
    
    return { 
      success: false, 
      error: error.message,
      timestamp: new Date().toISOString()
    }
  }
}
import { prisma } from '@/lib/infrastructure/database/prisma'
import { 
  BOOKING_STATUS, 
  PAYMENT_STATUS,
  SLOT_STATUS 
} from '@/lib/shared/constants'
import { bookingLogger } from '@/lib/shared/logger'
import { DomainError } from '@/lib/core/errors/domain-errors'

export async function expireBookingsJob() {
  const jobId = `expire_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  bookingLogger.info({ jobId }, 'ğŸš€ Starting expire bookings job...')
  
  const now = new Date()
  let expiredCount = 0
  let unlockedSlots = 0
  let errorsCount = 0

  try {
    const expiredBookings = await prisma.booking.findMany({
      where: {
        status: BOOKING_STATUS.DRAFT,
        expiresAt: { lt: now }
      },
      include: {
        slot: true,
        user: {
          select: { id: true, email: true, name: true }
        }
      }
    })

    bookingLogger.info({ jobId, count: expiredBookings.length }, `ğŸ“Š Found ${expiredBookings.length} expired bookings`)

    for (const booking of expiredBookings) {
      try {
        const startTime = Date.now()
        
        await prisma.$transaction(async (tx: any) => {
          await tx.booking.update({
            where: { id: booking.id },
            data: {
              status: BOOKING_STATUS.EXPIRED,
              paymentStatus: PAYMENT_STATUS.FAILED
            }
          })

          await tx.slot.update({
            where: { id: booking.slotId },
            data: {
              status: SLOT_STATUS.AVAILABLE,
              lockedById: null,
              lockedUntil: null
            }
          })

          await tx.notification.create({
            data: {
              userId: booking.userId,
              type: 'BOOKING_EXPIRED',
              title: 'Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø­Ø¬Ø²',
              message: `Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø­Ø¬Ø²Ùƒ ÙÙŠ ${booking.slot.startTime.toLocaleDateString('ar-EG')}`,
              relatedId: booking.id,
              data: {
                slotTime: booking.slot.startTime,
                fieldId: booking.slot.fieldId
              }
            }
          })
        })

        const duration = Date.now() - startTime
        
        bookingLogger.debug({
          jobId,
          bookingId: booking.id,
          userId: booking.userId,
          userEmail: booking.user?.email,
          slotId: booking.slotId,
          durationMs: duration
        }, 'Booking expired successfully')

        expiredCount++
        unlockedSlots++

      } catch (error: any) {
        errorsCount++
        bookingLogger.error({
          jobId,
          bookingId: booking.id,
          error: error.message,
          stack: error.stack
        }, `âŒ Error processing booking ${booking.id}`)
      }
    }

    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
    
    const deleted = await prisma.booking.deleteMany({
      where: {
        status: BOOKING_STATUS.EXPIRED,
        updatedAt: { lt: sevenDaysAgo }
      }
    })

    bookingLogger.info({
      jobId,
      deletedCount: deleted.count,
      cutoffDate: sevenDaysAgo.toISOString()
    }, `ğŸ—‘ï¸ Deleted ${deleted.count} old expired bookings`)

    const jobDuration = Date.now() - now.getTime()
    
    bookingLogger.info({
      jobId,
      durationMs: jobDuration,
      stats: {
        totalFound: expiredBookings.length,
        successfullyExpired: expiredCount,
        unlockedSlots,
        deletedOldBookings: deleted.count,
        errors: errorsCount,
        successRate: expiredBookings.length > 0 ? 
          ((expiredCount / expiredBookings.length) * 100).toFixed(2) + '%' : 'N/A'
      }
    }, 'âœ… Expire bookings job completed')

    return {
      success: true,
      stats: {
        expiredBookings: expiredCount,
        unlockedSlots,
        deletedOld: deleted.count,
        errors: errorsCount,
        timestamp: now.toISOString(),
        durationMs: jobDuration
      }
    }

  } catch (error: any) {
    bookingLogger.error({
      jobId,
      error: error.message,
      stack: error.stack
    }, 'âŒ Fatal error in expire bookings job')
    
    throw new DomainError('INTERNAL_ERROR', `Job failed: ${error.message}`)
  }
}

export async function runExpireBookingsJob() {
  const requestId = `run_expire_${Date.now()}`
  
  try {
    bookingLogger.info({ requestId }, 'Starting scheduled expire bookings job')
    
    const result = await expireBookingsJob()
    
    bookingLogger.info({ requestId, result }, 'âœ… Scheduled expire bookings job completed')
    
    return result
  } catch (error: any) {
    bookingLogger.error({ requestId, error: error.message, stack: error.stack }, 'âŒ Scheduled expire bookings job failed')
    
    return { 
      success: false, 
      error: error.message,
      timestamp: new Date().toISOString()
    }
  }
}
// lib/application/idempotency/idempotency-guard.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { addMinutes } from 'date-fns'
import crypto from 'crypto'

export class IdempotencyGuard {
  /**
   * ğŸ” ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø¹Ù…Ù„ÙŠØ© idempotent
   * @param key Ø§Ù„Ù…ÙØªØ§Ø­ Ø§Ù„ÙØ±ÙŠØ¯
   * @param userId Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
   * @param method Ø§Ø³Ù… Ø§Ù„Ø¹Ù…Ù„ÙŠØ©
   * @param requestData Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø¨ (Ù„ØªØ¬Ù†Ø¨ Ù†ÙØ³ Ø§Ù„Ø·Ù„Ø¨ Ø¨Ù…Ø¹Ø·ÙŠØ§Øª Ù…Ø®ØªÙ„ÙØ©)
   * @returns {idempotent: boolean, response?: any, shouldProceed: boolean}
   */
  static async check(
    key: string,
    userId: string,
    method: string,
    requestData?: any
  ): Promise<{
    idempotent: boolean
    response?: any
    shouldProceed: boolean
  }> {
    const now = new Date()
    
    // 1. ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ©
    await prisma.idempotencyKey.deleteMany({
      where: { expiresAt: { lt: now } }
    }).catch(() => {
      // ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ÙÙŠ Ø§Ù„ØªÙ†Ø¸ÙŠÙ
    })

    try {
      // 2. Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…ÙØªØ§Ø­ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… key Ùˆ userId
      const existing = await prisma.idempotencyKey.findFirst({
        where: { 
          AND: [
            { key },
            { userId }
          ]
        }
      })

      if (!existing) {
        return { idempotent: false, shouldProceed: true }
      }

      // 3. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø·Ø±ÙŠÙ‚Ø©
      if (existing.method !== method) {
        throw new Error('Ù…ÙØªØ§Ø­ idempotency ØºÙŠØ± ØµØ§Ù„Ø­ Ù„Ù‡Ø°Ø§ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©')
      }

      // 4. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† requestHash Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
      if (requestData && existing.requestHash) {
        const currentHash = this.hashRequest(requestData)
        if (currentHash !== existing.requestHash) {
          throw new Error('Ø·Ù„Ø¨ Ù…ÙƒØ±Ø± Ø¨Ù…Ø¹Ø·ÙŠØ§Øª Ù…Ø®ØªÙ„ÙØ©')
        }
      }

      // 5. Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ response Ù…Ø®Ø²Ù†
      if (existing.response) {
        return {
          idempotent: true,
          response: existing.response,
          shouldProceed: false
        }
      }

      // 6. Ø§Ù„Ù…ÙØªØ§Ø­ Ù…ÙˆØ¬ÙˆØ¯ ÙˆÙ„ÙƒÙ† Ø¨Ø¯ÙˆÙ† response (Ù…Ø§Ø²Ø§Ù„ ÙŠØ¹Ù…Ù„)
      return { idempotent: true, shouldProceed: false }

    } catch (error) {
      console.error('Idempotency check error:', error)
      return { idempotent: false, shouldProceed: true }
    }
  }

  /**
   * ğŸ’¾ Ø­ÙØ¸ Ù†ØªÙŠØ¬Ø© idempotent
   */
  static async saveResponse(
    key: string,
    userId: string,
    method: string,
    response: any,
    requestData?: any,
    ttlMinutes: number = 60
  ) {
    // âœ… Ø¥ØµÙ„Ø§Ø­: Ø§Ø³ØªØ®Ø¯Ù… Ù‚ÙŠÙ…Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù„Ù€ requestHash
    const requestHash = requestData ? this.hashRequest(requestData) : ''
    
    try {
      return await prisma.idempotencyKey.upsert({
        where: {
          key_userId: {
            key,
            userId
          }
        },
        update: {
          response,
          expiresAt: addMinutes(new Date(), ttlMinutes)
        },
        create: {
          key,
          userId,
          method,
          requestHash, // âœ… Ø§Ù„Ø¢Ù† string ÙˆÙ„ÙŠØ³ null
          response,
          expiresAt: addMinutes(new Date(), ttlMinutes)
        }
      })
    } catch (error) {
      console.error('Failed to save idempotency response:', error)
      // âœ… Ø¥ØµÙ„Ø§Ø­: Ø¥Ø±Ø¬Ø§Ø¹ Ù‚ÙŠÙ…Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
      return null
    }
  }

  /**
   * ğŸ”¢ ØªÙˆÙ„ÙŠØ¯ Ù…ÙØªØ§Ø­ Ø¢Ù…Ù†
   */
  static generateKey(prefix: string = 'req'): string {
    const timestamp = Date.now()
    const random = crypto.randomBytes(16).toString('hex')
    return `${prefix}_${timestamp}_${random}`
  }

  /**
   * ğŸ” Ø­Ø³Ø§Ø¨ Ù‡Ø§Ø´ Ù„Ù„Ø·Ù„Ø¨ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… SHA-256
   */
  private static hashRequest(data: any): string {
    const str = JSON.stringify(data, Object.keys(data).sort())
    return crypto.createHash('sha256').update(str).digest('hex')
  }
}
// app/api/webhooks/paymob/route.ts
import { NextRequest } from 'next/server'
import { BookingOrchestrator } from '@/lib/application/services/booking-orchestrator'
import { paymobService } from '@/lib/infrastructure/payments/providers'
import { assertWebhookValid } from '@/lib/domain/guards/payment-guards'
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { logger } from '@/lib/shared/logger'
import { parseISO, differenceInMinutes } from 'date-fns'

export async function POST(request: NextRequest) {
  const webhookId = `webhook_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

  try {
    logger.info({
      webhookId,
      ip: request.headers.get('x-forwarded-for') || 'unknown',
      userAgent: request.headers.get('user-agent') || 'unknown'
    }, 'Processing Paymob webhook')

    const body = await request.json()
    const hmac = request.headers.get('hmac')

    if (!hmac) {
      logger.error({
        webhookId,
        headers: Object.fromEntries(request.headers.entries())
      }, 'HMAC header missing')
      return apiErrorHandler(new Error('HMAC header missing'))
    }

    // 1ï¸âƒ£ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† HMAC
    if (!paymobService.verifyHMAC(body.obj, hmac)) {
      logger.error({
        webhookId,
        hmac,
        bodyHash: JSON.stringify(body.obj).length
      }, 'Invalid HMAC signature')
      return apiErrorHandler(new Error('Invalid HMAC signature'))
    }

    // 2ï¸âƒ£ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    const {
      success,
      amount_cents,
      id: transactionId,
      order: { id: orderId, merchant_order_id: bookingId },
      created_at,
      currency = 'EGP'
    } = body.obj

    const createdAt = parseISO(created_at)
    const now = new Date()
    const minutesDiff = differenceInMinutes(now, createdAt)

    logger.info({
      webhookId,
      bookingId,
      orderId,
      transactionId,
      success,
      amount: amount_cents / 100,
      created_at: createdAt.toISOString(),
      minutesAgo: minutesDiff,
      currency
    }, 'Webhook data extracted')

    if (minutesDiff > 60) {
      logger.warn({
        webhookId,
        minutesDiff,
        created_at: createdAt.toISOString(),
        received_at: now.toISOString()
      }, 'Webhook is too old, ignoring')
      return new Response('OK', {
        status: 200,
        headers: {
          'Content-Type': 'text/plain',
          'X-Webhook-Status': 'IGNORED_OLD'
        }
      })
    }

    // 3ï¸âƒ£ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù€ webhook
    const payment = await assertWebhookValid({
      orderId: orderId.toString(),
      transactionId: transactionId.toString(),
      amount: amount_cents / 100
    })

    logger.info({
      webhookId,
      paymentId: payment.id,
      bookingId: payment.bookingId,
      previousStatus: payment.status,
      created_at: createdAt.toISOString(),
      processingDelay: minutesDiff
    }, 'Webhook validated')

    // 4ï¸âƒ£ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø­Ø¬Ø²
    const processingStart = Date.now()

    await BookingOrchestrator.completeBooking({
      bookingId: payment.bookingId,
      success: Boolean(success),
      paymentDetails: {
        transactionId: transactionId.toString(),
        orderId: orderId.toString(),
        amount: amount_cents / 100,
        currency
      }
    })

    const processingTime = Date.now() - processingStart

    logger.info({
      webhookId,
      bookingId: payment.bookingId,
      success,
      processingTime,
      totalTimeFromCreation: minutesDiff + processingTime / 60000
    }, 'Booking processing completed')

    return new Response('OK', {
      status: 200,
      headers: {
        'Content-Type': 'text/plain',
        'X-Webhook-ID': webhookId,
        'X-Processing-Time': processingTime.toString(),
        'X-Booking-ID': payment.bookingId
      }
    })
  } catch (error: any) {
    logger.error('Webhook processing error', error, {
      webhookId,
      url: request.url,
      body: JSON.stringify(await request.json()).substring(0, 500)
    })

    return new Response('ERROR', {
      status: 500,
      headers: {
        'Content-Type': 'text/plain',
        'X-Webhook-Status': 'ERROR',
        'X-Error-Message': error.message.substring(0, 100)
      }
    })
  }
}
// app/api/payment/create/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'
import { BookingOrchestrator } from '@/lib/application/services/booking-orchestrator' // ğŸ”§ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„ÙƒÙ„Ø§Ø³
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { logger } from '@/lib/shared/logger'

export async function POST(request: NextRequest) {
  const requestId = `create_payment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    logger.info({ requestId }, 'Creating payment')

    const session = await getServerSession(authOptions)
    const userId = session?.user?.id

    if (!userId) {
      logger.warn({ requestId }, 'Unauthorized payment attempt')
      return NextResponse.json(
        { error: 'ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹' },
        { status: 401 }
      )
    }

    const { bookingId, amount, currency = 'EGP', idempotencyKey } = await request.json()

    if (!bookingId || !amount) {
      logger.warn({ requestId, bookingId, amount }, 'Incomplete payment data')
      return NextResponse.json(
        { error: 'Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯ÙØ¹ ØºÙŠØ± Ù…ÙƒØªÙ…Ù„Ø©' },
        { status: 400 }
      )
    }

    if (amount <= 0) {
      logger.warn({ requestId, amount }, 'Invalid payment amount')
      return NextResponse.json(
        { error: 'Ù‚ÙŠÙ…Ø© Ø§Ù„Ø¯ÙØ¹ ØºÙŠØ± ØµØ§Ù„Ø­Ø©' },
        { status: 400 }
      )
    }

    // ğŸ”§ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§
    const result = await BookingOrchestrator.initiatePayment({  // âœ… BookingOrchestrator.
      bookingId,
      amount,
      currency,
      idempotencyKey,
      userId,
    })

    logger.info({
      requestId,
      bookingId,
      orderId: result.orderId,
      userId
    }, 'Payment initiated successfully')

    return NextResponse.json({
      success: true,
      data: result,
      message: 'ØªÙ… Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¯ÙØ¹ Ø¨Ù†Ø¬Ø§Ø­'
    })

  } catch (error: any) {
    logger.error('Payment creation error', error, { requestId })
    return apiErrorHandler(error)
  }
}
// app/api/fields/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { FIELD_STATUS } from '@/lib/shared/constants'
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { logger } from '@/lib/shared/logger'

export async function GET(request: NextRequest) {
  const requestId = `get_fields_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    const userAgent = request.headers.get('user-agent') || 'unknown'
    const ip = request.headers.get('x-forwarded-for') || request.headers.get('x-real-ip') || 'unknown'
    const acceptLanguage = request.headers.get('accept-language') || 'ar'
    const acceptEncoding = request.headers.get('accept-encoding') || 'gzip'
    
    logger.info({ 
      msg: 'Fetching fields',
      requestId, 
      userAgent, 
      ip, 
      acceptLanguage, 
      acceptEncoding, 
      url: request.url, 
      method: request.method 
    })
    
    const searchParams = request.nextUrl.searchParams
    const type = searchParams.get('type')
    const location = searchParams.get('location')
    const page = parseInt(searchParams.get('page') || '1')
    const limit = parseInt(searchParams.get('limit') || '10')
    const minPrice = searchParams.get('minPrice')
    const maxPrice = searchParams.get('maxPrice')
    const sortBy = searchParams.get('sortBy') || 'createdAt'
    const sortOrder = searchParams.get('sortOrder') || 'desc'

    if (page < 1 || limit < 1 || limit > 100) {
      return NextResponse.json({ 
        success: false, 
        error: 'Ù‚ÙŠÙ… Ø§Ù„ØªØµÙØ­ ØºÙŠØ± ØµØ§Ù„Ø­Ø©', 
        code: 'INVALID_PAGINATION' 
      }, { status: 400 })
    }

    const skip = (page - 1) * limit
    const where: any = { status: FIELD_STATUS.OPEN }

    if (type && type !== 'Ø§Ù„ÙƒÙ„') where.type = type.toUpperCase()
    if (location && location !== 'Ø§Ù„ÙƒÙ„') where.location = location
    if (minPrice) where.pricePerHour = { ...where.pricePerHour, gte: parseFloat(minPrice) }
    if (maxPrice) where.pricePerHour = { ...where.pricePerHour, lte: parseFloat(maxPrice) }

    const orderBy: any = {}
    if (sortBy === 'price') orderBy.pricePerHour = sortOrder
    else if (sortBy === 'name') orderBy.name = sortOrder
    else orderBy.createdAt = 'desc'

    // âœ… Ø§Ø³ØªØ®Ø¯Ù… select ÙÙ‚Ø· Ù…Ø¹ _count
    const [fields, totalCount] = await Promise.all([
      prisma.field.findMany({
        where,
        orderBy,
        skip,
        take: limit,
        select: {
          id: true,
          name: true,
          description: true,
          location: true,
          address: true,
          type: true,
          imageUrl: true,
          pricePerHour: true,
          depositPrice: true,
          facilities: true,
          _count: {
            select: {
              bookings: true,
              reviews: true
            }
          }
        }
      }),
      prisma.field.count({ where })
    ])

    const enrichedFields = fields.map((field: any) => ({
      ...field,
      popularity: field._count.bookings,
      positiveReviews: field._count.reviews,
      isPopular: field._count.bookings > 10,
      hasDiscount: field.pricePerHour > 100,
      estimatedEarnings: field.pricePerHour * field._count.bookings
    }))

    const totalPages = Math.ceil(totalCount / limit)
    const hasNextPage = page < totalPages
    const hasPreviousPage = page > 1

    logger.info({ 
      msg: 'Fields fetched successfully',
      requestId, 
      count: fields.length, 
      totalCount, 
      page, 
      limit, 
      totalPages, 
      filters: { type, location, minPrice, maxPrice } 
    })
    
    return NextResponse.json({ 
      success: true,
      data: enrichedFields,
      pagination: {
        currentPage: page,
        totalPages,
        totalItems: totalCount,
        itemsPerPage: limit,
        hasNextPage,
        hasPreviousPage
      },
      filters: {
        applied: { type, location, minPrice, maxPrice, sortBy, sortOrder },
        available: {
          types: ['FOOTBALL', 'BASKETBALL', 'TENNIS', 'SWIMMING'],
          locations: ['Ø§Ù„Ù‚Ø§Ù‡Ø±Ø©', 'Ø§Ù„Ø¬ÙŠØ²Ø©', 'Ø§Ù„Ø¥Ø³ÙƒÙ†Ø¯Ø±ÙŠØ©', 'Ø§Ù„Ù…Ù†ØµÙˆØ±Ø©'],
          priceRange: { min: 50, max: 500, step: 50 }
        }
      },
      metadata: {
        requestId,
        generatedAt: new Date().toISOString(),
        cacheInfo: { recommended: true, duration: 300 }
      }
    }, {
      headers: {
        'Cache-Control': 'public, max-age=300, stale-while-revalidate=60',
        'X-Total-Count': totalCount.toString(),
        'X-Page-Count': totalPages.toString(),
        'X-Request-ID': requestId
      }
    })
    
  } catch (error: any) {
    logger.error({ 
      msg: 'Error fetching fields',
      error: error.message,
      requestId, 
      url: request.url 
    })
    return apiErrorHandler(error)
  }
}
// app/api/fields/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { FIELD_STATUS } from '@/lib/shared/constants'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { logger } from '@/lib/shared/logger'

interface Params {
  params: {
    id: string
  }
}

export async function GET(
  request: NextRequest,
  { params }: Params
) {
  const requestId = `get_field_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    const fieldId = params.id
    
    const userAgent = request.headers.get('user-agent') || 'unknown'
    const ip = request.headers.get('x-forwarded-for') || request.headers.get('x-real-ip') || 'unknown'
    const acceptLanguage = request.headers.get('accept-language') || 'unknown'
    
    logger.info({ 
      requestId, 
      fieldId,
      userAgent,
      ip,
      acceptLanguage,
      url: request.url,
      method: request.method
    }, 'Fetching field details')

    if (!fieldId) {
      throw new DomainError('VALIDATION_ERROR', 'Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ù…Ù„Ø¹Ø¨ ØºÙŠØ± ØµØ§Ù„Ø­')
    }

    const ifNoneMatch = request.headers.get('if-none-match')
    const cacheKey = `field_${fieldId}`
    
    if (ifNoneMatch === cacheKey) {
      return new NextResponse(null, { status: 304 })
    }

    // âœ… Ø´ÙŠÙ„ reviewCount Ù…Ù† select
    const field = await prisma.field.findUnique({
      where: { id: fieldId },
      select: {
        id: true,
        name: true,
        description: true,
        location: true,
        address: true,
        type: true,
        imageUrl: true,
        pricePerHour: true,
        depositPrice: true,
        openingTime: true,
        closingTime: true,
        slotDurationMin: true,
        status: true,
        facilities: true,
        gallery: true
      }
    })

    if (!field) {
      logger.warn({ requestId, fieldId, ip }, 'Field not found')
      throw new DomainError('FIELD_NOT_FOUND', 'Ø§Ù„Ù…Ù„Ø¹Ø¨ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯')
    }

    if (field.status === FIELD_STATUS.CLOSED || field.status === FIELD_STATUS.MAINTENANCE) {
      logger.warn({ 
        requestId, 
        fieldId, 
        status: field.status,
        ip 
      }, 'Field not available')
      
      return NextResponse.json({
        success: false,
        error: 'Ø§Ù„Ù…Ù„Ø¹Ø¨ ØºÙŠØ± Ù…ØªØ§Ø­ Ø­Ø§Ù„ÙŠÙ‹Ø§',
        code: 'FIELD_UNAVAILABLE',
        field: {
          id: field.id,
          name: field.name,
          status: field.status,
          estimatedReopen: field.status === FIELD_STATUS.MAINTENANCE ? 
            'Ø®Ù„Ø§Ù„ 24 Ø³Ø§Ø¹Ø©' : 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'
        }
      }, { 
        status: 403,
        headers: {
          'Cache-Control': 'no-cache',
          'X-Field-Status': field.status
        }
      })
    }

    const bookingsCount = await prisma.booking.count({
      where: {
        fieldId: fieldId,
        status: 'CONFIRMED'
      }
    })

    logger.info({ 
      requestId, 
      fieldId,
      totalBookings: bookingsCount
    }, 'Field details fetched successfully')
    
    return NextResponse.json({
      success: true,
      data: {
        field: {
          ...field,
          gallery: field.gallery || [],
          popularity: bookingsCount
        }
      },
      metadata: {
        cached: false,
        expires: new Date(Date.now() + 5 * 60 * 1000).toISOString()
      }
    }, {
      headers: {
        'ETag': cacheKey,
        'Cache-Control': 'public, max-age=300',
        'X-Request-ID': requestId
      }
    })
    
  } catch (error: any) {
    logger.error('Error fetching field', error, { 
      requestId,
      url: request.url 
    })
    return apiErrorHandler(error)
  }
}
// app/api/fields/[id]/slots/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { generateSlotsForDay } from '@/lib/domain/slots/time-slots/core-logic'
import { getUISlots } from '@/lib/domain/slots/read-model'
import { FIELD_STATUS, SLOT_STATUS } from '@/lib/shared/constants'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { logger } from '@/lib/shared/logger'

export async function GET(
  request: NextRequest,
  { params }: { params: { fieldId: string } }
) {
  const requestId = `get_slots_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    const fieldId = params.fieldId
    const { searchParams } = new URL(request.url)
    const dateParam = searchParams.get('date')
    
    // Ø§Ø³ØªØ®Ø¯Ø§Ù… request Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† rate limiting
    const ip = request.headers.get('x-forwarded-for') || 'unknown'
    const userAgent = request.headers.get('user-agent') || 'unknown'
    
    logger.info({ 
      requestId, 
      fieldId, 
      dateParam,
      ip,
      userAgent 
    }, 'Fetching slots')

    if (!fieldId) {
      throw new DomainError('VALIDATION_ERROR', 'Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ù„Ø¹Ø¨ Ù…Ø·Ù„ÙˆØ¨')
    }

    if (!dateParam) {
      throw new DomainError('VALIDATION_ERROR', 'Ø§Ù„ØªØ§Ø±ÙŠØ® Ù…Ø·Ù„ÙˆØ¨')
    }

    const date = new Date(dateParam)
    if (isNaN(date.getTime())) {
      throw new DomainError('VALIDATION_ERROR', 'ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ø±ÙŠØ® ØºÙŠØ± ØµØ§Ù„Ø­')
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„ØªØ§Ø±ÙŠØ® Ù„ÙŠØ³ ÙÙŠ Ø§Ù„Ù…Ø§Ø¶ÙŠ
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    
    if (date < today) {
      throw new DomainError('INVALID_DATE', 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø¬Ø² Ù…ÙˆØ§Ø¹ÙŠØ¯ ÙÙŠ Ø§Ù„Ù…Ø§Ø¶ÙŠ')
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„ØªØ§Ø±ÙŠØ® Ù„ÙŠØ³ Ø£Ø¨Ø¹Ø¯ Ù…Ù† 30 ÙŠÙˆÙ…
    const maxDate = new Date()
    maxDate.setDate(maxDate.getDate() + 30)
    
    if (date > maxDate) {
      throw new DomainError('INVALID_DATE', 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø¬Ø² Ù…ÙˆØ§Ø¹ÙŠØ¯ Ø£Ø¨Ø¹Ø¯ Ù…Ù† 30 ÙŠÙˆÙ…')
    }

    const field = await prisma.field.findUnique({
      where: { id: fieldId }
    })

    if (!field) {
      throw new DomainError('FIELD_NOT_FOUND', 'Ø§Ù„Ù…Ù„Ø¹Ø¨ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯')
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ù„Ø¹Ø¨
    if (field.status === FIELD_STATUS.CLOSED) {
      logger.info({ requestId, fieldId }, 'Field is closed')
      return NextResponse.json({
        success: true,
        data: {
          slots: [],
          field: {
            id: field.id,
            name: field.name,
            status: field.status,
            message: 'Ø§Ù„Ù…Ù„Ø¹Ø¨ Ù…ØºÙ„Ù‚ Ø­Ø§Ù„ÙŠØ§Ù‹'
          },
          metadata: {
            reason: 'FIELD_CLOSED',
            reopenDate: field.closingTime ? new Date(field.closingTime).toISOString() : null
          }
        }
      })
    }

    if (field.status === FIELD_STATUS.MAINTENANCE) {
      logger.info({ requestId, fieldId }, 'Field is under maintenance')
      return NextResponse.json({
        success: true,
        data: {
          slots: [],
          field: {
            id: field.id,
            name: field.name,
            status: field.status,
            message: 'Ø§Ù„Ù…Ù„Ø¹Ø¨ ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©'
          },
          metadata: {
            reason: 'FIELD_MAINTENANCE',
            estimatedCompletion: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
          }
        }
      })
    }

    // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³Ù„Ø§Øª Ø§Ù„Ù…Ù‚ÙÙˆÙ„Ø© Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ©
    const cleanupResult = await prisma.slot.updateMany({
      where: {
        fieldId,
        status: SLOT_STATUS.TEMP_LOCKED,
        lockedUntil: { lt: new Date() }
      },
      data: {
        status: SLOT_STATUS.AVAILABLE,
        lockedById: null,
        lockedUntil: null
      }
    })

    if (cleanupResult.count > 0) {
      logger.debug({ 
        requestId, 
        cleaned: cleanupResult.count 
      }, 'Cleaned expired locks')
    }

    // ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø³Ù„Ø§Øª
    const slots = await generateSlotsForDay({
      fieldId,
      date,
      now: new Date()
    })

    const uiSlots = getUISlots(slots)

    // âœ… Ø¥ØµÙ„Ø§Ø­: Ø§Ø³ØªØ®Ø¯Ù… uiStatus Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† status
    const availableSlots = uiSlots.filter(s => s.uiStatus === 'AVAILABLE').length
    const lockedSlots = uiSlots.filter(s => s.uiStatus === 'LOCKED_ME' || s.uiStatus === 'LOCKED_OTHER').length
    const bookedSlots = uiSlots.filter(s => s.uiStatus === 'BOOKED').length

    logger.info({ 
      requestId, 
      fieldId, 
      slotCount: uiSlots.length,
      availableSlots,
      lockedSlots
    }, 'Slots fetched successfully')
    
    return NextResponse.json({
      success: true,
      data: {
        field: {
          id: field.id,
          name: field.name,
          description: field.description,
          status: field.status,
          pricePerHour: field.pricePerHour,
          depositPrice: field.depositPrice,
          openingTime: field.openingTime,
          closingTime: field.closingTime,
          slotDuration: field.slotDuration // âœ… ØªØµØ­ÙŠØ­: slotDuration Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† slotDurationMin
        },
        slots: uiSlots,
        date: date.toISOString().split('T')[0],
        statistics: {
          total: uiSlots.length,
          available: availableSlots, // âœ… Ù…Ø³ØªØ®Ø¯Ù… uiStatus
          locked: lockedSlots,       // âœ… Ù…Ø³ØªØ®Ø¯Ù… uiStatus
          booked: bookedSlots        // âœ… Ù…Ø³ØªØ®Ø¯Ù… uiStatus
        }
      }
    }, {
      headers: {
        'Cache-Control': 'public, max-age=60', // 1 Ø¯Ù‚ÙŠÙ‚Ø© Ù„Ù„Ø³Ù„Ø§Øª
        'X-Request-ID': requestId
      }
    })

  } catch (error: any) {
    logger.error('Get slots error', error, { 
      requestId,
      url: request.url 
    })
    return apiErrorHandler(error)
  }
}
// app/api/fields/[id]/slots/date/[date]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { parseISO, isValid, startOfDay } from 'date-fns'
import { generateSlotsForDay } from '@/lib/domain/slots/time-slots/core-logic'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { SLOT_STATUS } from '@/lib/shared/constants'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { logger } from '@/lib/shared/logger'

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string; date: string } }
) {
  const requestId = `get_slots_by_date_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    const { id: fieldId, date } = params

    const userAgent = request.headers.get('user-agent') || 'unknown'
    const accept = request.headers.get('accept') || 'application/json'
    
    logger.info({ 
      requestId, 
      fieldId, 
      date,
      userAgent,
      accept
    }, 'Fetching slots by date')

    if (!fieldId || !date) {
      throw new DomainError('VALIDATION_ERROR', 'Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ù„Ø¹Ø¨ ÙˆØ§Ù„ØªØ§Ø±ÙŠØ® Ù…Ø·Ù„ÙˆØ¨Ø§Ù†')
    }

    const parsedDate = parseISO(date)

    if (!isValid(parsedDate)) {
      throw new DomainError('VALIDATION_ERROR', 'ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ø±ÙŠØ® ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† YYYY-MM-DD')
    }

    const now = new Date()
    const startOfToday = startOfDay(now)
    
    if (parsedDate < startOfToday) {
      throw new DomainError('INVALID_DATE', 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¹Ø±Ø¶ Ù…ÙˆØ§Ø¹ÙŠØ¯ ÙÙŠ Ø§Ù„Ù…Ø§Ø¶ÙŠ')
    }

    const cleanupResult = await prisma.slot.updateMany({
      where: {
        fieldId,
        status: SLOT_STATUS.TEMP_LOCKED,
        lockedUntil: { lt: now }
      },
      data: {
        status: SLOT_STATUS.AVAILABLE,
        lockedUntil: null,
        lockedById: null
      }
    })

    if (cleanupResult.count > 0) {
      logger.debug({
        requestId,
        cleaned: cleanupResult.count
      }, 'Cleaned expired locks')
    }

    const slots = await generateSlotsForDay({
      fieldId,
      date: startOfDay(parsedDate),
      now
    })

    const normalizedSlots = slots.map(slot => {
      const startTimeISO = slot.startTime.toISOString()
      const endTimeISO = slot.endTime.toISOString()

      return {
        ...slot,
        startTime: startTimeISO,
        endTime: endTimeISO,
        durationMinutes: Math.floor(
          (slot.endTime.getTime() - slot.startTime.getTime()) / (1000 * 60)
        ),
        price: slot.price,
        isPast: slot.startTime < now, // Ù‡Ù†Ø§ Ù„Ø³Ù‡ Date
        canBook: slot.status === 'AVAILABLE' && slot.startTime > now,
        timeUntilStart: slot.startTime.getTime() - now.getTime()
      }
    })

    const stats = {
      total: normalizedSlots.length,
      available: normalizedSlots.filter(s => s.status === 'AVAILABLE').length,
      locked: normalizedSlots.filter(s => s.status === 'TEMP_LOCKED').length,
      booked: normalizedSlots.filter(s => s.status === 'BOOKED').length,
      past: normalizedSlots.filter(s => new Date(s.startTime) < now).length
    }

    logger.info({ 
      requestId, 
      fieldId, 
      date,
      slotCount: normalizedSlots.length,
      stats
    }, 'Slots by date fetched successfully')
    
    return NextResponse.json({
      success: true,
      data: {
        fieldId,
        date: parsedDate.toISOString().split('T')[0],
        slots: normalizedSlots,
        statistics: stats,
        metadata: {
          generatedAt: now.toISOString(),
          cacheDuration: 60,
          timezone: 'Africa/Cairo'
        }
      }
    }, {
      headers: {
        'Cache-Control': 'public, max-age=60',
        'X-Request-ID': requestId,
        'X-Slots-Count': normalizedSlots.length.toString()
      }
    })
    
  } catch (error: any) {
    logger.error('Get slots by date error', error, { 
      requestId,
      url: request.url 
    })
    return apiErrorHandler(error)
  }
}
// app/api/fields/[fieldId]/slots/[slotId]/lock/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'
import { addMinutes } from 'date-fns'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { SLOT_STATUS } from '@/lib/shared/constants'
import { logger } from '@/lib/shared/logger'
import { assertSlotCanLock } from '@/lib/domain/guards/slot-guards' // âœ… Ø§Ù„Ø¢Ù† Ù…Ø³ØªØ®Ø¯Ù…

const LOCK_DURATION_MINUTES = 5

export async function POST(
  request: NextRequest,
  { params }: { params: { fieldId: string; slotId: string } }
) {
  const requestId = `lock_slot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    // Ø§Ø³ØªØ®Ø¯Ø§Ù… request Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† headers
    const userAgent = request.headers.get('user-agent') || 'unknown'
    const ip = request.headers.get('x-forwarded-for') || 'unknown'
    
    logger.info({ 
      requestId, 
      fieldId: params.fieldId,
      slotId: params.slotId,
      userAgent,
      ip,
      endpoint: request.url
    }, 'Locking slot')

    const session = await getServerSession(authOptions)
    const userId = session?.user?.id

    if (!userId) {
      logger.warn({ 
        requestId,
        ip,
        userAgent,
        fieldId: params.fieldId,
        slotId: params.slotId
      }, 'Unauthorized lock attempt')
      throw new DomainError('UNAUTHORIZED', 'ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù„Ù‚ÙÙ„ Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯')
    }

    const { slotId, fieldId } = params
    const now = new Date()

    // âœ… Ø§Ø³ØªØ®Ø¯Ø§Ù… assertSlotCanLock Ù„Ù„ØªØ­Ù‚Ù‚ Ù‚Ø¨Ù„ Ø§Ù„Ù‚ÙÙ„
    const validation = await assertSlotCanLock({
      slotId,
      userId,
      fieldId
    })

    // Ø¥Ø°Ø§ ÙƒØ§Ù† ÙŠÙ…ÙƒÙ† ØªÙ…Ø¯ÙŠØ¯ Ø§Ù„Ù‚ÙÙ„
    if (validation.canExtend) {
      logger.info({
        requestId,
        slotId,
        userId,
        previousLockUntil: validation.slot.lockedUntil,
        newLockUntil: addMinutes(now, LOCK_DURATION_MINUTES)
      }, 'Extending existing lock')
      
      await prisma.slot.update({
        where: { id: slotId },
        data: {
          lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES)
        }
      })

      return NextResponse.json({
        success: true,
        data: {
          extended: true,
          lockDuration: LOCK_DURATION_MINUTES,
          lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES).toISOString(),
          message: 'ØªÙ… ØªÙ…Ø¯ÙŠØ¯ Ù‚ÙÙ„ Ø§Ù„Ù…ÙˆØ¹Ø¯ Ø¨Ù†Ø¬Ø§Ø­'
        },
        metadata: {
          requestId,
          userId,
          timestamp: now.toISOString()
        }
      })
    }

    // Ù‚ÙÙ„ Ø¬Ø¯ÙŠØ¯
    const result = await prisma.$transaction(async (tx: any) => {
      const updateResult = await tx.slot.updateMany({
        where: {
          id: slotId,
          fieldId: fieldId,
          OR: [
            {
              status: SLOT_STATUS.AVAILABLE
            },
            {
              status: SLOT_STATUS.TEMP_LOCKED,
              OR: [
                { lockedUntil: null },
                { lockedUntil: { lt: now } }
              ]
            }
          ]
        },
        data: {
          status: SLOT_STATUS.TEMP_LOCKED,
          lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES),
          lockedById: null
        }
      })

      if (updateResult.count === 0) {
        const slot = await tx.slot.findUnique({
          where: { id: slotId },
          include: {
            field: {
              select: { id: true, name: true }
            },
            lockedByUser: {
              select: { id: true, email: true, name: true }
            }
          }
        })

        if (!slot) {
          throw new DomainError('SLOT_NOT_FOUND', 'Ø§Ù„Ù…ÙˆØ¹Ø¯ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯')
        }

        if (slot.status === SLOT_STATUS.BOOKED) {
          throw new DomainError('SLOT_ALREADY_BOOKED', 'Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù…Ø­Ø¬ÙˆØ² Ø¨Ø§Ù„ÙØ¹Ù„')
        }

        if (slot.status === SLOT_STATUS.TEMP_LOCKED && slot.lockedUntil && slot.lockedUntil > now) {
          if (slot.lockedByUserId === userId) {
            // ØªØ­Ø¯ÙŠØ« ÙˆÙ‚Øª Ø§Ù„Ù‚ÙÙ„
            await tx.slot.update({
              where: { id: slotId },
              data: {
                lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES)
              }
            })
            
            logger.info({ 
              requestId, 
              slotId, 
              userId,
              fieldName: slot.field?.name 
            }, 'Slot lock extended (fallback)')
            return { success: true, extended: true }
          } else {
            throw new DomainError('SLOT_LOCKED_BY_OTHER', 
              `Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù…Ù‚ÙÙˆÙ„ Ø­Ø§Ù„ÙŠØ§Ù‹ Ø¨ÙˆØ§Ø³Ø·Ø© ${slot.lockedByUser?.name || 'Ù…Ø³ØªØ®Ø¯Ù… Ø¢Ø®Ø±'}`
            )
          }
        }

        throw new DomainError('SLOT_CANNOT_BE_LOCKED', 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ù‚ÙÙ„ Ù‡Ø°Ø§ Ø§Ù„Ù…ÙˆØ¹Ø¯ Ø­Ø§Ù„ÙŠØ§Ù‹')
      }

      logger.info({ 
        requestId, 
        slotId, 
        userId,
        lockDuration: LOCK_DURATION_MINUTES,
        lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES).toISOString()
      }, 'Slot locked successfully')
      
      return { success: true, locked: true }
    })

    // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Slot Ø¨Ø¹Ø¯ Ø§Ù„Ù‚ÙÙ„
    const updatedSlot = await prisma.slot.findUnique({
      where: { id: slotId },
      select: {
        id: true,
        startTime: true,
        endTime: true,
        status: true,
        lockedUntil: true,
        field: {
          select: {
            id: true,
            name: true,
            pricePerHour: true
          }
        }
      }
    })

    return NextResponse.json({
      success: true,
      data: {
        ...result,
        slot: updatedSlot,
        lockDuration: LOCK_DURATION_MINUTES,
        lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES).toISOString(),
        expiresIn: LOCK_DURATION_MINUTES * 60, // Ø¨Ø§Ù„Ø«ÙˆØ§Ù†ÙŠ
        countdownStart: now.getTime(),
        message: result.extended ? 'ØªÙ… ØªÙ…Ø¯ÙŠØ¯ Ø§Ù„Ù‚ÙÙ„' : 'ØªÙ… Ù‚ÙÙ„ Ø§Ù„Ù…ÙˆØ¹Ø¯ Ø¨Ù†Ø¬Ø§Ø­'
      },
      metadata: {
        requestId,
        userId,
        timestamp: now.toISOString(),
        cacheControl: 'no-cache'
      }
    }, {
      headers: {
        'Cache-Control': 'no-store, no-cache, must-revalidate',
        'X-Lock-Duration': LOCK_DURATION_MINUTES.toString(),
        'X-Request-ID': requestId
      }
    })

  } catch (error: any) {
    logger.error('Lock error', error, { 
      requestId,
      url: request.url,
      params,
      ip: request.headers.get('x-forwarded-for') || 'unknown'
    })
    
    return apiErrorHandler(error)
  }
}
//app/api/cron/cleanup/rout.ts
import { NextResponse } from 'next/server'
import { BookingOrchestrator } from '@/lib/application/services/booking-orchestrator' // ğŸ”§ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„ÙƒÙ„Ø§Ø³
import { ENV } from '@/lib/shared/env/env'
import { logger } from '@/lib/shared/logger'

export const dynamic = 'force-dynamic'

export async function GET(request: Request) {
  const jobId = `cron_cleanup_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    logger.info({ jobId }, 'Starting cron cleanup job')
    
    const authHeader = request.headers.get('authorization')
    
    if (authHeader !== `Bearer ${ENV.CRON_SECRET}`) {
      logger.warn({ jobId }, 'Unauthorized cron attempt')
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // ğŸ”§ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§ - Ø§Ø³ØªØ®Ø¯Ù… static methods
    const [expireResult, unlockResult] = await Promise.all([
      BookingOrchestrator.cleanupExpiredBookings(),    // âœ… BookingOrchestrator.
      BookingOrchestrator.cleanupExpiredLocks()        // âœ… BookingOrchestrator.
    ])

    logger.info({ 
      jobId,
      expiredBookings: expireResult.cleaned || 0,
      unlockedSlots: unlockResult.unlockedSlots || 0
    }, 'Cron cleanup completed')
    
    return NextResponse.json({
      success: true,
      timestamp: new Date().toISOString(),
      results: {
        expireBookings: expireResult,
        unlockSlots: unlockResult
      }
    })
  } catch (error: any) {
    logger.error('Cron cleanup error', error, { jobId })
    return NextResponse.json(
      { 
        success: false,
        error: 'Cleanup failed', 
        details: error.message 
      },
      { status: 500 }
    )
  }
}
// app/api/bookings/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'
import { BookingOrchestrator } from '@/lib/application/services/booking-orchestrator'  // âœ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„ÙƒÙ„Ø§Ø³ Ù…Ø¨Ø§Ø´Ø±Ø©
import { IdempotencyGuard } from '@/lib/application/idempotency/idempotency-guard'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { BOOKING_STATUS } from '@/lib/shared/constants'
import { logger } from '@/lib/shared/logger'

export async function GET(request: NextRequest) {
  const requestId = `get_bookings_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    logger.info({ requestId }, 'Fetching bookings')
    
    const session = await getServerSession(authOptions)
    const userId = session?.user?.id

    if (!userId) {
      logger.warn({ requestId }, 'Unauthorized access to bookings')
      throw new DomainError('UNAUTHORIZED')
    }

    const { searchParams } = new URL(request.url)
    const page = parseInt(searchParams.get('page') || '1')
    const limit = Math.min(parseInt(searchParams.get('limit') || '20'), 50)
    const status = searchParams.get('status')
    const skip = (page - 1) * limit

    const where: any = { userId }
    
    if (status) {
      where.status = status
    } else {
      where.status = {
        in: [BOOKING_STATUS.CONFIRMED, BOOKING_STATUS.PENDING_PAYMENT]
      }
    }

    const [bookings, total] = await Promise.all([
      prisma.booking.findMany({
        where,
        include: {
          field: {
            select: {
              id: true,
              name: true,
              pricePerHour: true
            }
          },
          slot: {
            select: {
              id: true,
              startTime: true,
              endTime: true,
              durationMinutes: true
            }
          },
          payments: {
            take: 1,
            orderBy: { createdAt: 'desc' }
          }
        },
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit
      }),
      prisma.booking.count({ where })
    ])

    logger.info({ 
      requestId, 
      userId, 
      count: bookings.length,
      total 
    }, 'Bookings fetched successfully')
    
    return NextResponse.json({
      success: true,
      data: bookings,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
        hasMore: page * limit < total
      }
    })

  } catch (error: any) {
    logger.error('Get bookings error', error, { requestId })
    return apiErrorHandler(error)
  }
}

export async function POST(request: NextRequest) {
  const requestId = `create_booking_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    logger.info({ requestId }, 'Creating booking')
    
    const session = await getServerSession(authOptions)
    const userId = session?.user?.id

    if (!userId) {
      logger.warn({ requestId }, 'Unauthorized booking creation attempt')
      throw new DomainError('UNAUTHORIZED')
    }

    const { slotId, fieldId, idempotencyKey } = await request.json()

    if (!slotId || !fieldId) {
      logger.warn({ requestId, slotId, fieldId }, 'Incomplete booking data')
      throw new DomainError('VALIDATION_ERROR', 'Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø¬Ø² ØºÙŠØ± Ù…ÙƒØªÙ…Ù„Ø©')
    }

    const finalKey = idempotencyKey || IdempotencyGuard.generateKey('booking')

    // âœ… Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ù€ static method Ù…Ù† Ø§Ù„ÙƒÙ„Ø§Ø³
    const result = await BookingOrchestrator.createBooking({
      userId,
      slotId,
      fieldId,
      idempotencyKey: finalKey
    })

    logger.info({ 
      requestId, 
      bookingId: result.bookingId,
      userId 
    }, 'Booking created successfully')
    
    return NextResponse.json({
      success: true,
      ...result,
      idempotencyKey: finalKey
    })

  } catch (error: any) {
    logger.error('Create booking error', error, { requestId })
    return apiErrorHandler(error)
  }
}
// app/api/auth/register/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { RateLimiterMemory } from 'rate-limiter-flexible'
import { prisma } from '@/lib/infrastructure/database/prisma'  
import { hashPassword } from '@/lib/infrastructure/security/password'  // âœ… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯
import { z } from 'zod'
import { logger } from '@/lib/shared/logger'  // âœ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù€ logger Ø§Ù„Ø¬Ø¯ÙŠØ¯

// Rate Limiter Ù„Ù„ØªØ³Ø¬ÙŠÙ„
const registerRateLimiter = new RateLimiterMemory({
  points: 3,
  duration: 60 * 60,
  blockDuration: 60 * 60,
})

const registerSchema = z.object({
  name: z.string().min(2, 'Ø§Ù„Ø§Ø³Ù… ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø­Ø±ÙÙŠÙ† Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„'),
  email: z.string().email('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ØºÙŠØ± ØµØ§Ù„Ø­'),
  password: z.string()
    .min(6, 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† 6 Ø£Ø­Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„')
    .max(72, 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø·ÙˆÙŠÙ„Ø© Ø¬Ø¯Ø§Ù‹'),
  phoneNumber: z.string().min(10, 'Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ ØºÙŠØ± ØµØ§Ù„Ø­'),
  age: z.number().min(13, 'Ø§Ù„Ø¹Ù…Ø± ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† 13 Ø³Ù†Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„'),
  skillLevel: z.enum(['WEAK', 'AVERAGE', 'GOOD', 'EXCELLENT', 'LEGENDARY'])
})

const normalizeEmail = (email: string): string => {
  return email.toLowerCase().trim()
}

const checkRegisterRateLimit = async (ip: string) => {
  try {
    await registerRateLimiter.consume(ip)
    return { allowed: true }
  } catch (rateLimiterRes: any) {
    const retryAfter = Math.ceil(rateLimiterRes.msBeforeNext / 1000) || 60
    throw new Error(`Ù„Ù‚Ø¯ ØªØ¬Ø§ÙˆØ²Øª Ø§Ù„Ø­Ø¯ Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡ Ù…Ù† Ø§Ù„ØªØ³Ø¬ÙŠÙ„Ø§Øª. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¨Ø¹Ø¯ ${retryAfter} Ø«Ø§Ù†ÙŠØ©`)
  }
}

const getClientIp = (request: NextRequest): string => {
  const forwardedFor = request.headers.get('x-forwarded-for')
  const realIp = request.headers.get('x-real-ip')
  
  if (forwardedFor) {
    return forwardedFor.split(',')[0].trim()
  }
  
  return realIp || 'unknown'
}

export async function POST(request: NextRequest) {
  const requestId = `register_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    logger.info({ requestId }, 'Registration attempt')
    
    const clientIp = getClientIp(request)
    await checkRegisterRateLimit(clientIp)
    
    const body = await request.json()
    const validatedData = registerSchema.parse(body)

    const normalizedEmail = normalizeEmail(validatedData.email)

    const existingUser = await prisma.user.findUnique({
      where: { email: normalizedEmail }
    })

    if (existingUser) {
      logger.warn({ requestId, email: normalizedEmail }, 'Email already exists')
      return NextResponse.json(
        { 
          success: false,
          error: 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„',
          code: 'EMAIL_ALREADY_EXISTS'
        },
        { status: 409 }
      )
    }

    const existingPhone = await prisma.user.findUnique({
      where: { phoneNumber: validatedData.phoneNumber }
    })

    if (existingPhone) {
      logger.warn({ requestId, phone: validatedData.phoneNumber }, 'Phone already exists')
      return NextResponse.json(
        { 
          success: false,
          error: 'Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„',
          code: 'PHONE_ALREADY_EXISTS'
        },
        { status: 409 }
      )
    }

    const hashedPassword = await hashPassword(validatedData.password)

    const user = await prisma.user.create({
      data: {
        name: validatedData.name,
        email: normalizedEmail,
        passwordHash: hashedPassword,
        phoneNumber: validatedData.phoneNumber,
        age: validatedData.age,
        skillLevel: validatedData.skillLevel,
        role: 'PLAYER',
        roleUpdatedAt: new Date(),
        isActive: true,
        isVerified: false,
        emailVerifiedAt: null
      }
    })

    logger.info({ requestId, userId: user.id }, 'Registration successful')
    
    return NextResponse.json({
      success: true,
      message: 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø¨Ù†Ø¬Ø§Ø­',
      data: {
        id: user.id,
        name: user.name,
        email: user.email,
        requiresVerification: true
      }
    }, { status: 201 })

  } catch (error: any) {
    if (error.name === 'ZodError') {
      const firstError = error.errors[0]
      logger.warn({ requestId, error: firstError.message }, 'Validation error in registration')
      return NextResponse.json(
        { 
          success: false,
          error: firstError.message,
          code: 'VALIDATION_ERROR'
        },
        { status: 400 }
      )
    }

    if (error.message.includes('Ù„Ù‚Ø¯ ØªØ¬Ø§ÙˆØ²Øª Ø§Ù„Ø­Ø¯ Ø§Ù„Ù…Ø³Ù…ÙˆØ­')) {
      logger.warn({ requestId, error: error.message }, 'Rate limit exceeded')
      return NextResponse.json(
        { 
          success: false,
          error: error.message,
          code: 'RATE_LIMIT_EXCEEDED'
        },
        { status: 429 }
      )
    }

    logger.error('Registration error', error, { requestId })
    return NextResponse.json(
      { 
        success: false,
        error: 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨',
        code: 'INTERNAL_SERVER_ERROR'
      },
      { status: 500 }
    )
  }
}
// app/api/auth/me/route.ts
import { NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { successResponse, errorResponse } from '@/lib/infrastructure/auth/responses'
import { logger } from '@/lib/shared/logger'

// âœ… Ø£Ø¶Ù Ù‡Ø°Ø§ Ù„ØªØ­Ø¯ÙŠØ¯ Ø£Ù† Ø§Ù„Ù…Ø³Ø§Ø± Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ
export const dynamic = 'force-dynamic'

export const GET = async () => {
  const requestId = `auth_me_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

  try {
    logger.info({ requestId }, 'Fetching user data')

    const session = await getServerSession(authOptions)

    if (!session?.user?.id) {
      logger.warn({ requestId }, 'Unauthorized access to /api/auth/me')
      return NextResponse.json(
        errorResponse('ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹', 'UNAUTHORIZED'),
        { status: 401 }
      )
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: {
        id: true,
        name: true,
        email: true,
        phoneNumber: true,
        age: true,
        description: true,
        skillLevel: true,
        role: true,
        isVerified: true,
        isActive: true,
        lastLogin: true,
        createdAt: true,
        updatedAt: true,
      }
    })

    if (!user) {
      logger.warn({ requestId, userId: session.user.id }, 'User not found')
      return NextResponse.json(
        errorResponse('Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯', 'USER_NOT_FOUND'),
        { status: 404 }
      )
    }

    if (!user.isActive) {
      logger.warn({ requestId, userId: user.id }, 'Inactive account accessed')
      return NextResponse.json(
        errorResponse('Ø§Ù„Ø­Ø³Ø§Ø¨ ØºÙŠØ± Ù†Ø´Ø·', 'ACCOUNT_INACTIVE'),
        { status: 403 }
      )
    }

    logger.info({ requestId, userId: user.id }, 'User data fetched successfully')

    return NextResponse.json(
      successResponse('ØªÙ… Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­', {
        user: {
          ...user,
          lastLogin: user.lastLogin?.toISOString(),
          createdAt: user.createdAt.toISOString(),
          updatedAt: user.updatedAt.toISOString()
        }
      }, '/api/auth/me')
    )

  } catch (error: any) {
    logger.error('Error in /api/auth/me', error, { requestId })
    return NextResponse.json(
      errorResponse('Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…', 'INTERNAL_ERROR'),
      { status: 500 }
    )
  }
}
// app/api/auth/[...nextauth]/route.ts
import NextAuth from 'next-auth'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'  // âœ… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯

const handler = NextAuth(authOptions)

export { handler as GET, handler as POST }
import { NextRequest, NextResponse } from 'next/server'
import { getToken } from 'next-auth/jwt'

export default async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl
  
  // 1ï¸âƒ£ ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù€ SECRET Ø£ÙˆÙ„Ø§Ù‹
  if (!process.env.NEXTAUTH_SECRET) {
    console.error('âŒ [MIDDLEWARE ERROR] NEXTAUTH_SECRET is not defined')
    
    if (process.env.NODE_ENV === 'production') {
      return new NextResponse('Server configuration error', { 
        status: 500,
        headers: { 'Content-Type': 'text/plain' }
      })
    }
    
    return new NextResponse(
      'NEXTAUTH_SECRET is missing. Add to .env.local:\n' +
      'NEXTAUTH_SECRET=$(openssl rand -base64 32)',
      { 
        status: 500,
        headers: { 'Content-Type': 'text/plain' }
      }
    )
  }
  
  // 2ï¸âƒ£ ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø«Ø§Ø¨ØªØ©
  if (
    pathname.startsWith('/_next') ||
    pathname.startsWith('/api/_next') ||
    pathname.includes('.') ||
    pathname === '/favicon.ico'
  ) {
    return NextResponse.next()
  }
  
  // 3ï¸âƒ£ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ token
  const token = await getToken({ 
    req: request, 
    secret: process.env.NEXTAUTH_SECRET
  })
  
  // 4ï¸âƒ£ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©
  const publicPaths = ['/', '/login', '/register', '/about', '/contact']
  const isPublicPath = publicPaths.some(path => 
    pathname === path || pathname.startsWith('/api/auth')
  )
  
  // 5ï¸âƒ£ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø­Ù…ÙŠØ©
  const isProtectedPath = pathname.startsWith('/dashboard')
  
  // Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©
  if (isPublicPath) {
    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø³Ø¬Ù„ ÙˆÙŠØ­Ø§ÙˆÙ„ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù€ /login Ø£Ùˆ /register
    if (token && (pathname === '/login' || pathname === '/register')) {
      return NextResponse.redirect(new URL('/dashboard', request.url))
    }
    return NextResponse.next()
  }
  
  // Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø­Ù…ÙŠØ©
  if (isProtectedPath) {
    if (!token) {
      const loginUrl = new URL('/login', request.url)
      loginUrl.searchParams.set('redirect', pathname)
      return NextResponse.redirect(loginUrl)
    }
    
    return NextResponse.next()
  }
  
  // Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ø¨Ø§Ù‚ÙŠ
  return NextResponse.next()
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|api/health).*)',
  ],
}
