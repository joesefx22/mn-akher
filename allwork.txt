
// lib/constants/index.ts
export const SLOT_STATUS = {
  AVAILABLE: 'AVAILABLE',
  TEMP_LOCKED: 'TEMP_LOCKED',
  BOOKED: 'BOOKED',
  UNAVAILABLE: 'UNAVAILABLE'
} as const

export const BOOKING_STATUS = {
  CONFIRMED: 'CONFIRMED',
  PENDING_CONFIRMATION: 'PENDING_CONFIRMATION',
  CANCELLED: 'CANCELLED',
  DRAFT: 'DRAFT',
  FAILED: 'FAILED',
  EXPIRED: 'EXPIRED'
} as const

export const FIELD_STATUS = {
  OPEN: 'OPEN',
  CLOSED: 'CLOSED',
  MAINTENANCE: 'MAINTENANCE'
} as const

export const FIELD_TYPES = {
  FOOTBALL: 'FOOTBALL',
  PADEL: 'PADEL',
  TENNIS: 'TENNIS',
  BASKETBALL: 'BASKETBALL'
} as const

export const PAYMENT_STATUS = {
  PENDING: 'PENDING',
  PAID: 'PAID',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
} as const
2. Ø£Ù†ÙˆØ§Ø¹ TypeScript
typescript
// lib/types/index.ts
import { 
  SLOT_STATUS, 
  BOOKING_STATUS, 
  FIELD_STATUS, 
  FIELD_TYPES,
  PAYMENT_STATUS 
} from '@/lib/constants'

export type SlotStatus = typeof SLOT_STATUS[keyof typeof SLOT_STATUS]
export type BookingStatus = typeof BOOKING_STATUS[keyof typeof BOOKING_STATUS]
export type FieldStatus = typeof FIELD_STATUS[keyof typeof FIELD_STATUS]
export type FieldType = typeof FIELD_TYPES[keyof typeof FIELD_TYPES]
export type PaymentStatus = typeof PAYMENT_STATUS[keyof typeof PAYMENT_STATUS]

export interface User {
  id: string
  email: string
  name: string
  phone?: string
  avatar?: string
  createdAt: Date
}

export interface Field {
  id: string
  name: string
  description: string
  location: string
  address: string
  pricePerHour: number
  depositPrice: number
  imageUrl: string
  gallery: string[]
  type: FieldType
  status: FieldStatus
  openingTime: string // "08:00"
  closingTime: string // "22:00"
  slotDurationMin: number
  facilities: string[]
  rules: string[]
  rating: number
  reviewCount: number
  createdAt: Date
}

export interface Slot {
  id: string
  fieldId: string
  startTime: Date
  endTime: Date
  status: SlotStatus
  price: number
  deposit: number
  lockedUntil?: Date
  lockedByUserId?: string
}

export interface Booking {
  id: string
  userId: string
  fieldId: string
  slotId: string
  status: BookingStatus
  paymentStatus: PaymentStatus
  totalAmount: number
  depositPaid: number
  refundableUntil?: Date
  cancellationReason?: string
  createdAt: Date
  updatedAt: Date
  field?: Field
  slot?: Slot
  user?: User
}

export interface Payment {
  id: string
  bookingId: string
  amount: number
  currency: string
  paymentId: string
  orderId: string
  status: PaymentStatus
  metadata?: Record<string, any>
  createdAt: Date
}
3. Ù…Ù†Ø·Ù‚ Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯ (Time Slots Logic)
typescript
// lib/time-slots/core-logic.ts
import { addMinutes, startOfDay, addDays, isSameDay } from 'date-fns'

export const SLOT_DURATION = 60 // Ø¯Ù‚Ø§Ø¦Ù‚
export const LOCK_DURATION_MINUTES = 5
export const CONFIRMATION_WINDOW_HOURS = 24

export interface Day {
  date: Date
  label: string
  weekday: string
  dayNumber: string
  monthName: string
  isToday: boolean
  isTomorrow: boolean
  isWeekend: boolean
}

export function generateNextDays(count: number = 14): Day[] {
  const days: Day[] = []
  const today = startOfDay(new Date())

  for (let i = 0; i < count; i++) {
    const date = addDays(today, i)
    const weekday = date.toLocaleDateString('ar-EG', { weekday: 'long' })
    const dayNumber = date.toLocaleDateString('ar-EG', { day: 'numeric' })
    const monthName = date.toLocaleDateString('ar-EG', { month: 'long' })
    const dayOfWeek = date.getDay()

    days.push({
      date,
      label: `${weekday}ØŒ ${dayNumber} ${monthName}`,
      weekday,
      dayNumber,
      monthName,
      isToday: i === 0,
      isTomorrow: i === 1,
      isWeekend: dayOfWeek === 5 || dayOfWeek === 6 // Ø§Ù„Ø¬Ù…Ø¹Ø© ÙˆØ§Ù„Ø³Ø¨Øª
    })
  }

  return days
}

export function generateTimeSlots(
  startTime: string,
  endTime: string,
  date: Date,
  existingSlots: Slot[] = []
): Slot[] {
  const slots: Slot[] = []
  const [startHour, startMinute] = startTime.split(':').map(Number)
  const [endHour, endMinute] = endTime.split(':').map(Number)
  
  let current = new Date(date)
  current.setHours(startHour, startMinute, 0, 0)
  
  const end = new Date(date)
  end.setHours(endHour, endMinute, 0, 0)
  
  while (addMinutes(current, SLOT_DURATION) <= end) {
    const slotStart = new Date(current)
    const slotEnd = addMinutes(slotStart, SLOT_DURATION)
    
    const existingSlot = existingSlots.find(slot =>
      isSameDay(new Date(slot.startTime), date) &&
      new Date(slot.startTime).getHours() === slotStart.getHours() &&
      new Date(slot.startTime).getMinutes() === slotStart.getMinutes()
    )
    
    slots.push({
      id: existingSlot?.id || `slot-${date.toISOString()}-${slotStart.getTime()}`,
      startTime: slotStart,
      endTime: slotEnd,
      status: existingSlot?.status || 'AVAILABLE',
      price: 0, // Ø³ÙŠØªÙ… ØªØ¹Ø¨Ø¦ØªÙ‡ Ù…Ù† Field
      deposit: 0,
      ...existingSlot
    })
    
    current = slotEnd
  }
  
  return slots
}

export function canBookDirectly(startTime: Date): boolean {
  const now = new Date()
  const diffHours = (startTime.getTime() - now.getTime()) / (1000 * 60 * 60)
  return diffHours >= CONFIRMATION_WINDOW_HOURS
}
4. Ù…ÙƒÙˆÙ† Day Selector Ù…Ø­Ø³Ù†
tsx
// components/booking/day-selector.tsx
'use client'

import { ChevronRight, ChevronLeft } from 'lucide-react'
import { Day } from '@/lib/time-slots/core-logic'

interface DaySelectorProps {
  days: Day[]
  selectedDate: Date | null
  onSelectDate: (date: Date) => void
}

export default function DaySelector({ days, selectedDate, onSelectDate }: DaySelectorProps) {
  const scroll = (direction: 'left' | 'right') => {
    const container = document.getElementById('days-container')
    if (container) {
      const scrollAmount = direction === 'left' ? -300 : 300
      container.scrollBy({ left: scrollAmount, behavior: 'smooth' })
    }
  }

  return (
    <div className="mb-12">
      <div className="flex items-center justify-between mb-6">
        <div>
          <h2 className="text-2xl font-bold text-gray-900">Ø§Ø®ØªØ± Ø§Ù„ØªØ§Ø±ÙŠØ®</h2>
          <p className="text-gray-600 mt-1">Ø­Ø¯Ø¯ Ø§Ù„ÙŠÙˆÙ… Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„Ø­Ø¬Ø²Ùƒ</p>
        </div>
        <div className="flex gap-2">
          <button
            onClick={() => scroll('left')}
            className="p-3 rounded-xl bg-gray-100 hover:bg-gray-200 transition-colors"
            aria-label="Scroll left"
          >
            <ChevronLeft className="w-5 h-5 text-gray-700" />
          </button>
          <button
            onClick={() => scroll('right')}
            className="p-3 rounded-xl bg-gray-100 hover:bg-gray-200 transition-colors"
            aria-label="Scroll right"
          >
            <ChevronRight className="w-5 h-5 text-gray-700" />
          </button>
        </div>
      </div>

      <div className="relative">
        <div
          id="days-container"
          className="flex gap-4 overflow-x-auto pb-6 scrollbar-hide"
        >
          {days.map((day) => {
            const isSelected = selectedDate?.toDateString() === day.date.toDateString()
            
            return (
              <button
                key={day.date.toISOString()}
                onClick={() => onSelectDate(day.date)}
                className={`
                  flex-shrink-0 w-36 h-36 rounded-2xl p-5 text-center transition-all duration-300
                  border-2 hover:border-primary-500 hover:shadow-lg
                  ${isSelected
                    ? 'bg-gradient-to-br from-primary-500 to-primary-600 border-primary-500 text-white shadow-xl scale-105'
                    : 'bg-white border-gray-200 text-gray-700 hover:shadow-lg'
                  }
                  ${day.isWeekend ? 'bg-gradient-to-br from-amber-50 to-amber-100 border-amber-200' : ''}
                `}
              >
                <div className="text-sm font-medium mb-1">
                  {day.isToday ? 'Ø§Ù„ÙŠÙˆÙ…' : day.isTomorrow ? 'ØºØ¯Ø§Ù‹' : day.weekday}
                </div>
                <div className="text-3xl font-bold mb-2">{day.dayNumber}</div>
                <div className="text-sm mb-3">{day.monthName}</div>
                
                {day.isWeekend && !isSelected && (
                  <div className="inline-block px-3 py-1 bg-amber-100 text-amber-800 rounded-full text-xs font-medium">
                    Ø¹Ø·Ù„Ø© Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹
                  </div>
                )}
                
                {isSelected && (
                  <div className="mt-2">
                    <div className="w-8 h-1 bg-white/30 rounded-full mx-auto"></div>
                  </div>
                )}
              </button>
            )
          })}
        </div>
        
        {/* Gradient overlays for scroll indication */}
        <div className="absolute left-0 top-0 bottom-6 w-12 bg-gradient-to-r from-white to-transparent pointer-events-none"></div>
        <div className="absolute right-0 top-0 bottom-6 w-12 bg-gradient-to-l from-white to-transparent pointer-events-none"></div>
      </div>
    </div>
  )
}
5. Ù…ÙƒÙˆÙ† Field Card ÙØ§Ø®Ø±
tsx
// components/fields/field-card.tsx
'use client'

import { MapPin, Star, Users, Clock, ArrowLeft } from 'lucide-react'
import { Field } from '@/lib/types'
import { useState } from 'react'

interface FieldCardProps {
  field: Field
  onBook: (fieldId: string) => void
}

export default function FieldCard({ field, onBook }: FieldCardProps) {
  const [imageError, setImageError] = useState(false)

  const getFieldTypeIcon = (type: string) => {
    switch (type) {
      case 'FOOTBALL': return 'âš½'
      case 'PADEL': return 'ğŸ¾'
      case 'TENNIS': return 'ğŸ¯'
      case 'BASKETBALL': return 'ğŸ€'
      default: return 'ğŸŸï¸'
    }
  }

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'OPEN': return 'bg-green-100 text-green-800'
      case 'CLOSED': return 'bg-red-100 text-red-800'
      case 'MAINTENANCE': return 'bg-yellow-100 text-yellow-800'
      default: return 'bg-gray-100 text-gray-800'
    }
  }

  return (
    <div className="group relative bg-white rounded-2xl shadow-lg hover:shadow-2xl transition-all duration-300 overflow-hidden border border-gray-100">
      {/* Status Badge */}
      <div className="absolute top-4 left-4 z-10">
        <span className={`px-3 py-1 rounded-full text-xs font-bold ${getStatusColor(field.status)}`}>
          {field.status === 'OPEN' ? 'Ù…ÙØªÙˆØ­' : field.status === 'CLOSED' ? 'Ù…ØºÙ„Ù‚' : 'ØµÙŠØ§Ù†Ø©'}
        </span>
      </div>

      {/* Type Badge */}
      <div className="absolute top-4 right-4 z-10">
        <span className="px-3 py-1 bg-black/80 text-white rounded-full text-xs font-bold backdrop-blur-sm">
          {getFieldTypeIcon(field.type)} {field.type === 'FOOTBALL' ? 'ÙƒØ±Ø© Ù‚Ø¯Ù…' : 'Ø¨Ø§Ø¯Ù„'}
        </span>
      </div>

      {/* Image */}
      <div className="relative h-48 overflow-hidden">
        {!imageError ? (
          <img
            src={field.imageUrl}
            alt={field.name}
            className="w-full h-full object-cover group-hover:scale-105 transition-transform duration-500"
            onError={() => setImageError(true)}
          />
        ) : (
          <div className="w-full h-full bg-gradient-to-br from-primary-500/20 to-primary-600/20 flex items-center justify-center">
            <div className="text-4xl">{getFieldTypeIcon(field.type)}</div>
          </div>
        )}
        
        {/* Gradient Overlay */}
        <div className="absolute inset-0 bg-gradient-to-t from-black/50 to-transparent"></div>
        
        {/* Price */}
        <div className="absolute bottom-4 left-4">
          <div className="flex items-center gap-2">
            <span className="text-2xl font-bold text-white">{field.pricePerHour}</span>
            <span className="text-white/80">Ø¬.Ù…/Ø³Ø§Ø¹Ø©</span>
          </div>
        </div>
      </div>

      {/* Content */}
      <div className="p-6">
        <div className="flex items-start justify-between mb-4">
          <div className="flex-1">
            <h3 className="text-xl font-bold text-gray-900 mb-2 line-clamp-1">{field.name}</h3>
            <div className="flex items-center gap-2 text-gray-600 mb-3">
              <MapPin className="w-4 h-4" />
              <span className="text-sm">{field.location}</span>
            </div>
          </div>
          
          {/* Rating */}
          <div className="flex items-center gap-1 bg-gray-50 px-3 py-1 rounded-full">
            <Star className="w-4 h-4 fill-amber-400 text-amber-400" />
            <span className="font-bold text-gray-900">{field.rating}</span>
            <span className="text-gray-500 text-sm">({field.reviewCount})</span>
          </div>
        </div>

        {/* Description */}
        <p className="text-gray-600 text-sm mb-4 line-clamp-2">{field.description}</p>

        {/* Facilities */}
        {field.facilities && field.facilities.length > 0 && (
          <div className="flex flex-wrap gap-2 mb-4">
            {field.facilities.slice(0, 3).map((facility, index) => (
              <span key={index} className="px-3 py-1 bg-gray-100 text-gray-700 rounded-full text-xs">
                {facility}
              </span>
            ))}
            {field.facilities.length > 3 && (
              <span className="px-3 py-1 bg-gray-100 text-gray-700 rounded-full text-xs">
                +{field.facilities.length - 3}
              </span>
            )}
          </div>
        )}

        {/* Info Grid */}
        <div className="grid grid-cols-2 gap-3 mb-6">
          <div className="flex items-center gap-2 text-gray-700">
            <Clock className="w-4 h-4 text-gray-400" />
            <span className="text-sm">{field.openingTime} - {field.closingTime}</span>
          </div>
          <div className="flex items-center gap-2 text-gray-700">
            <Users className="w-4 h-4 text-gray-400" />
            <span className="text-sm">Ø¹Ø±Ø¨ÙˆÙ† {field.depositPrice} Ø¬.Ù…</span>
          </div>
        </div>

        {/* Action Button */}
        <button
          onClick={() => onBook(field.id)}
          disabled={field.status !== 'OPEN'}
          className={`
            w-full py-3 rounded-xl font-bold transition-all duration-300 flex items-center justify-center gap-2
            ${field.status === 'OPEN'
              ? 'bg-gradient-to-r from-primary-500 to-primary-600 hover:from-primary-600 hover:to-primary-700 text-white hover:shadow-lg'
              : 'bg-gray-100 text-gray-500 cursor-not-allowed'
            }
          `}
        >
          {field.status === 'OPEN' ? (
            <>
              Ø§Ø­Ø¬Ø² Ø§Ù„Ø¢Ù†
              <ArrowLeft className="w-4 h-4" />
            </>
          ) : (
            'ØºÙŠØ± Ù…ØªØ§Ø­ Ù„Ù„Ø­Ø¬Ø²'
          )}
        </button>
      </div>
    </div>
  )
}
6. Ù…ÙƒÙˆÙ† Slot Grid Ù…Ø­Ø³Ù†
tsx
// components/booking/slot-grid.tsx
'use client'

import { useState } from 'react'
import { Clock, Lock, CheckCircle, AlertCircle } from 'lucide-react'
import SlotBookingModal from './slot-booking-modal'
import { UISlot } from '@/components/booking/slots-mapper'

interface SlotGridProps {
  slots: UISlot[]
  fieldId: string
  fieldName: string
  onSlotSelect?: (slot: UISlot) => void
}

export default function SlotGrid({ slots, fieldId, fieldName, onSlotSelect }: SlotGridProps) {
  const [selectedSlot, setSelectedSlot] = useState<UISlot | null>(null)

  const handleSlotClick = (slot: UISlot) => {
    if (slot.uiStatus === 'AVAILABLE') {
      setSelectedSlot(slot)
      if (onSlotSelect) {
        onSlotSelect(slot)
      }
    }
  }

  const getSlotVariant = (slot: UISlot) => {
    switch (slot.uiStatus) {
      case 'AVAILABLE':
        return {
          bg: 'bg-gradient-to-br from-green-50 to-green-100',
          border: 'border-green-200',
          text: 'text-green-800',
          hover: 'hover:from-green-100 hover:to-green-200 hover:border-green-300 hover:shadow-md',
          icon: <Clock className="w-4 h-4" />,
          label: 'Ù…ØªØ§Ø­'
        }
      case 'LOCKED_ME':
        return {
          bg: 'bg-gradient-to-br from-blue-50 to-blue-100',
          border: 'border-blue-200',
          text: 'text-blue-800',
          hover: 'hover:from-blue-100 hover:to-blue-200 hover:border-blue-300',
          icon: <Lock className="w-4 h-4" />,
          label: 'Ù…Ù‚ÙÙˆÙ„ Ù„Ùƒ'
        }
      case 'LOCKED_OTHER':
        return {
          bg: 'bg-gradient-to-br from-gray-100 to-gray-200',
          border: 'border-gray-300',
          text: 'text-gray-600',
          hover: '',
          icon: <Lock className="w-4 h-4" />,
          label: 'Ù…Ø­Ø¬ÙˆØ²'
        }
      case 'BOOKED':
        return {
          bg: 'bg-gradient-to-br from-red-50 to-red-100',
          border: 'border-red-200',
          text: 'text-red-600',
          hover: '',
          icon: <CheckCircle className="w-4 h-4" />,
          label: 'Ù…Ø­Ø¬ÙˆØ²'
        }
      default:
        return {
          bg: 'bg-gray-100',
          border: 'border-gray-300',
          text: 'text-gray-500',
          hover: '',
          icon: null,
          label: 'ØºÙŠØ± Ù…ØªØ§Ø­'
        }
    }
  }

  // ØªØµÙÙŠØ© Ø§Ù„Ø³Ø§Ø¹Ø§Øª Ø­Ø³Ø¨ Ø­Ø§Ù„Ø© Ø§Ù„ÙŠÙˆÙ…
  const morningSlots = slots.filter(slot => 
    new Date(slot.startTime).getHours() < 12
  )
  const afternoonSlots = slots.filter(slot => 
    new Date(slot.startTime).getHours() >= 12 && 
    new Date(slot.startTime).getHours() < 17
  )
  const eveningSlots = slots.filter(slot => 
    new Date(slot.startTime).getHours() >= 17
  )

  const renderTimeSlot = (slot: UISlot) => {
    const variant = getSlotVariant(slot)
    const isAvailable = slot.uiStatus === 'AVAILABLE'
    const timeString = new Date(slot.startTime).toLocaleTimeString('ar-EG', {
      hour: '2-digit',
      minute: '2-digit',
      hour12: true
    })

    return (
      <button
        key={slot.id}
        onClick={() => handleSlotClick(slot)}
        disabled={!isAvailable}
        className={`
          relative flex flex-col items-center justify-center p-4 rounded-xl
          ${variant.bg} ${variant.border} border ${variant.text}
          transition-all duration-200 ${variant.hover}
          disabled:opacity-50 disabled:cursor-not-allowed
          group
        `}
      >
        <div className="flex items-center gap-2 mb-2">
          {variant.icon}
          <span className="font-bold">{timeString}</span>
        </div>
        
        <div className="text-sm font-medium mb-1">{variant.label}</div>
        
        {slot.metadata?.needsConfirmation && (
          <div className="absolute -top-2 -right-2">
            <div className="bg-amber-500 text-white text-xs px-2 py-1 rounded-full flex items-center gap-1">
              <AlertCircle className="w-3 h-3" />
              <span>ØªØ£ÙƒÙŠØ¯</span>
            </div>
          </div>
        )}
        
        {isAvailable && (
          <div className="mt-2">
            <div className="text-lg font-bold">{slot.price} Ø¬.Ù…</div>
            <div className="text-xs opacity-75">Ø¹Ø±Ø¨ÙˆÙ† {slot.deposit} Ø¬.Ù…</div>
          </div>
        )}
        
        {/* Hover Effect */}
        {isAvailable && (
          <div className="absolute inset-0 bg-gradient-to-br from-primary-500/10 to-transparent opacity-0 group-hover:opacity-100 rounded-xl transition-opacity"></div>
        )}
      </button>
    )
  }

  return (
    <div className="space-y-8">
      {/* Morning Slots */}
      {morningSlots.length > 0 && (
        <div>
          <h4 className="text-lg font-bold text-gray-900 mb-4 flex items-center gap-2">
            <div className="w-2 h-2 bg-amber-500 rounded-full"></div>
            ÙØªØ±Ø© Ø§Ù„ØµØ¨Ø§Ø­
          </h4>
          <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-3">
            {morningSlots.map(renderTimeSlot)}
          </div>
        </div>
      )}

      {/* Afternoon Slots */}
      {afternoonSlots.length > 0 && (
        <div>
          <h4 className="text-lg font-bold text-gray-900 mb-4 flex items-center gap-2">
            <div className="w-2 h-2 bg-orange-500 rounded-full"></div>
            ÙØªØ±Ø© Ø§Ù„Ø¸Ù‡ÙŠØ±Ø©
          </h4>
          <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-3">
            {afternoonSlots.map(renderTimeSlot)}
          </div>
        </div>
      )}

      {/* Evening Slots */}
      {eveningSlots.length > 0 && (
        <div>
          <h4 className="text-lg font-bold text-gray-900 mb-4 flex items-center gap-2">
            <div className="w-2 h-2 bg-purple-500 rounded-full"></div>
            ÙØªØ±Ø© Ø§Ù„Ù…Ø³Ø§Ø¡
          </h4>
          <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-3">
            {eveningSlots.map(renderTimeSlot)}
          </div>
        </div>
      )}

      {/* No Slots Message */}
      {slots.length === 0 && (
        <div className="text-center py-12 bg-gradient-to-br from-gray-50 to-gray-100 rounded-2xl">
          <Clock className="w-16 h-16 text-gray-400 mx-auto mb-4" />
          <h3 className="text-xl font-semibold text-gray-700 mb-2">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…ÙˆØ§Ø¹ÙŠØ¯ Ù…ØªØ§Ø­Ø©</h3>
          <p className="text-gray-500">Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯ Ù…Ø­Ø¬ÙˆØ²Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„ÙŠÙˆÙ…</p>
        </div>
      )}

      {/* Booking Modal */}
      {selectedSlot && (
        <SlotBookingModal
          slot={selectedSlot}
          fieldId={fieldId}
          fieldName={fieldName}
          onClose={() => setSelectedSlot(null)}
        />
      )}
    </div>
  )
}
7. Ù…ÙƒÙˆÙ† Slot Booking Modal Ù…Ø­Ø³Ù†
tsx
// components/booking/slot-booking-modal.tsx
'use client'

import { X, Clock, MapPin, CreditCard, Shield, AlertCircle, Loader2 } from 'lucide-react'
import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { useSession } from 'next-auth/react'
import { UISlot } from '@/components/booking/slots-mapper'
import { IdempotencyGuard } from '@/lib/idempotency/idempotency-guard'

interface SlotBookingModalProps {
  slot: UISlot
  fieldId: string
  fieldName: string
  onClose: () => void
}

export default function SlotBookingModal({ slot, fieldId, fieldName, onClose }: SlotBookingModalProps) {
  const { data: session } = useSession()
  const router = useRouter()
  const [isBooking, setIsBooking] = useState(false)
  const [step, setStep] = useState(1) // 1: Confirm, 2: Processing, 3: Success/Error

  const handleBook = async () => {
    if (!session) {
      router.push('/login')
      return
    }

    setIsBooking(true)
    setStep(2)

    try {
      // ØªÙˆÙ„ÙŠØ¯ Ù…ÙØªØ§Ø­ idempotency Ø¢Ù…Ù†
      const idempotencyKey = IdempotencyGuard.generateKey('booking')

      // 1. Ù‚ÙÙ„ Ø§Ù„Ù€ Slot
      const lockResponse = await fetch(`/api/fields/${fieldId}/slots/${slot.id}/lock`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      })

      if (!lockResponse.ok) {
        const err = await lockResponse.json()
        throw new Error(err.error || 'ÙØ´Ù„ ÙÙŠ Ù‚ÙÙ„ Ø§Ù„Ù…ÙˆØ¹Ø¯')
      }

      // 2. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø¬Ø²
      const response = await fetch('/api/bookings', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          slotId: slot.id,
          fieldId,
          startTime: slot.startTime,
          idempotencyKey
        })
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­Ø¬Ø²')
      }

      setStep(3)
      
      setTimeout(() => {
        if (slot.metadata?.needsConfirmation) {
          router.push('/bookings?status=pending')
        } else {
          router.push(`/payment?bookingId=${data.bookingId}`)
        }
        onClose()
      }, 1500)

    } catch (error: any) {
      console.error('Booking error:', error)
      alert(error.message || 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­Ø¬Ø²')
      setStep(1)
    } finally {
      setIsBooking(false)
    }
  }

  const formatDate = (date: Date) => {
    return date.toLocaleDateString('ar-EG', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    })
  }

  const formatTime = (date: Date) => {
    return date.toLocaleTimeString('ar-EG', {
      hour: '2-digit',
      minute: '2-digit',
      hour12: true
    })
  }

  const getStepContent = () => {
    switch (step) {
      case 1:
        return (
          <>
            {/* Header */}
            <div className="flex items-center justify-between p-6 border-b border-gray-100">
              <div>
                <h3 className="text-xl font-bold text-gray-900">ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø¬Ø²</h3>
                <p className="text-gray-600 text-sm mt-1">Ø§Ù„Ø±Ø¬Ø§Ø¡ Ù…Ø±Ø§Ø¬Ø¹Ø© ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø­Ø¬Ø²</p>
              </div>
              <button
                onClick={onClose}
                className="p-2 hover:bg-gray-100 rounded-xl transition-colors"
              >
                <X className="w-5 h-5 text-gray-500" />
              </button>
            </div>

            {/* Content */}
            <div className="p-6">
              <div className="mb-6">
                <h4 className="font-bold text-lg text-gray-900 mb-2">{fieldName}</h4>
                <p className="text-gray-600">Ù…Ù„Ø¹Ø¨ ÙƒØ±Ø© Ù‚Ø¯Ù… Ø§Ø­ØªØ±Ø§ÙÙŠ</p>
              </div>

              <div className="space-y-4">
                <div className="flex items-center gap-3 p-3 bg-gray-50 rounded-xl">
                  <Clock className="w-5 h-5 text-primary-500" />
                  <div>
                    <div className="font-medium text-gray-900">{formatDate(slot.startTime)}</div>
                    <div className="text-gray-600 text-sm">
                      Ù…Ù† {formatTime(slot.startTime)} Ø¥Ù„Ù‰ {formatTime(slot.endTime)}
                    </div>
                  </div>
                </div>

                <div className="flex items-center gap-3 p-3 bg-gray-50 rounded-xl">
                  <MapPin className="w-5 h-5 text-primary-500" />
                  <div>
                    <div className="font-medium text-gray-900">Ø§Ù„Ù…ÙˆÙ‚Ø¹</div>
                    <div className="text-gray-600 text-sm">Ù…Ø¯ÙŠÙ†Ø© Ù†ØµØ±ØŒ Ø§Ù„Ù‚Ø§Ù‡Ø±Ø©</div>
                  </div>
                </div>

                <div className="flex items-center gap-3 p-3 bg-gray-50 rounded-xl">
                  <CreditCard className="w-5 h-5 text-primary-500" />
                  <div className="flex-1">
                    <div className="font-medium text-gray-900">Ø§Ù„Ø³Ø¹Ø±</div>
                    <div className="flex justify-between items-center">
                      <div>
                        <span className="text-2xl font-bold text-gray-900">{slot.price}</span>
                        <span className="text-gray-600 mr-2">Ø¬.Ù…</span>
                      </div>
                      <div className="text-sm text-gray-600">
                        Ø¹Ø±Ø¨ÙˆÙ†: {slot.deposit} Ø¬.Ù…
                      </div>
                    </div>
                  </div>
                </div>

                {slot.metadata?.needsConfirmation && (
                  <div className="p-3 bg-amber-50 border border-amber-200 rounded-xl">
                    <div className="flex items-start gap-2">
                      <AlertCircle className="w-5 h-5 text-amber-600 mt-0.5" />
                      <div>
                        <div className="font-medium text-amber-800">ÙŠØ­ØªØ§Ø¬ ØªØ£ÙƒÙŠØ¯</div>
                        <p className="text-amber-700 text-sm mt-1">
                          Ù‡Ø°Ø§ Ø§Ù„Ù…ÙˆØ¹Ø¯ ÙŠØ­ØªØ§Ø¬ ØªØ£ÙƒÙŠØ¯ Ù…Ù† Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù„Ø¹Ø¨. Ø³ÙŠØªÙ… Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ Ø®Ù„Ø§Ù„ 24 Ø³Ø§Ø¹Ø©.
                        </p>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </div>

            {/* Footer */}
            <div className="p-6 border-t border-gray-100">
              <div className="flex gap-3">
                <button
                  onClick={onClose}
                  className="flex-1 py-3 px-4 border border-gray-300 text-gray-700 rounded-xl font-medium hover:bg-gray-50 transition-colors"
                >
                  Ø¥Ù„ØºØ§Ø¡
                </button>
                <button
                  onClick={handleBook}
                  disabled={isBooking}
                  className="flex-1 py-3 px-4 rounded-xl font-bold text-white bg-gradient-to-r from-primary-500 to-primary-600 hover:from-primary-600 hover:to-primary-700 disabled:opacity-50 transition-all duration-300 flex items-center justify-center gap-2"
                >
                  {isBooking ? (
                    <>
                      <Loader2 className="w-5 h-5 animate-spin" />
                      Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­Ø¬Ø²...
                    </>
                  ) : (
                    'ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø¬Ø²'
                  )}
                </button>
              </div>
              
              <div className="flex items-center justify-center gap-2 mt-4 text-sm text-gray-500">
                <Shield className="w-4 h-4" />
                <span>Ø¬Ù…ÙŠØ¹ Ø¨ÙŠØ§Ù†Ø§ØªÙƒ Ù…Ø­Ù…ÙŠØ© ÙˆØ¢Ù…Ù†Ø©</span>
              </div>
            </div>
          </>
        )
      
      case 2:
        return (
          <div className="p-8 text-center">
            <div className="relative w-20 h-20 mx-auto mb-6">
              <Loader2 className="w-20 h-20 text-primary-500 animate-spin" />
              <div className="absolute inset-0 flex items-center justify-center">
                <div className="w-8 h-8 bg-primary-500 rounded-full animate-ping"></div>
              </div>
            </div>
            <h3 className="text-xl font-bold text-gray-900 mb-2">Ø¬Ø§Ø±ÙŠ ØªØ£ÙƒÙŠØ¯ Ø­Ø¬Ø²Ùƒ</h3>
            <p className="text-gray-600">Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø¨ÙŠÙ†Ù…Ø§ Ù†Ù‚ÙˆÙ… Ø¨ØªØ£Ù…ÙŠÙ† Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù„Ùƒ</p>
          </div>
        )
      
      case 3:
        return (
          <div className="p-8 text-center">
            <div className="w-20 h-20 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-6">
              <div className="w-12 h-12 bg-green-500 rounded-full flex items-center justify-center">
                <CheckCircle className="w-8 h-8 text-white" />
              </div>
            </div>
            <h3 className="text-xl font-bold text-gray-900 mb-2">ØªÙ… Ø­Ø¬Ø² Ø§Ù„Ù…ÙˆØ¹Ø¯ Ø¨Ù†Ø¬Ø§Ø­!</h3>
            <p className="text-gray-600 mb-6">Ø³ÙŠØªÙ… ØªÙˆØ¬ÙŠÙ‡Ùƒ Ø¥Ù„Ù‰ ØµÙØ­Ø© Ø§Ù„Ø¯ÙØ¹ Ø®Ù„Ø§Ù„ Ù„Ø­Ø¸Ø§Øª</p>
            <div className="w-12 h-1 bg-primary-500 rounded-full mx-auto animate-pulse"></div>
          </div>
        )
    }
  }

  return (
    <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4 backdrop-blur-sm">
      <div className="bg-white rounded-2xl max-w-md w-full shadow-2xl animate-in zoom-in-95">
        {getStepContent()}
      </div>
    </div>
  )
}
8. ØµÙØ­Ø© Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª (Ù…Ø­Ø³Ù†Ø©)
tsx
// app/(player)/bookings/page.tsx
'use client'

import { useState, useEffect } from 'react'
import { useSession } from 'next-auth/react'
import { 
  Calendar, 
  Clock, 
  MapPin, 
  AlertCircle,
  CheckCircle,
  XCircle,
  Filter,
  Download,
  Share2
} from 'lucide-react'
import { Booking } from '@/lib/types'

export default function MyBookingsPage() {
  const { data: session } = useSession()
  const [bookings, setBookings] = useState<Booking[]>([])
  const [filteredBookings, setFilteredBookings] = useState<Booking[]>([])
  const [loading, setLoading] = useState(true)
  const [statusFilter, setStatusFilter] = useState<string>('all')
  const [selectedDate, setSelectedDate] = useState<string>('all')

  useEffect(() => {
    fetchBookings()
  }, [])

  useEffect(() => {
    let filtered = bookings
    
    if (statusFilter !== 'all') {
      filtered = filtered.filter(booking => booking.status === statusFilter)
    }
    
    if (selectedDate !== 'all') {
      const today = new Date()
      const tomorrow = new Date(today)
      tomorrow.setDate(tomorrow.getDate() + 1)
      
      if (selectedDate === 'today') {
        filtered = filtered.filter(booking => 
          new Date(booking.slot!.startTime).toDateString() === today.toDateString()
        )
      } else if (selectedDate === 'tomorrow') {
        filtered = filtered.filter(booking => 
          new Date(booking.slot!.startTime).toDateString() === tomorrow.toDateString()
        )
      } else if (selectedDate === 'upcoming') {
        filtered = filtered.filter(booking => 
          new Date(booking.slot!.startTime) > today
        )
      } else if (selectedDate === 'past') {
        filtered = filtered.filter(booking => 
          new Date(booking.slot!.startTime) < today
        )
      }
    }
    
    setFilteredBookings(filtered)
  }, [bookings, statusFilter, selectedDate])

  const fetchBookings = async () => {
    try {
      const res = await fetch('/api/bookings/my-bookings')
      const data = await res.json()
      setBookings(data.bookings as Booking[])
      setFilteredBookings(data.bookings as Booking[])
    } catch (error) {
      console.error('Error fetching bookings:', error)
    } finally {
      setLoading(false)
    }
  }

  const handleCancelBooking = async (bookingId: string) => {
    if (!confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø­Ø¬Ø²ØŸ')) return
    
    try {
      const res = await fetch(`/api/bookings/${bookingId}/cancel`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ reason: 'Ø¥Ù„ØºØ§Ø¡ Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…' })
      })
      
      if (res.ok) {
        alert('ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø­Ø¬Ø² Ø¨Ù†Ø¬Ø§Ø­')
        fetchBookings()
      }
    } catch (error) {
      console.error('Error cancelling booking:', error)
    }
  }

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'CONFIRMED':
        return <CheckCircle className="w-5 h-5 text-green-500" />
      case 'PENDING_CONFIRMATION':
        return <AlertCircle className="w-5 h-5 text-amber-500" />
      case 'CANCELLED':
        return <XCircle className="w-5 h-5 text-red-500" />
      default:
        return null
    }
  }

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'CONFIRMED':
        return 'bg-green-100 text-green-800 border-green-200'
      case 'PENDING_CONFIRMATION':
        return 'bg-amber-100 text-amber-800 border-amber-200'
      case 'CANCELLED':
        return 'bg-red-100 text-red-800 border-red-200'
      default:
        return 'bg-gray-100 text-gray-800 border-gray-200'
    }
  }

  if (loading) {
    return (
      <div className="min-h-screen bg-gradient-to-b from-gray-50 to-gray-100">
        <div className="container mx-auto px-4 py-16 text-center">
          <div className="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-primary-500"></div>
          <p className="mt-4 text-gray-600">Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª...</p>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-gradient-to-b from-gray-50 to-gray-100">
      <div className="container mx-auto px-4 py-8">
        {/* Header */}
        <div className="mb-8">
          <h1 className="text-3xl font-bold text-gray-900 mb-2">Ø­Ø¬ÙˆØ²Ø§ØªÙŠ</h1>
          <p className="text-gray-600">Ø¥Ø¯Ø§Ø±Ø© ÙˆÙ…ØªØ§Ø¨Ø¹Ø© Ø¬Ù…ÙŠØ¹ Ø­Ø¬ÙˆØ²Ø§ØªÙƒ ÙÙŠ Ù…ÙƒØ§Ù† ÙˆØ§Ø­Ø¯</p>
        </div>

        {/* Stats */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
          <div className="bg-white rounded-2xl p-6 shadow-lg border border-gray-100">
            <div className="flex items-center justify-between">
              <div>
                <div className="text-2xl font-bold text-gray-900">{bookings.length}</div>
                <div className="text-gray-600">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª</div>
              </div>
              <div className="w-12 h-12 bg-primary-100 rounded-xl flex items-center justify-center">
                <Calendar className="w-6 h-6 text-primary-600" />
              </div>
            </div>
          </div>
          
          <div className="bg-white rounded-2xl p-6 shadow-lg border border-gray-100">
            <div className="flex items-center justify-between">
              <div>
                <div className="text-2xl font-bold text-gray-900">
                  {bookings.filter(b => b.status === 'CONFIRMED').length}
                </div>
                <div className="text-gray-600">Ø­Ø¬ÙˆØ²Ø§Øª Ù…Ø¤ÙƒØ¯Ø©</div>
              </div>
              <div className="w-12 h-12 bg-green-100 rounded-xl flex items-center justify-center">
                <CheckCircle className="w-6 h-6 text-green-600" />
              </div>
            </div>
          </div>
          
          <div className="bg-white rounded-2xl p-6 shadow-lg border border-gray-100">
            <div className="flex items-center justify-between">
              <div>
                <div className="text-2xl font-bold text-gray-900">
                  {bookings.filter(b => b.status === 'PENDING_CONFIRMATION').length}
                </div>
                <div className="text-gray-600">Ø¨Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„ØªØ£ÙƒÙŠØ¯</div>
              </div>
              <div className="w-12 h-12 bg-amber-100 rounded-xl flex items-center justify-center">
                <AlertCircle className="w-6 h-6 text-amber-600" />
              </div>
            </div>
          </div>
        </div>

        {/* Filters */}
        <div className="bg-white rounded-2xl shadow-lg p-6 mb-8">
          <div className="flex items-center justify-between mb-6">
            <div className="flex items-center gap-2">
              <Filter className="w-5 h-5 text-gray-500" />
              <h3 className="font-bold text-gray-900">ØªØµÙÙŠØ© Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª</h3>
            </div>
            
            <div className="flex gap-3">
              <button className="px-4 py-2 border border-gray-300 text-gray-700 rounded-xl hover:bg-gray-50 flex items-center gap-2">
                <Download className="w-4 h-4" />
                ØªØµØ¯ÙŠØ±
              </button>
              <button className="px-4 py-2 bg-gray-100 text-gray-700 rounded-xl hover:bg-gray-200 flex items-center gap-2">
                <Share2 className="w-4 h-4" />
                Ù…Ø´Ø§Ø±ÙƒØ©
              </button>
            </div>
          </div>
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø¬Ø²
              </label>
              <select
                value={statusFilter}
                onChange={(e) => setStatusFilter(e.target.value)}
                className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-primary-500 focus:border-transparent"
              >
                <option value="all">Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø§Ù„Ø§Øª</option>
                <option value="CONFIRMED">Ù…Ø¤ÙƒØ¯</option>
                <option value="PENDING_CONFIRMATION">Ø¨Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„ØªØ£ÙƒÙŠØ¯</option>
                <option value="CANCELLED">Ù…Ù„ØºÙ‰</option>
              </select>
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Ø§Ù„ØªØ§Ø±ÙŠØ®
              </label>
              <select
                value={selectedDate}
                onChange={(e) => setSelectedDate(e.target.value)}
                className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-primary-500 focus:border-transparent"
              >
                <option value="all">Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£ÙˆÙ‚Ø§Øª</option>
                <option value="today">Ø§Ù„ÙŠÙˆÙ…</option>
                <option value="tomorrow">ØºØ¯Ø§Ù‹</option>
                <option value="upcoming">Ù‚Ø§Ø¯Ù…Ø©</option>
                <option value="past">Ø³Ø§Ø¨Ù‚Ø©</option>
              </select>
            </div>
          </div>
        </div>

        {/* Bookings List */}
        {filteredBookings.length === 0 ? (
          <div className="text-center py-16 bg-white rounded-2xl shadow-lg">
            <Calendar className="w-16 h-16 text-gray-400 mx-auto mb-4" />
            <h3 className="text-xl font-semibold text-gray-700 mb-2">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø¬ÙˆØ²Ø§Øª</h3>
            <p className="text-gray-500 mb-6">Ù‚Ù… Ø¨Ø­Ø¬Ø² Ù…Ù„Ø¹Ø¨Ùƒ Ø§Ù„Ø£ÙˆÙ„ Ø§Ù„Ø¢Ù†!</p>
            <button
              onClick={() => window.location.href = '/fields'}
              className="px-6 py-3 bg-gradient-to-r from-primary-500 to-primary-600 text-white rounded-xl hover:from-primary-600 hover:to-primary-700"
            >
              Ø§Ø³ØªØ¹Ø±Ø¶ Ø§Ù„Ù…Ù„Ø§Ø¹Ø¨
            </button>
          </div>
        ) : (
          <div className="grid gap-6">
            {filteredBookings.map((booking) => (
              <div 
                key={booking.id}
                className="bg-white rounded-2xl shadow-lg p-6 border border-gray-100 hover:shadow-xl transition-shadow"
              >
                <div className="flex flex-col lg:flex-row lg:items-center justify-between gap-6">
                  {/* Booking Info */}
                  <div className="flex-1">
                    <div className="flex items-center gap-3 mb-4">
                      {getStatusIcon(booking.status)}
                      <span className={`px-3 py-1 rounded-full text-sm font-medium border ${getStatusColor(booking.status)}`}>
                        {booking.status === 'CONFIRMED' ? 'Ù…Ø¤ÙƒØ¯' :
                         booking.status === 'PENDING_CONFIRMATION' ? 'Ø¨Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„ØªØ£ÙƒÙŠØ¯' : 'Ù…Ù„ØºÙ‰'}
                      </span>
                      
                      {booking.status === 'PENDING_CONFIRMATION' && (
                        <div className="flex items-center gap-1 text-amber-600">
                          <AlertCircle className="w-4 h-4" />
                          <span className="text-sm">ÙŠØ­ØªØ§Ø¬ ØªØ£ÙƒÙŠØ¯ Ù…ÙˆØ¸Ù</span>
                        </div>
                      )}
                    </div>
                    
                    <h3 className="text-xl font-bold text-gray-900 mb-2">
                      {booking.field?.name}
                    </h3>
                    
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                      <div className="flex items-center gap-2">
                        <Calendar className="w-4 h-4 text-gray-400" />
                        <span className="text-gray-700">
                          {new Date(booking.slot!.startTime).toLocaleDateString('ar-EG')}
                        </span>
                      </div>
                      
                      <div className="flex items-center gap-2">
                        <Clock className="w-4 h-4 text-gray-400" />
                        <span className="text-gray-700">
                          {new Date(booking.slot!.startTime).toLocaleTimeString('ar-EG', {
                            hour: '2-digit',
                            minute: '2-digit'
                          })}
                        </span>
                      </div>
                      
                      <div className="flex items-center gap-2">
                        <MapPin className="w-4 h-4 text-gray-400" />
                        <span className="text-gray-700">{booking.field?.location}</span>
                      </div>
                    </div>
                    
                    {/* Payment Status */}
                    {booking.paymentStatus && (
                      <div className="inline-flex items-center gap-2 px-3 py-1 bg-gray-100 rounded-full">
                        <div className={`w-2 h-2 rounded-full ${
                          booking.paymentStatus === 'PAID' ? 'bg-green-500' :
                          booking.paymentStatus === 'PENDING' ? 'bg-amber-500' : 'bg-red-500'
                        }`}></div>
                        <span className="text-sm text-gray-700">
                          {booking.paymentStatus === 'PAID' ? 'ØªÙ… Ø§Ù„Ø¯ÙØ¹' :
                           booking.paymentStatus === 'PENDING' ? 'Ø¨Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø¯ÙØ¹' : 'ÙØ´Ù„ Ø§Ù„Ø¯ÙØ¹'}
                        </span>
                      </div>
                    )}
                  </div>
                  
                  {/* Actions */}
                  <div className="flex flex-col gap-3">
                    {booking.status === 'CONFIRMED' && (
                      <>
                        <button
                          onClick={() => handleCancelBooking(booking.id)}
                          className="px-4 py-2 bg-red-50 text-red-700 rounded-xl hover:bg-red-100 transition-colors"
                        >
                          Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø­Ø¬Ø²
                        </button>
                        <button
                          onClick={() => window.open(`/bookings/${booking.id}/invoice`, '_blank')}
                          className="px-4 py-2 bg-gray-100 text-gray-700 rounded-xl hover:bg-gray-200 transition-colors"
                        >
                          Ø¹Ø±Ø¶ Ø§Ù„ÙØ§ØªÙˆØ±Ø©
                        </button>
                      </>
                    )}
                    
                    {booking.status === 'PENDING_CONFIRMATION' && (
                      <button
                        onClick={() => handleCancelBooking(booking.id)}
                        className="px-4 py-2 bg-gray-100 text-gray-700 rounded-xl hover:bg-gray-200 transition-colors"
                      >
                        Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø·Ù„Ø¨
                      </button>
                    )}
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}
9. Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Tailwind CSS Ù„Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„ÙØ§Ø®Ø±
javascript
// tailwind.config.js
module.exports = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#fefce8',
          100: '#fef9c3',
          200: '#fef08a',
          300: '#fde047',
          400: '#facc15',
          500: '#eab308',
          600: '#ca8a04',
          700: '#a16207',
          800: '#854d0e',
          900: '#713f12',
        },
        secondary: {
          50: '#f8fafc',
          100: '#f1f5f9',
          200: '#e2e8f0',
          300: '#cbd5e1',
          400: '#94a3b8',
          500: '#64748b',
          600: '#475569',
          700: '#334155',
          800: '#1e293b',
          900: '#0f172a',
        }
      },
      fontFamily: {
        sans: ['var(--font-inter)', 'system-ui', 'sans-serif'],
        arabic: ['var(--font-cairo)', 'system-ui', 'sans-serif'],
      },
      animation: {
        'infinite-scroll': 'infinite-scroll 25s linear infinite',
        'gradient': 'gradient 8s linear infinite',
        'float': 'float 6s ease-in-out infinite',
        'pulse-slow': 'pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite',
      },
      keyframes: {
        'infinite-scroll': {
          from: { transform: 'translateX(0)' },
          to: { transform: 'translateX(-100%)' },
        },
        'gradient': {
          '0%, 100%': {
            'background-size': '200% 200%',
            'background-position': 'left center'
          },
          '50%': {
            'background-size': '200% 200%',
            'background-position': 'right center'
          },
        },
        'float': {
          '0%, 100%': { transform: 'translateY(0)' },
          '50%': { transform: 'translateY(-20px)' },
        }
      },
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic': 'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
        'gradient-premium': 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
        'gradient-gold': 'linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%)',
      },
      boxShadow: {
        'premium': '0 20px 60px rgba(0, 0, 0, 0.15)',
        'glow': '0 0 40px rgba(234, 179, 8, 0.3)',
      }
    },
  },
  plugins: [
    require('@tailwindcss/forms'),
    require('@tailwindcss/typography'),
    require('@tailwindcss/aspect-ratio'),
  ],
}
10. Ù…Ù„Ù Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø¹Ø§Ù…
css
/* app/globals.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
  }

  body {
    @apply font-sans text-gray-900 bg-gray-50;
    direction: rtl;
  }

  /* Custom scrollbar */
  ::-webkit-scrollbar {
    @apply w-2;
  }

  ::-webkit-scrollbar-track {
    @apply bg-gray-100;
  }

  ::-webkit-scrollbar-thumb {
    @apply bg-gray-400 rounded-full;
  }

  ::-webkit-scrollbar-thumb:hover {
    @apply bg-gray-500;
  }
}

@layer components {
  .glass-effect {
    @apply backdrop-blur-md bg-white/70 border border-white/20;
  }

  .gradient-text {
    @apply bg-gradient-to-r from-primary-500 to-primary-600 bg-clip-text text-transparent;
  }

  .gradient-border {
    @apply border border-transparent bg-gradient-to-r from-primary-500 to-primary-600 bg-origin-border;
  }

  .card-hover {
    @apply transition-all duration-300 hover:shadow-xl hover:-translate-y-1;
  }

  .btn-primary {
    @apply px-6 py-3 bg-gradient-to-r from-primary-500 to-primary-600 text-white font-medium rounded-xl 
           hover:from-primary-600 hover:to-primary-700 transition-all duration-300 
           focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2
           disabled:opacity-50 disabled:cursor-not-allowed;
  }

  .btn-secondary {
    @apply px-6 py-3 bg-white text-gray-700 font-medium rounded-xl border border-gray-300
           hover:bg-gray-50 transition-all duration-300 
           focus:outline-none focus:ring-2 focus:ring-gray-300 focus:ring-offset-2;
  }

  .input-field {
    @apply w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-primary-500 
           focus:border-transparent transition-all duration-200 outline-none;
  }

  .badge {
    @apply inline-flex items-center px-3 py-1 rounded-full text-xs font-medium;
  }

  .badge-success {
    @apply bg-green-100 text-green-800;
  }

  .badge-warning {
    @apply bg-amber-100 text-amber-800;
  }

  .badge-error {
    @apply bg-red-100 text-red-800;
  }

  .badge-info {
    @apply bg-blue-100 text-blue-800;
  }
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }

  .scrollbar-hide {
    -ms-overflow-style: none;
    scrollbar-width: none;
  }
  
  .scrollbar-hide::-webkit-scrollbar {
    display: none;
  }

  .line-clamp-1 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }

  .line-clamp-2 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
  }

  .line-clamp-3 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 3;
  }
}
11. Ù…Ù„Ù Layout Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
tsx
// app/layout.tsx
import type { Metadata } from 'next'
import { Inter, Cairo } from 'next/font/google'
import './globals.css'
import Navbar from '@/components/layout/navbar'
import Footer from '@/components/layout/footer'
import { Toaster } from 'react-hot-toast'
import Providers from '@/components/providers'

const inter = Inter({
  subsets: ['latin'],
  variable: '--font-inter',
})

const cairo = Cairo({
  subsets: ['arabic'],
  variable: '--font-cairo',
})

export const metadata: Metadata = {
  title: 'Elite Stadiums | Ù†Ø¸Ø§Ù… Ø­Ø¬Ø² Ø§Ù„Ù…Ù„Ø§Ø¹Ø¨ Ø§Ù„ÙØ§Ø®Ø±',
  description: 'Ù†Ø¸Ø§Ù… Ø­Ø¬Ø² Ù…Ù„Ø§Ø¹Ø¨ ÙƒØ±Ø© Ø§Ù„Ù‚Ø¯Ù… ÙˆØ§Ù„Ø¨Ø§Ø¯Ù„ Ø§Ù„ÙØ§Ø®Ø±. Ø§Ø­Ø¬Ø² Ù…Ù„Ø¹Ø¨Ùƒ Ø¨Ø³Ù‡ÙˆÙ„Ø© ÙˆØ£Ù…Ø§Ù†.',
  keywords: ['Ù…Ù„Ø§Ø¹Ø¨', 'Ø­Ø¬Ø²', 'ÙƒØ±Ø© Ù‚Ø¯Ù…', 'Ø¨Ø§Ø¯Ù„', 'Ø±ÙŠØ§Ø¶Ø©'],
  authors: [{ name: 'Elite Stadiums' }],
  openGraph: {
    type: 'website',
    locale: 'ar_EG',
    url: 'https://elitestadiums.com',
    title: 'Elite Stadiums',
    description: 'Ù†Ø¸Ø§Ù… Ø­Ø¬Ø² Ø§Ù„Ù…Ù„Ø§Ø¹Ø¨ Ø§Ù„ÙØ§Ø®Ø±',
    images: ['/og-image.jpg'],
  },
}

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  return (
    <html lang="ar" dir="rtl" className={`${inter.variable} ${cairo.variable}`}>
      <body className="min-h-screen bg-gradient-to-b from-gray-50 to-gray-100">
        <Providers>
          <div className="flex flex-col min-h-screen">
            <Navbar />
            <main className="flex-1">
              {children}
            </main>
            <Footer />
          </div>
          <Toaster 
            position="top-center"
            toastOptions={{
              duration: 4000,
              style: {
                background: '#1f2937',
                color: '#fff',
                borderRadius: '12px',
                padding: '16px',
                fontSize: '14px',
              },
              success: {
                iconTheme: {
                  primary: '#10b981',
                  secondary: '#fff',
                },
              },
              error: {
                iconTheme: {
                  primary: '#ef4444',
                  secondary: '#fff',
                },
              },
            }}
          />
        </Providers>
      </body>
    </html>
  )
}
12. Ù…ÙƒÙˆÙ† Navbar ÙØ§Ø®Ø±
tsx
// components/layout/navbar.tsx
'use client'

import { useState, useEffect } from 'react'
import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { useSession, signOut } from 'next-auth/react'
import { 
  Menu, 
  X, 
  User, 
  Bell, 
  Search, 
  Trophy,
  LogOut,
  Settings,
  ChevronDown
} from 'lucide-react'
import { motion, AnimatePresence } from 'framer-motion'

export default function Navbar() {
  const [isOpen, setIsOpen] = useState(false)
  const [isScrolled, setIsScrolled] = useState(false)
  const [userMenuOpen, setUserMenuOpen] = useState(false)
  const pathname = usePathname()
  const { data: session } = useSession()

  useEffect(() => {
    const handleScroll = () => {
      setIsScrolled(window.scrollY > 20)
    }
    window.addEventListener('scroll', handleScroll)
    return () => window.removeEventListener('scroll', handleScroll)
  }, [])

  const navItems = [
    { name: 'Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©', href: '/' },
    { name: 'Ø§Ù„Ù…Ù„Ø§Ø¹Ø¨', href: '/fields?type=football' },
    { name: 'Ø§Ù„Ø¨Ø·ÙˆÙ„Ø§Øª', href: '/tournaments' },
    { name: 'Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª', href: '/subscriptions' },
    { name: 'ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§', href: '/contact' },
  ]

  const userNavigation = [
    { name: 'Ø­Ø³Ø§Ø¨ÙŠ', href: '/profile', icon: User },
    { name: 'Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª', href: '/bookings', icon: Trophy },
    { name: 'Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª', href: '/notifications', icon: Bell },
    { name: 'Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª', href: '/settings', icon: Settings },
    { name: 'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬', href: '#', icon: LogOut, onClick: () => signOut() },
  ]

  return (
    <nav className={`fixed top-0 left-0 right-0 z-50 transition-all duration-300 ${
      isScrolled 
        ? 'bg-white/90 backdrop-blur-md shadow-lg py-3' 
        : 'bg-transparent py-5'
    }`}>
      <div className="container mx-auto px-4">
        <div className="flex items-center justify-between">
          {/* Logo */}
          <Link href="/" className="flex items-center gap-3">
            <div className="w-10 h-10 bg-gradient-to-br from-primary-500 to-primary-600 rounded-xl flex items-center justify-center">
              <Trophy className="w-6 h-6 text-white" />
            </div>
            <div className="hidden md:block">
              <div className="text-xl font-bold gradient-text">Elite Stadiums</div>
              <div className="text-xs text-gray-500">Ù†Ø¸Ø§Ù… Ø­Ø¬Ø² Ø§Ù„Ù…Ù„Ø§Ø¹Ø¨ Ø§Ù„ÙØ§Ø®Ø±</div>
            </div>
          </Link>

          {/* Desktop Navigation */}
          <div className="hidden lg:flex items-center gap-8">
            {navItems.map((item) => (
              <Link
                key={item.name}
                href={item.href}
                className={`relative font-medium transition-colors ${
                  pathname === item.href 
                    ? 'text-primary-600' 
                    : 'text-gray-700 hover:text-primary-600'
                }`}
              >
                {item.name}
                {pathname === item.href && (
                  <motion.div
                    layoutId="navbar-indicator"
                    className="absolute -bottom-1 left-0 right-0 h-0.5 bg-gradient-to-r from-primary-500 to-primary-600"
                  />
                )}
              </Link>
            ))}
          </div>

          {/* Right Section */}
          <div className="flex items-center gap-4">
            {/* Search */}
            <button className="p-2 hover:bg-gray-100 rounded-xl transition-colors">
              <Search className="w-5 h-5 text-gray-600" />
            </button>

            {/* Notifications */}
            <button className="p-2 hover:bg-gray-100 rounded-xl transition-colors relative">
              <Bell className="w-5 h-5 text-gray-600" />
              <span className="absolute -top-1 -right-1 w-2 h-2 bg-red-500 rounded-full"></span>
            </button>

            {/* User Menu */}
            {session ? (
              <div className="relative">
                <button
                  onClick={() => setUserMenuOpen(!userMenuOpen)}
                  className="flex items-center gap-3 p-2 hover:bg-gray-100 rounded-xl transition-colors"
                >
                  <div className="w-9 h-9 bg-gradient-to-br from-primary-500 to-primary-600 rounded-full flex items-center justify-center text-white font-bold">
                    {session.user?.name?.charAt(0) || 'U'}
                  </div>
                  <div className="hidden md:block text-right">
                    <div className="font-medium text-gray-900">{session.user?.name}</div>
                    <div className="text-xs text-gray-500">Ù„Ø§Ø¹Ø¨</div>
                  </div>
                  <ChevronDown className={`w-4 h-4 text-gray-500 transition-transform ${
                    userMenuOpen ? 'rotate-180' : ''
                  }`} />
                </button>

                <AnimatePresence>
                  {userMenuOpen && (
                    <motion.div
                      initial={{ opacity: 0, y: 10 }}
                      animate={{ opacity: 1, y: 0 }}
                      exit={{ opacity: 0, y: 10 }}
                      className="absolute left-0 mt-2 w-64 bg-white rounded-2xl shadow-xl border border-gray-100 py-2 z-50"
                    >
                      {userNavigation.map((item) => (
                        <Link
                          key={item.name}
                          href={item.href}
                          onClick={() => {
                            setUserMenuOpen(false)
                            if (item.onClick) item.onClick()
                          }}
                          className="flex items-center gap-3 px-4 py-3 text-gray-700 hover:bg-gray-50 transition-colors"
                        >
                          <item.icon className="w-4 h-4" />
                          <span>{item.name}</span>
                        </Link>
                      ))}
                    </motion.div>
                  )}
                </AnimatePresence>
              </div>
            ) : (
              <div className="flex items-center gap-3">
                <Link
                  href="/login"
                  className="px-4 py-2 text-gray-700 hover:text-primary-600 font-medium"
                >
                  ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„
                </Link>
                <Link
                  href="/register"
                  className="btn-primary"
                >
                  Ø§Ø´ØªØ±Ø§Ùƒ Ø¬Ø¯ÙŠØ¯
                </Link>
              </div>
            )}

            {/* Mobile Menu Button */}
            <button
              onClick={() => setIsOpen(!isOpen)}
              className="lg:hidden p-2 hover:bg-gray-100 rounded-xl transition-colors"
            >
              {isOpen ? (
                <X className="w-6 h-6 text-gray-700" />
              ) : (
                <Menu className="w-6 h-6 text-gray-700" />
              )}
            </button>
          </div>
        </div>

        {/* Mobile Menu */}
        <AnimatePresence>
          {isOpen && (
            <motion.div
              initial={{ opacity: 0, height: 0 }}
              animate={{ opacity: 1, height: 'auto' }}
              exit={{ opacity: 0, height: 0 }}
              className="lg:hidden overflow-hidden"
            >
              <div className="mt-4 pb-4 space-y-2 border-t border-gray-200 pt-4">
                {navItems.map((item) => (
                  <Link
                    key={item.name}
                    href={item.href}
                    onClick={() => setIsOpen(false)}
                    className={`block px-4 py-3 rounded-xl font-medium ${
                      pathname === item.href
                        ? 'bg-primary-50 text-primary-600'
                        : 'text-gray-700 hover:bg-gray-50'
                    }`}
                  >
                    {item.name}
                  </Link>
                ))}
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    </nav>
  )
}
2ï¸âƒ£ Core Constants
typescript
// lib/constants/status.ts

export const SLOT_STATUS = {
  AVAILABLE: 'AVAILABLE',
  TEMP_LOCKED: 'TEMP_LOCKED',
  BOOKED: 'BOOKED',
  UNAVAILABLE: 'UNAVAILABLE'
} as const

export const BOOKING_STATUS = {
  DRAFT: 'DRAFT',
  PENDING_PAYMENT: 'PENDING_PAYMENT',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED',
  FAILED: 'FAILED',
  EXPIRED: 'EXPIRED'
} as const

export const PAYMENT_STATUS = {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  PAID: 'PAID',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
} as const

export const FIELD_STATUS = {
  OPEN: 'OPEN',
  CLOSED: 'CLOSED',
  MAINTENANCE: 'MAINTENANCE'
} as const

export const NOTIFICATION_TYPE = {
  PAYMENT_SUCCESS: 'PAYMENT_SUCCESS',
  PAYMENT_FAILED: 'PAYMENT_FAILED',
  BOOKING_CONFIRMED: 'BOOKING_CONFIRMED',
  SLOT_REMINDER: 'SLOT_REMINDER'
} as const

export type SlotStatus = typeof SLOT_STATUS[keyof typeof SLOT_STATUS]
export type BookingStatus = typeof BOOKING_STATUS[keyof typeof BOOKING_STATUS]
export type PaymentStatus = typeof PAYMENT_STATUS[keyof typeof PAYMENT_STATUS]
export type FieldStatus = typeof FIELD_STATUS[keyof typeof FIELD_STATUS]
3ï¸âƒ£ Domain Errors
typescript
// lib/errors/domain-errors.ts

export const DOMAIN_ERRORS = {
  // Slot errors
  SLOT_NOT_FOUND: { code: 'SLOT_001', message: 'Ø§Ù„Ù…ÙˆØ¹Ø¯ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯' },
  SLOT_LOCKED_BY_OTHER: { code: 'SLOT_002', message: 'Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù…Ù‚ÙÙˆÙ„ Ù…Ø¤Ù‚ØªØ§Ù‹' },
  SLOT_LOCK_EXPIRED: { code: 'SLOT_003', message: 'Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù‚ÙÙ„' },
  SLOT_ALREADY_BOOKED: { code: 'SLOT_004', message: 'Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù…Ø­Ø¬ÙˆØ² Ø¨Ø§Ù„ÙØ¹Ù„' },
  SLOT_CANNOT_BE_LOCKED: { code: 'SLOT_005', message: 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ù‚ÙÙ„ Ù‡Ø°Ø§ Ø§Ù„Ù…ÙˆØ¹Ø¯' },
  SLOT_UNAVAILABLE: { code: 'SLOT_006', message: 'Ø§Ù„Ù…ÙˆØ¹Ø¯ ØºÙŠØ± Ù…ØªØ§Ø­ Ù„Ù„Ø­Ø¬Ø²' },
  
  // Booking errors
  BOOKING_NOT_FOUND: { code: 'BOOK_001', message: 'Ø§Ù„Ø­Ø¬Ø² ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯' },
  BOOKING_NOT_OWNED: { code: 'BOOK_002', message: 'ØºÙŠØ± Ù…ØµØ±Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù‡Ø°Ø§ Ø§Ù„Ø­Ø¬Ø²' },
  BOOKING_INVALID_STATE: { code: 'BOOK_003', message: 'Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„Ø§ ØªØ³Ù…Ø­ Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©' },
  BOOKING_LIMIT_EXCEEDED: { code: 'BOOK_004', message: 'ÙˆØµÙ„Øª Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø­Ø¬Ø²' },
  BOOKING_EXPIRED: { code: 'BOOK_005', message: 'Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø­Ø¬Ø²' },
  
  // Time errors
  TIME_IN_PAST: { code: 'TIME_001', message: 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø¬Ø² ÙˆÙ‚Øª Ù…Ø¶Ù‰' },
  TIME_TOO_CLOSE: { code: 'TIME_002', message: 'Ø§Ù„ÙˆÙ‚Øª Ù‚Ø±ÙŠØ¨ Ø¬Ø¯Ø§Ù‹' },

  // Payment errors
  PAYMENT_ALREADY_PROCESSED: { code: 'PAY_001', message: 'ØªÙ… Ø¯ÙØ¹ Ù‡Ø°Ø§ Ø§Ù„Ø­Ø¬Ø² Ù…Ø³Ø¨Ù‚Ø§Ù‹' },
  PAYMENT_FAILED: { code: 'PAY_002', message: 'ÙØ´Ù„ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¯ÙØ¹' },

  // General
  UNAUTHORIZED: { code: 'AUTH_001', message: 'ØºÙŠØ± Ù…ØµØ±Ø­' },
  VALIDATION_ERROR: { code: 'VAL_001', message: 'Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ§Ù„Ø­Ø©' }
} as const

export class DomainError extends Error {
  constructor(
    public errorCode: keyof typeof DOMAIN_ERRORS,
    public override message?: string
  ) {
    super(message || DOMAIN_ERRORS[errorCode].message)
    this.name = 'DomainError'
  }
  
  toResponse() {
    return {
      errorCode: DOMAIN_ERRORS[this.errorCode].code,
      errorMessage: this.message || DOMAIN_ERRORS[this.errorCode].message
    }
  }
}

export function errorResponse(error: unknown) {
  if (error instanceof DomainError) {
    return new Response(
      JSON.stringify(error.toResponse()),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    )
  }
  
  return new Response(
    JSON.stringify({
      errorCode: 'UNKNOWN_ERROR',
      errorMessage: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹'
    }),
    { status: 500, headers: { 'Content-Type': 'application/json' } }
  )
}
4ï¸âƒ£ Slot Read Model
typescript
// lib/slots/read-model.ts

import { SLOT_STATUS } from '@/lib/constants/status'

export type UISlotView = {
  id: string
  startTime: Date
  endTime: Date
  uiStatus: 'AVAILABLE' | 'LOCKED_ME' | 'LOCKED_OTHER' | 'BOOKED'
  originalStatus: string
  price: number
  deposit: number
  metadata?: {
    needsConfirmation?: boolean
    lockedUntil?: Date
    lockedByUserId?: string
  }
}

export class SlotReadModel {
  static toUISlot(dbSlot: any, currentUserId?: string | null): UISlotView {
    const now = new Date()
    const startTime = new Date(dbSlot.startTime)
    
    const dbStatus = this.normalizeDbStatus(dbSlot.status)
    
    let uiStatus: UISlotView['uiStatus']
    let needsConfirmation = false

    switch (dbStatus) {
      case SLOT_STATUS.BOOKED:
        uiStatus = 'BOOKED'
        break

      case SLOT_STATUS.TEMP_LOCKED:
        if (dbSlot.lockedByUserId === currentUserId) {
          uiStatus = 'LOCKED_ME'
        } else {
          uiStatus = 'LOCKED_OTHER'
        }
        break

      case SLOT_STATUS.AVAILABLE:
        uiStatus = 'AVAILABLE'
        const diffHours = (startTime.getTime() - now.getTime()) / (1000 * 60 * 60)
        if (diffHours < 24) {
          needsConfirmation = true
        }
        break

      default:
        throw new Error(`Ø­Ø§Ù„Ø© ØºÙŠØ± Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„Ø¹Ø±Ø¶: ${dbSlot.status}`)
    }

    return {
      id: dbSlot.id,
      startTime,
      endTime: new Date(dbSlot.endTime),
      uiStatus,
      originalStatus: dbSlot.status,
      price: dbSlot.price,
      deposit: dbSlot.deposit,
      metadata: {
        needsConfirmation,
        lockedUntil: dbSlot.lockedUntil ? new Date(dbSlot.lockedUntil) : undefined,
        lockedByUserId: dbSlot.lockedByUserId
      }
    }
  }
  
  private static normalizeDbStatus(dbStatus: string): string {
    switch (dbStatus) {
      case SLOT_STATUS.AVAILABLE:
      case 'AVAILABLE_NEEDS_CONFIRM':
      case 'PENDING_CONFIRMATION':
        return SLOT_STATUS.AVAILABLE
      case SLOT_STATUS.TEMP_LOCKED:
        return SLOT_STATUS.TEMP_LOCKED
      case SLOT_STATUS.BOOKED:
        return SLOT_STATUS.BOOKED
      case SLOT_STATUS.UNAVAILABLE:
        return SLOT_STATUS.UNAVAILABLE
      default:
        return SLOT_STATUS.UNAVAILABLE
    }
  }

  static filterVisibleSlots(dbSlots: any[], currentUserId?: string | null): UISlotView[] {
    return dbSlots
      .map(slot => this.toUISlot(slot, currentUserId))
      .filter(slot => ['AVAILABLE', 'LOCKED_ME', 'LOCKED_OTHER', 'BOOKED'].includes(slot.uiStatus))
  }
}

export function getUISlots(slots: any[], userId?: string): UISlotView[] {
  return SlotReadModel.filterVisibleSlots(slots, userId)
}
5ï¸âƒ£ Booking Guard
typescript
// lib/guards/assertBookingState.ts

import { prisma } from '@/lib/prisma'
import { DomainError } from '@/lib/errors/domain-errors'
import { SLOT_STATUS, BOOKING_STATUS } from '@/lib/constants/status'

export class BookingGuard {
  static async assertBookingState(params: {
    bookingId: string
    expectedStatuses: string[]
    userId?: string
    customCheck?: (booking: any) => Promise<void>
  }) {
    const booking = await prisma.booking.findUnique({
      where: { id: params.bookingId },
      include: { slot: true, field: true }
    })

    if (!booking) {
      throw new DomainError('BOOKING_NOT_FOUND')
    }

    if (params.userId && booking.userId !== params.userId) {
      throw new DomainError('BOOKING_NOT_OWNED')
    }

    if (!params.expectedStatuses.includes(booking.status)) {
      throw new DomainError('BOOKING_INVALID_STATE')
    }

    if (params.customCheck) {
      await params.customCheck(booking)
    }

    return booking
  }

  static async assertSlotLockedToUser(params: {
    slotId: string
    userId: string
  }) {
    const slot = await prisma.slot.findUnique({
      where: { id: params.slotId }
    })

    if (!slot) {
      throw new DomainError('SLOT_NOT_FOUND')
    }

    const now = new Date()

    if (slot.status !== SLOT_STATUS.TEMP_LOCKED) {
      throw new DomainError('SLOT_CANNOT_BE_LOCKED')
    }

    if (!slot.lockedUntil || slot.lockedUntil <= now) {
      throw new DomainError('SLOT_LOCK_EXPIRED')
    }

    if (slot.lockedByUserId !== params.userId) {
      throw new DomainError('SLOT_LOCKED_BY_OTHER')
    }

    return slot
  }

  static async assertSlotCanBeLocked(params: {
    slotId: string
    userId: string
  }) {
    const slot = await prisma.slot.findUnique({
      where: { id: params.slotId }
    })

    if (!slot) {
      throw new DomainError('SLOT_NOT_FOUND')
    }

    const now = new Date()

    if (slot.status === SLOT_STATUS.BOOKED) {
      throw new DomainError('SLOT_ALREADY_BOOKED')
    }

    if (slot.status === SLOT_STATUS.UNAVAILABLE) {
      throw new DomainError('SLOT_UNAVAILABLE')
    }

    if (new Date(slot.startTime) <= now) {
      throw new DomainError('TIME_IN_PAST')
    }

    if (
      slot.status === SLOT_STATUS.TEMP_LOCKED &&
      slot.lockedUntil &&
      slot.lockedUntil > now
    ) {
      if (slot.lockedByUserId === params.userId) {
        return { slot, canExtend: true }
      } else {
        throw new DomainError('SLOT_LOCKED_BY_OTHER')
      }
    }

    return { slot, canExtend: false }
  }
}

export const assertBooking = BookingGuard.assertBookingState.bind(BookingGuard)
export const assertSlotLocked = BookingGuard.assertSlotLockedToUser.bind(BookingGuard)
export const assertSlotCanLock = BookingGuard.assertSlotCanBeLocked.bind(BookingGuard)
6ï¸âƒ£ Core Logic
typescript
// lib/time-slots/core-logic.ts

import { addMinutes, startOfDay, addDays } from 'date-fns'
import { prisma } from '@/lib/prisma'
import { SLOT_STATUS } from '@/lib/constants/status'

const CONFIRMATION_WINDOW_HOURS = 24
const LOCK_DURATION_MINUTES = 5

export interface Day {
  date: Date
  label: string
  weekday: string
  dayNumber: string
  monthName: string
  isToday: boolean
  isTomorrow: boolean
}

function normalizeToMinute(date: Date): number {
  return Math.floor(date.getTime() / 60000) * 60000
}

export function canBookDirectly(start: Date): boolean {
  const diffMs = start.getTime() - Date.now()
  const diffHours = diffMs / (1000 * 60 * 60)
  return diffHours >= CONFIRMATION_WINDOW_HOURS
}

function normalizeDbStatus(status: string | null | undefined): string {
  if (!status) return SLOT_STATUS.AVAILABLE
  switch (status) {
    case SLOT_STATUS.AVAILABLE:
    case SLOT_STATUS.TEMP_LOCKED:
    case SLOT_STATUS.BOOKED:
    case SLOT_STATUS.UNAVAILABLE:
      return status
    case 'AVAILABLE_NEEDS_CONFIRM':
    case 'PENDING_CONFIRMATION':
      return SLOT_STATUS.AVAILABLE
    default:
      return SLOT_STATUS.UNAVAILABLE
  }
}

function resolveSlotStatus({
  field,
  slotStart,
  dbSlot,
  now
}: {
  field: any
  slotStart: Date
  dbSlot?: any
  now: Date
}): string | null {
  const diffMs = slotStart.getTime() - now.getTime()
  const diffHours = diffMs / (1000 * 60 * 60)

  if (diffHours < 0) return null

  if (field.status !== 'OPEN' && !dbSlot) {
    return SLOT_STATUS.UNAVAILABLE
  }

  if (dbSlot) {
    const dbStatus = normalizeDbStatus(dbSlot.status)

    if (
      dbStatus === SLOT_STATUS.TEMP_LOCKED &&
      dbSlot.lockedUntil &&
      new Date(dbSlot.lockedUntil) > now
    ) {
      return SLOT_STATUS.TEMP_LOCKED
    }

    if (dbStatus === SLOT_STATUS.BOOKED) {
      return SLOT_STATUS.BOOKED
    }

    if (dbStatus === SLOT_STATUS.UNAVAILABLE) {
      return SLOT_STATUS.UNAVAILABLE
    }
  }

  return SLOT_STATUS.AVAILABLE
}

export async function generateSlotsForDay({
  fieldId,
  date,
  now
}: {
  fieldId: string
  date: Date
  now: Date
}) {
  const field = await prisma.field.findUnique({
    where: { id: fieldId }
  })

  if (!field) {
    throw new Error('Field not found')
  }

  const dayStart = startOfDay(date)
  const dayEnd = addDays(dayStart, 1)

  const existingSlots = await prisma.slot.findMany({
    where: {
      fieldId,
      startTime: {
        gte: dayStart,
        lt: dayEnd
      }
    }
  })

  const slotsMap = new Map<number, any>(
    existingSlots.map(slot => [
      normalizeToMinute(new Date(slot.startTime)),
      slot
    ])
  )

  const [openH, openM] = field.openingTime.split(':').map(Number)
  const [closeH, closeM] = field.closingTime.split(':').map(Number)

  let current = startOfDay(date)
  current.setHours(openH, openM, 0, 0)

  const end = startOfDay(date)
  end.setHours(closeH, closeM, 0, 0)

  const slots: any[] = []

  while (addMinutes(current, field.slotDurationMin) <= end) {
    const slotStart = new Date(current)
    const slotEnd = addMinutes(slotStart, field.slotDurationMin)

    const key = normalizeToMinute(slotStart)
    const dbSlot = slotsMap.get(key)

    const status = resolveSlotStatus({
      field,
      slotStart,
      dbSlot,
      now
    })

    if (status) {
      slots.push({
        id: dbSlot?.id ?? `${fieldId}-${slotStart.toISOString()}`,
        fieldId,
        startTime: slotStart,
        endTime: slotEnd,
        status,
        price: field.pricePerHour,
        deposit: field.depositPrice
      })
    }

    current = slotEnd
  }

  return slots
}

export async function generateSlotsForRange({
  fieldId,
  startDate,
  endDate,
  now
}: {
  fieldId: string
  startDate: Date
  endDate: Date
  now: Date
}) {
  const allSlots: any[] = []
  let currentDate = startOfDay(startDate)

  while (currentDate <= endDate) {
    const daySlots = await generateSlotsForDay({
      fieldId,
      date: currentDate,
      now
    })

    allSlots.push(...daySlots)
    currentDate = addDays(currentDate, 1)
  }

  return allSlots
}

export async function lockSlot({
  slotId,
  userId
}: {
  slotId: string
  userId: string
}) {
  const now = new Date()

  return prisma.$transaction(async tx => {
    const slot = await tx.slot.findUnique({
      where: { id: slotId }
    })

    if (!slot) {
      throw new Error('Slot not available')
    }

    const status = normalizeDbStatus(slot.status)
    const canLock = status === SLOT_STATUS.AVAILABLE

    if (!canLock) {
      throw new Error('Slot not available')
    }

    await tx.slot.update({
      where: { id: slotId },
      data: {
        status: SLOT_STATUS.TEMP_LOCKED,
        lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES),
        lockedByUserId: userId
      }
    })

    return { success: true }
  })
}

export function generateNextDays(count: number = 10): Day[] {
  const days: Day[] = []
  const today = startOfDay(new Date())

  for (let i = 0; i < count; i++) {
    const date = addDays(today, i)

    const weekday = date.toLocaleDateString('ar-EG', { weekday: 'long' })
    const dayNumber = date.toLocaleDateString('ar-EG', { day: 'numeric' })
    const monthName = date.toLocaleDateString('ar-EG', { month: 'long' })

    days.push({
      date,
      label: `${weekday}ØŒ ${dayNumber} ${monthName}`,
      weekday,
      dayNumber,
      monthName,
      isToday: i === 0,
      isTomorrow: i === 1
    })
  }

  return days
}

export function generateNextTenDays(): Day[] {
  return generateNextDays(10)
}
7ï¸âƒ£ Booking Limits
typescript
// lib/time-slots/booking-limits.ts

import { prisma } from '@/lib/prisma'
import { startOfDay, addDays } from 'date-fns'
import { DomainError } from '@/lib/errors/domain-errors'

export async function checkBookingLimits({
  userId,
  slotDate,
  slotDurationMin
}: {
  userId: string
  slotDate: Date
  slotDurationMin: number
}) {
  const dayStart = startOfDay(slotDate)
  const dayEnd = addDays(dayStart, 1)
  
  // Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ ÙŠØ¨Ø¯Ø£ Ù…Ù† Ø§Ù„Ø³Ø¨Øª (Ø­Ø³Ø¨ Ù…ØµØ±)
  const dayOfWeek = dayStart.getDay()
  const weekStart = addDays(dayStart, -dayOfWeek)
  const weekEnd = addDays(weekStart, 7)

  // Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
  const dailyBookings = await prisma.booking.findMany({
    where: {
      userId,
      status: { in: ['CONFIRMED', 'PENDING_PAYMENT'] },
      slot: {
        startTime: { gte: dayStart, lt: dayEnd }
      }
    },
    include: { slot: true }
  })

  const dailyMinutes = dailyBookings.reduce((sum, booking) => {
    return sum + booking.slot.duration || 60
  }, 0)

  if (dailyMinutes + slotDurationMin > 120) {
    throw new DomainError('BOOKING_LIMIT_EXCEEDED', 'ÙˆØµÙ„Øª Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ø§Ù„ÙŠÙˆÙ…ÙŠ (Ø³Ø§Ø¹ØªÙŠÙ†)')
  }

  // Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ÙŠØ©
  const weeklyBookings = await prisma.booking.findMany({
    where: {
      userId,
      status: { in: ['CONFIRMED', 'PENDING_PAYMENT'] },
      slot: {
        startTime: { gte: weekStart, lt: weekEnd }
      }
    },
    include: { slot: true }
  })

  const weeklyMinutes = weeklyBookings.reduce((sum, booking) => {
    return sum + booking.slot.duration || 60
  }, 0)

  if (weeklyMinutes + slotDurationMin > 240) {
    throw new DomainError('BOOKING_LIMIT_EXCEEDED', 'ÙˆØµÙ„Øª Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ÙŠ (4 Ø³Ø§Ø¹Ø§Øª)')
  }

  return true
}
8ï¸âƒ£ Booking Orchestrator
typescript
// lib/booking/orchestrator.ts

import { prisma } from '@/lib/prisma'
import { addMinutes } from 'date-fns'
import { checkBookingLimits } from '@/lib/time-slots/booking-limits'
import { DomainError } from '@/lib/errors/domain-errors'
import { assertSlotLocked, assertBooking } from '@/lib/guards/assertBookingState'
import { SLOT_STATUS, BOOKING_STATUS, PAYMENT_STATUS } from '@/lib/constants/status'

export class BookingOrchestrator {
  static async initiateBooking(params: {
    userId: string
    slotId: string
    fieldId: string
    idempotencyKey?: string
  }) {
    return prisma.$transaction(async (tx) => {
      // 1. ØªØ£ÙƒØ¯ Ø¥Ù† Slot Ù…Ù‚ÙÙˆÙ„Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
      const slot = await tx.slot.findUnique({
        where: {
          id: params.slotId,
          status: SLOT_STATUS.TEMP_LOCKED,
          lockedByUserId: params.userId,
          lockedUntil: { gt: new Date() }
        },
        include: { field: true }
      })

      if (!slot) {
        throw new DomainError('SLOT_NOT_FOUND')
      }

      // 2. ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø­Ø¬Ø²
      await checkBookingLimits({
        userId: params.userId,
        slotDate: new Date(slot.startTime),
        slotDurationMin: slot.field.slotDurationMin
      })

      // 3. Ø£Ù†Ø´Ø¦ booking Ø¨Ø­Ø§Ù„Ø© DRAFT
      const booking = await tx.booking.create({
        data: {
          userId: params.userId,
          fieldId: params.fieldId,
          slotId: params.slotId,
          status: BOOKING_STATUS.DRAFT,
          paymentStatus: PAYMENT_STATUS.PENDING,
          totalAmount: slot.price,
          expiresAt: addMinutes(new Date(), 10),
          idempotencyKey: params.idempotencyKey
        }
      })

      return {
        bookingId: booking.id,
        needsConfirmation: !this.canBookDirectly(new Date(slot.startTime))
      }
    })
  }

  static async confirmBooking(bookingId: string, paymentData: any) {
    return prisma.$transaction(async (tx) => {
      // 1. ØªØ­Ù‚Ù‚ Ù…Ù† Booking
      const booking = await assertBooking({
        bookingId,
        expectedStatuses: [BOOKING_STATUS.DRAFT],
        customCheck: async (b) => {
          if (b.expiresAt && b.expiresAt < new Date()) {
            throw new DomainError('BOOKING_EXPIRED')
          }
        }
      })

      // 2. ØªØ­Ø¯ÙŠØ« Booking
      const updatedBooking = await tx.booking.update({
        where: { id: bookingId },
        data: {
          status: BOOKING_STATUS.PENDING_PAYMENT,
          paymentStatus: PAYMENT_STATUS.PROCESSING,
          paymentId: paymentData.paymentId,
          orderId: paymentData.orderId
        }
      })

      // 3. Slot ØªÙØ¶Ù„ TEMP_LOCKED (Ù„Ø³Ù‡ Ù…Ø´ BOOKED)
      return updatedBooking
    })
  }

  static async finalizeBooking(bookingId: string, paymentSuccess: boolean) {
    return prisma.$transaction(async (tx) => {
      const booking = await tx.booking.findUnique({
        where: { id: bookingId },
        include: { slot: true }
      })

      if (!booking) {
        throw new DomainError('BOOKING_NOT_FOUND')
      }

      if (paymentSuccess) {
        // âœ… Ø§Ù„Ø¯ÙØ¹ Ù†Ø¬Ø­
        await tx.booking.update({
          where: { id: bookingId },
          data: {
            status: BOOKING_STATUS.CONFIRMED,
            paymentStatus: PAYMENT_STATUS.PAID
          }
        })

        // âœ… Slot ÙŠØªØ­ÙˆÙ„ BOOKED
        await tx.slot.update({
          where: { id: booking.slotId },
          data: { status: SLOT_STATUS.BOOKED }
        })

        // âœ… Ø¥Ù†Ø´Ø§Ø¡ notification
        await tx.notification.create({
          data: {
            userId: booking.userId,
            type: 'PAYMENT_SUCCESS',
            title: 'ØªÙ… Ø§Ù„Ø¯ÙØ¹ Ø¨Ù†Ø¬Ø§Ø­',
            message: `ØªÙ… Ø¯ÙØ¹ ${booking.totalAmount} Ø¬.Ù… Ù„Ø­Ø¬Ø²Ùƒ`,
            relatedId: bookingId
          }
        })
      } else {
        // âŒ Ø§Ù„Ø¯ÙØ¹ ÙØ´Ù„
        await tx.booking.update({
          where: { id: bookingId },
          data: {
            status: BOOKING_STATUS.FAILED,
            paymentStatus: PAYMENT_STATUS.FAILED
          }
        })

        // âœ… Ø¥Ø¹Ø§Ø¯Ø© Slot Ù„Ù€ AVAILABLE
        await tx.slot.update({
          where: { id: booking.slotId },
          data: { status: SLOT_STATUS.AVAILABLE }
        })
      }

      return { success: true }
    })
  }

  private static canBookDirectly(start: Date): boolean {
    const diffMs = start.getTime() - Date.now()
    const diffHours = diffMs / (1000 * 60 * 60)
    return diffHours >= 24
  }
}
9ï¸âƒ£ API: Lock Slot
typescript
// app/api/fields/[fieldId]/slots/[slotId]/lock/route.ts

import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { prisma } from '@/lib/prisma'
import { authOptions } from '@/lib/auth'
import { addMinutes } from 'date-fns'
import { assertSlotCanLock } from '@/lib/guards/assertBookingState'
import { errorResponse } from '@/lib/errors/domain-errors'

const LOCK_DURATION_MINUTES = 5

export async function POST(
  request: NextRequest,
  { params }: { params: { fieldId: string; slotId: string } }
) {
  try {
    const session = await getServerSession(authOptions)
    const userId = session?.user?.id

    if (!userId) {
      return NextResponse.json(
        { error: 'ØºÙŠØ± Ù…ØµØ±Ø­' },
        { status: 401 }
      )
    }

    const { slotId, fieldId } = params
    const now = new Date()

    const { slot, canExtend } = await assertSlotCanLock({
      slotId,
      userId
    })

    if (slot.fieldId !== fieldId) {
      return NextResponse.json(
        { error: 'Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù„Ø§ ÙŠÙ†ØªÙ…ÙŠ Ø¥Ù„Ù‰ Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ø¹Ø¨' },
        { status: 400 }
      )
    }

    const result = await prisma.$transaction(async (tx) => {
      if (canExtend) {
        await tx.slot.update({
          where: { id: slotId },
          data: {
            lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES)
          }
        })
        return { success: true, extended: true }
      } else {
        await tx.slot.update({
          where: { id: slotId },
          data: {
            status: 'TEMP_LOCKED',
            lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES),
            lockedByUserId: userId
          }
        })
        return { success: true, locked: true }
      }
    })

    return NextResponse.json(result)
  } catch (error: any) {
    console.error('Lock error:', error)
    return errorResponse(error)
  }
}
ğŸ”Ÿ API: Bookings
typescript
// app/api/bookings/route.ts

import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { prisma } from '@/lib/prisma'
import { authOptions } from '@/lib/auth'
import { BookingOrchestrator } from '@/lib/booking/orchestrator'
import { errorResponse } from '@/lib/errors/domain-errors'

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    const userId = session?.user?.id

    if (!userId) {
      return NextResponse.json(
        { error: 'ØºÙŠØ± Ù…ØµØ±Ø­' },
        { status: 401 }
      )
    }

    const bookings = await prisma.booking.findMany({
      where: {
        userId,
        slot: { startTime: { gte: new Date() } }
      },
      include: {
        field: true,
        slot: true
      },
      orderBy: { slot: { startTime: 'asc' } }
    })

    return NextResponse.json({ bookings })
  } catch (error) {
    console.error('Get bookings error:', error)
    return errorResponse(error)
  }
}

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    const userId = session?.user?.id

    if (!userId) {
      return NextResponse.json(
        { error: 'ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹' },
        { status: 401 }
      )
    }

    const { slotId, fieldId, idempotencyKey } = await request.json()

    if (!slotId || !fieldId) {
      return NextResponse.json(
        { error: 'Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø¬Ø² ØºÙŠØ± Ù…ÙƒØªÙ…Ù„Ø©' },
        { status: 400 }
      )
    }

    const result = await BookingOrchestrator.initiateBooking({
      userId,
      slotId,
      fieldId,
      idempotencyKey
    })

    return NextResponse.json({
      success: true,
      bookingId: result.bookingId,
      needsConfirmation: result.needsConfirmation
    })
  } catch (error) {
    console.error('Create booking error:', error)
    return errorResponse(error)
  }
}
1ï¸âƒ£1ï¸âƒ£ API: Payments
typescript
// app/api/payments/create/route.ts

import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { prisma } from '@/lib/prisma'
import { authOptions } from '@/lib/auth'
import { BookingOrchestrator } from '@/lib/booking/orchestrator'
import { errorResponse } from '@/lib/errors/domain-errors'

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    const userId = session?.user?.id

    if (!userId) {
      return NextResponse.json(
        { error: 'ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹' },
        { status: 401 }
      )
    }

    const { bookingId, paymentMethod } = await request.json()

    if (!bookingId) {
      return NextResponse.json(
        { error: 'Ø±Ù‚Ù… Ø§Ù„Ø­Ø¬Ø² Ù…Ø·Ù„ÙˆØ¨' },
        { status: 400 }
      )
    }

    // TODO: Ø¯Ù…Ø¬ Ù…Ø¹ gateway Ø¯ÙØ¹ (Paymob, Stripe, etc.)
    const paymentData = {
      paymentId: `pay_${Date.now()}`,
      orderId: `order_${Date.now()}`,
      amount: 100, // TODO: Ø§Ø­ØµÙ„ Ù…Ù† Booking
      currency: 'EGP'
    }

    const booking = await BookingOrchestrator.confirmBooking(
      bookingId,
      paymentData
    )

    // TODO: Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ gateway Ø§Ù„Ø¯ÙØ¹
    // const paymentResult = await paymob.createPayment({...})

    return NextResponse.json({
      success: true,
      bookingId: booking.id,
      paymentUrl: 'https://payment-gateway.com/checkout' // TODO: URL Ø­Ù‚ÙŠÙ‚ÙŠ
    })
  } catch (error) {
    console.error('Payment error:', error)
    return errorResponse(error)
  }
}
1ï¸âƒ£2ï¸âƒ£ Webhook: Paymob
typescript
// app/api/webhooks/paymob/route.ts

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { BookingOrchestrator } from '@/lib/booking/orchestrator'
import { errorResponse } from '@/lib/errors/domain-errors'

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    
    // TODO: Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† HMAC signature
    // if (!verifyHMAC(body)) {
    //   return NextResponse.json({ error: 'Invalid signature' }, { status: 401 })
    // }

    const {
      success,
      order: { id: orderId },
      amount_cents,
      transactionId
    } = body.obj

    const payment = await prisma.payment.findFirst({
      where: { orderId: orderId.toString() },
      include: { booking: true }
    })

    if (!payment) {
      console.error('Payment not found for order:', orderId)
      return NextResponse.json({ error: 'Payment not found' }, { status: 404 })
    }

    await BookingOrchestrator.finalizeBooking(
      payment.bookingId,
      success
    )

    // TODO: ØªØ­Ø¯ÙŠØ« Ø³Ø¬Ù„ Ø§Ù„Ø¯ÙØ¹
    await prisma.payment.update({
      where: { id: payment.id },
      data: {
        status: success ? 'PAID' : 'FAILED',
        metadata: body.obj
      }
    })

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Webhook error:', error)
    return errorResponse(error)
  }
}
1ï¸âƒ£3ï¸âƒ£ Cron Cleanup
typescript
// app/api/cron/cleanup/route.ts

import { prisma } from '@/lib/prisma'
import { addMinutes } from 'date-fns'
import { NextResponse } from 'next/server'

export const dynamic = 'force-dynamic'

export async function GET(request: Request) {
  const authHeader = request.headers.get('authorization')
  
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return new Response('Unauthorized', { status: 401 })
  }

  const now = new Date()
  const results = {
    unlockedSlots: 0,
    expiredBookings: 0,
    orphanedSlotsFixed: 0
  }

  try {
    // 1. ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù€ TEMP_LOCKED Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ©
    const unlocked = await prisma.slot.updateMany({
      where: {
        status: 'TEMP_LOCKED',
        lockedUntil: { lt: now }
      },
      data: {
        status: 'AVAILABLE',
        lockedByUserId: null,
        lockedUntil: null
      }
    })
    results.unlockedSlots = unlocked.count

    // 2. Bookings ÙÙŠ DRAFT Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØªÙ‡Ø§
    const expiredTime = addMinutes(now, -15)
    const expired = await prisma.booking.updateMany({
      where: {
        status: 'DRAFT',
        expiresAt: { lt: now }
      },
      data: {
        status: 'EXPIRED',
        paymentStatus: 'FAILED'
      }
    })
    results.expiredBookings = expired.count

    // 3. ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù€ slots Ø§Ù„Ù„ÙŠ Ù…ÙÙŠØ´ Ù„Ù‡Ø§ bookings
    const orphanedSlots = await prisma.slot.findMany({
      where: {
        status: 'BOOKED',
        bookings: {
          none: {
            status: { in: ['CONFIRMED', 'PENDING_PAYMENT'] }
          }
        }
      }
    })

    if (orphanedSlots.length > 0) {
      await prisma.slot.updateMany({
        where: {
          id: { in: orphanedSlots.map(s => s.id) }
        },
        data: { status: 'AVAILABLE' }
      })
      results.orphanedSlotsFixed = orphanedSlots.length
    }

    return NextResponse.json({
      success: true,
      timestamp: now.toISOString(),
      results
    })
  } catch (error) {
    console.error('Cron cleanup error:', error)
    return NextResponse.json(
      { error: 'Cleanup failed' },
      { status: 500 }
    )
  }
}
1ï¸âƒ£4ï¸âƒ£ UI Components
Slot Grid
tsx
// app/components/booking/slot-grid.tsx
'use client'

import { useState } from 'react'
import SlotBookingModal from './slot-booking-modal'
import { getUISlots } from '@/lib/slots/read-model'

interface Slot {
  id: string
  startTime: Date
  endTime: Date
  status: string
  price: number
  deposit: number
  lockedUntil?: Date
  lockedByUserId?: string
}

interface SlotGridProps {
  slots: Slot[]
  fieldId: string
  fieldName: string
  userId?: string
}

export default function SlotGrid({ slots, fieldId, fieldName, userId }: SlotGridProps) {
  const [selectedSlot, setSelectedSlot] = useState<any>(null)
  const uiSlots = getUISlots(slots, userId)

  const handleSelectSlot = (slot: any) => {
    if (slot.uiStatus === 'AVAILABLE') {
      setSelectedSlot(slot)
    }
  }

  return (
    <div className="space-y-4">
      <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
        {uiSlots.map((slot) => {
          let bgColor = 'bg-gray-100'
          let textColor = 'text-gray-800'
          let disabled = false

          switch (slot.uiStatus) {
            case 'AVAILABLE':
              bgColor = 'bg-green-100 hover:bg-green-200'
              textColor = 'text-green-800'
              break
            case 'LOCKED_ME':
              bgColor = 'bg-blue-100'
              textColor = 'text-blue-800'
              disabled = true
              break
            case 'LOCKED_OTHER':
              bgColor = 'bg-gray-300'
              textColor = 'text-gray-600'
              disabled = true
              break
            case 'BOOKED':
              bgColor = 'bg-gray-300'
              textColor = 'text-gray-600'
              disabled = true
              break
          }

          return (
            <button
              key={slot.id}
              onClick={() => handleSelectSlot(slot)}
              disabled={disabled}
              className={`p-4 rounded-lg ${bgColor} ${textColor} border transition-colors disabled:opacity-50 disabled:cursor-not-allowed`}
            >
              <div className="font-medium">
                {slot.startTime.toLocaleTimeString('ar-EG', { 
                  hour: '2-digit', 
                  minute: '2-digit',
                  hour12: true 
                })}
              </div>
              {slot.metadata?.needsConfirmation && (
                <div className="text-xs mt-1 text-yellow-600">ÙŠØ­ØªØ§Ø¬ ØªØ£ÙƒÙŠØ¯</div>
              )}
              <div className="text-sm mt-2 font-semibold">
                {slot.price} Ø¬.Ù…
              </div>
            </button>
          )
        })}
      </div>

      {selectedSlot && (
        <SlotBookingModal
          slot={selectedSlot}
          fieldId={fieldId}
          fieldName={fieldName}
          onClose={() => setSelectedSlot(null)}
        />
      )}
    </div>
  )
}
Slot Booking Modal
tsx
// app/components/booking/slot-booking-modal.tsx
'use client'

import { X, Clock, CreditCard, AlertCircle } from 'lucide-react'
import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { useSession } from 'next-auth/react'

interface SlotBookingModalProps {
  slot: any
  fieldId: string
  fieldName: string
  onClose: () => void
}

export default function SlotBookingModal({ slot, fieldId, fieldName, onClose }: SlotBookingModalProps) {
  const { data: session } = useSession()
  const router = useRouter()
  const [isLoading, setIsLoading] = useState(false)

  const handleBook = async () => {
    if (!session) {
      router.push('/login')
      return
    }

    setIsLoading(true)
    try {
      // 1. Ù‚ÙÙ„ Ø§Ù„Ù€ slot Ø£ÙˆÙ„Ø§Ù‹
      const lockRes = await fetch(`/api/fields/${fieldId}/slots/${slot.id}/lock`, {
        method: 'POST'
      })

      if (!lockRes.ok) {
        throw new Error('ÙØ´Ù„ ÙÙŠ Ù‚ÙÙ„ Ø§Ù„Ù…ÙˆØ¹Ø¯')
      }

      // 2. Ø¥Ù†Ø´Ø§Ø¡ booking
      const bookingRes = await fetch('/api/bookings', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          slotId: slot.id,
          fieldId,
          idempotencyKey: `book_${Date.now()}_${slot.id}`
        })
      })

      const bookingData = await bookingRes.json()

      if (!bookingRes.ok) {
        throw new Error(bookingData.error || 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø¬Ø²')
      }

      if (slot.metadata?.needsConfirmation) {
        alert('ØªÙ… ØªÙ‚Ø¯ÙŠÙ… Ø·Ù„Ø¨ Ø§Ù„Ø­Ø¬Ø² Ø¨Ù†Ø¬Ø§Ø­! Ø³ÙŠØªÙ… ØªØ£ÙƒÙŠØ¯Ù‡ Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ù…ÙˆØ¸Ù.')
        onClose()
        router.push('/bookings')
      } else {
        // ØªÙˆØ¬ÙŠÙ‡ Ù„Ù„Ø¯ÙØ¹
        router.push(`/payment/${bookingData.bookingId}`)
      }
    } catch (error: any) {
      console.error('Booking error:', error)
      alert(error.message || 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­Ø¬Ø²')
    } finally {
      setIsLoading(false)
    }
  }

  const formatTime = (date: Date) => {
    return date.toLocaleTimeString('ar-EG', {
      hour: '2-digit',
      minute: '2-digit',
      hour12: true
    })
  }

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-2xl max-w-md w-full">
        <div className="flex items-center justify-between p-6 border-b">
          <h3 className="text-xl font-bold">ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø¬Ø²</h3>
          <button onClick={onClose} className="p-2 hover:bg-gray-100 rounded-lg">
            <X className="w-5 h-5" />
          </button>
        </div>

        <div className="p-6 space-y-4">
          <h4 className="font-bold text-lg">{fieldName}</h4>
          
          <div className="flex items-center gap-2 text-gray-600">
            <Clock className="w-4 h-4" />
            <span>
              {slot.startTime.toLocaleDateString('ar-EG')} | 
              Ù…Ù† {formatTime(slot.startTime)} Ø¥Ù„Ù‰ {formatTime(slot.endTime)}
            </span>
          </div>

          <div className="flex items-center gap-2 text-gray-600">
            <CreditCard className="w-4 h-4" />
            <span>Ø§Ù„Ø³Ø¹Ø±: {slot.price} Ø¬Ù†ÙŠÙ‡</span>
          </div>

          {slot.metadata?.needsConfirmation && (
            <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-3">
              <AlertCircle className="w-5 h-5 text-yellow-600 inline-block mr-2" />
              <span className="text-yellow-700">Ù‡Ø°Ø§ Ø§Ù„Ù…ÙˆØ¹Ø¯ ÙŠØ­ØªØ§Ø¬ ØªØ£ÙƒÙŠØ¯ Ù…Ù† Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©</span>
            </div>
          )}
        </div>

        <div className="p-6 border-t">
          <div className="flex gap-3">
            <button
              onClick={onClose}
              className="flex-1 py-3 px-4 border border-gray-300 rounded-xl font-medium hover:bg-gray-50"
            >
              Ø¥Ù„ØºØ§Ø¡
            </button>
            <button
              onClick={handleBook}
              disabled={isLoading}
              className="flex-1 py-3 px-4 rounded-xl font-bold text-white bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 disabled:opacity-50"
            >
              {isLoading ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­Ø¬Ø²...' : 'Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„Ø­Ø¬Ø²'}
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}
Day Selector
tsx
// app/components/booking/day-selector.tsx
'use client'

import { ChevronRight, ChevronLeft } from 'lucide-react'

interface Day {
  date: Date
  label: string
  weekday: string
  dayNumber: string
  monthName: string
  isToday: boolean
  isTomorrow: boolean
}

interface DaySelectorProps {
  days: Day[]
  selectedDate: Date | null
  onSelectDate: (date: Date) => void
}

export default function DaySelector({ days, selectedDate, onSelectDate }: DaySelectorProps) {
  const scroll = (direction: 'left' | 'right') => {
    const container = document.getElementById('days-container')
    if (container) {
      const scrollAmount = direction === 'left' ? -200 : 200
      container.scrollBy({ left: scrollAmount, behavior: 'smooth' })
    }
  }

  return (
    <div className="mb-8">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-lg font-semibold">Ø§Ø®ØªØ± Ø§Ù„ÙŠÙˆÙ…</h3>
        <div className="flex gap-2">
          <button
            onClick={() => scroll('left')}
            className="p-2 rounded-lg bg-gray-100 hover:bg-gray-200"
          >
            <ChevronLeft className="w-5 h-5" />
          </button>
          <button
            onClick={() => scroll('right')}
            className="p-2 rounded-lg bg-gray-100 hover:bg-gray-200"
          >
            <ChevronRight className="w-5 h-5" />
          </button>
        </div>
      </div>

      <div className="relative">
        <div
          id="days-container"
          className="flex gap-3 overflow-x-auto pb-4 scrollbar-hide"
        >
          {days.map((day) => {
            const isSelected = selectedDate?.toDateString() === day.date.toDateString()
            
            return (
              <button
                key={day.date.toISOString()}
                onClick={() => onSelectDate(day.date)}
                className={`flex-shrink-0 w-28 rounded-xl p-4 text-center transition-all ${
                  isSelected
                    ? 'bg-gradient-to-r from-blue-500 to-blue-600 text-white shadow-lg scale-105'
                    : 'bg-gray-100 hover:bg-gray-200 text-gray-700'
                }`}
              >
                <div className="text-sm mb-1">
                  {day.isToday ? 'Ø§Ù„ÙŠÙˆÙ…' : day.isTomorrow ? 'ØºØ¯Ø§Ù‹' : day.weekday}
                </div>
                <div className="text-lg font-bold">{day.dayNumber}</div>
                <div className="text-sm mt-1">{day.monthName}</div>
              </button>
            )
          })}
        </div>
      </div>
    </div>
  )
}
1ï¸âƒ£5ï¸âƒ£ Main Page
tsx
// app/page.tsx
'use client'

import { useState, useEffect } from 'react'
import { useSession } from 'next-auth/react'
import DaySelector from './components/booking/day-selector'
import SlotGrid from './components/booking/slot-grid'
import { generateNextDays } from '@/lib/time-slots/core-logic'

export default function HomePage() {
  const { data: session } = useSession()
  const [selectedDate, setSelectedDate] = useState<Date>(new Date())
  const [slots, setSlots] = useState<any[]>([])
  const [field, setField] = useState<any>(null)
  const [loading, setLoading] = useState(true)
  
  const days = generateNextDays(10)

  useEffect(() => {
    fetchSlots()
  }, [selectedDate])

  const fetchSlots = async () => {
    try {
      setLoading(true)
      // TODO: Ø§Ø­ØµÙ„ fieldId Ù…Ù† context Ø£Ùˆ params
      const fieldId = '1' // Ù…Ø¤Ù‚Øª
      
      const dateStr = selectedDate.toISOString().split('T')[0]
      const res = await fetch(`/api/fields/${fieldId}/slots?date=${dateStr}`)
      const data = await res.json()
      
      setSlots(data.slots)
      setField(data.field)
    } catch (error) {
      console.error('Error fetching slots:', error)
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="container mx-auto px-4 py-8">
        <header className="mb-8">
          <h1 className="text-3xl font-bold text-gray-900">Ø­Ø¬Ø² Ø§Ù„Ù…Ù„Ø§Ø¹Ø¨</h1>
          <p className="text-gray-600 mt-2">Ø§Ø®ØªØ± Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ ÙˆØ­Ø¬Ø² Ù…Ù„Ø§Ø¹Ø¨Ùƒ Ø§Ù„Ù…ÙØ¶Ù„Ø©</p>
        </header>

        <div className="bg-white rounded-2xl shadow-lg p-6">
          {field && (
            <div className="mb-6">
              <h2 className="text-2xl font-bold mb-2">{field.name}</h2>
              <p className="text-gray-600">{field.description}</p>
              <div className="flex items-center gap-4 mt-3">
                <span className="bg-green-100 text-green-800 px-3 py-1 rounded-full text-sm">
                  {field.pricePerHour} Ø¬.Ù…/Ø³Ø§Ø¹Ø©
                </span>
                <span className="text-gray-600">
                  Ù…ÙˆØ§Ø¹ÙŠØ¯ Ø§Ù„Ø¹Ù…Ù„: {field.openingTime} - {field.closingTime}
                </span>
              </div>
            </div>
          )}

          <DaySelector
            days={days}
            selectedDate={selectedDate}
            onSelectDate={setSelectedDate}
          />

          {loading ? (
            <div className="text-center py-12">
              <div className="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
              <p className="mt-4 text-gray-600">Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯...</p>
            </div>
          ) : (
            <SlotGrid
              slots={slots}
              fieldId={field?.id || ''}
              fieldName={field?.name || ''}
              userId={session?.user?.id}
            />
          )}
        </div>

        <div className="mt-8 grid grid-cols-1 md:grid-cols-3 gap-4">
          <div className="bg-white p-4 rounded-xl border">
            <h4 className="font-bold mb-2">ğŸš€ Ø­Ø¬Ø² ÙÙˆØ±ÙŠ</h4>
            <p className="text-sm text-gray-600">Ø§Ø­Ø¬Ø² ÙˆØ§Ø¯ÙØ¹ Ù…Ø¨Ø§Ø´Ø±Ø© Ù„Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯ Ø¨Ø¹Ø¯ 24 Ø³Ø§Ø¹Ø©</p>
          </div>
          
          <div className="bg-white p-4 rounded-xl border">
            <h4 className="font-bold mb-2">â° ØªØ£ÙƒÙŠØ¯ ÙŠØ¯ÙˆÙŠ</h4>
            <p className="text-sm text-gray-600">Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯ Ø§Ù„Ù‚Ø±ÙŠØ¨Ø© ØªØ­ØªØ§Ø¬ ØªØ£ÙƒÙŠØ¯ Ù…Ù† Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©</p>
          </div>
          
          <div className="bg-white p-4 rounded-xl border">
            <h4 className="font-bold mb-2">ğŸ”’ Ù‚ÙÙ„ Ø¢Ù…Ù†</h4>
            <p className="text-sm text-gray-600">Ø§Ù„Ù…ÙˆØ¹Ø¯ ÙŠØ¨Ù‚Ù‰ Ù…Ù‚ÙÙˆÙ„ Ù„Ùƒ 5 Ø¯Ù‚Ø§Ø¦Ù‚ Ù„Ø¥ØªÙ…Ø§Ù… Ø§Ù„Ø­Ø¬Ø²</p>
          </div>
        </div>
      </div>
    </div>
  )
}
1ï¸âƒ£6ï¸âƒ£ Prisma Client
typescript
// lib/prisma.ts

import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma = globalForPrisma.prisma ?? new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma
1ï¸âƒ£7ï¸âƒ£ Auth Config
typescript
// lib/auth.ts

import NextAuth from 'next-auth'
import CredentialsProvider from 'next-auth/providers/credentials'
import { prisma } from '@/lib/prisma'

export const authOptions = {
  providers: [
    CredentialsProvider({
      name: 'credentials',
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Password', type: 'password' }
      },
      async authorize(credentials) {
        // TODO: Implement real authentication
        if (!credentials) return null
        
        // Mock user for development
        const user = await prisma.user.upsert({
          where: { email: credentials.email },
          update: {},
          create: {
            email: credentials.email,
            name: 'Test User',
            phone: '01000000000'
          }
        })
        
        return {
          id: user.id,
          email: user.email,
          name: user.name
        }
      }
    })
  ],
  session: {
    strategy: 'jwt' as const
  },
  pages: {
    signIn: '/login'
  }
}

export const { handlers, signIn, signOut, auth } = NextAuth(authOptions)
1ï¸âƒ£8ï¸âƒ£ Package.json Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
json
{
  "name": "booking-system",
  "version": "1.0.0",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "db:generate": "prisma generate",
    "db:push": "prisma db push",
    "db:seed": "tsx prisma/seed.ts"
  },
  "dependencies": {
    "@prisma/client": "^5.7.0",
    "date-fns": "^3.3.1",
    "next": "14.0.4",
    "next-auth": "^4.24.5",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "lucide-react": "^0.309.0"
  },
  "devDependencies": {
    "@types/node": "^20.10.5",
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.18",
    "autoprefixer": "^10.4.16",
    "postcss": "^8.4.32",
    "prisma": "^5.7.0",
    "tailwindcss": "^3.4.0",
    "typescript": "^5.3.3"
  }
}
2ï¸âƒ£ Idempotency Guard (Ù…Ù„Ù Ø¬Ø¯ÙŠØ¯)
typescript
// lib/idempotency/idempotency-guard.ts

import { prisma } from '@/lib/prisma'
import { addMinutes } from 'date-fns'

export class IdempotencyGuard {
  /**
   * ğŸ” ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø¹Ù…Ù„ÙŠØ© idempotent
   * @param key Ø§Ù„Ù…ÙØªØ§Ø­ Ø§Ù„ÙØ±ÙŠØ¯
   * @param userId Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
   * @param method Ø§Ø³Ù… Ø§Ù„Ø¹Ù…Ù„ÙŠØ©
   * @param requestData Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø¨ (Ù„ØªØ¬Ù†Ø¨ Ù†ÙØ³ Ø§Ù„Ø·Ù„Ø¨ Ø¨Ù…Ø¹Ø·ÙŠØ§Øª Ù…Ø®ØªÙ„ÙØ©)
   * @returns {idempotent: boolean, response?: any, shouldProceed: boolean}
   */
  static async check(
    key: string,
    userId: string,
    method: string,
    requestData?: any
  ): Promise<{
    idempotent: boolean
    response?: any
    shouldProceed: boolean
  }> {
    const now = new Date()
    
    // 1. ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ©
    await prisma.idempotencyKey.deleteMany({
      where: { expiresAt: { lt: now } }
    })

    // 2. Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…ÙØªØ§Ø­
    const existing = await prisma.idempotencyKey.findUnique({
      where: { key }
    })

    if (!existing) {
      return { idempotent: false, shouldProceed: true }
    }

    // 3. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆØ§Ù„Ø·Ø±ÙŠÙ‚Ø©
    if (existing.userId !== userId || existing.method !== method) {
      throw new Error('Ù…ÙØªØ§Ø­ idempotency ØºÙŠØ± ØµØ§Ù„Ø­ Ù„Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ùˆ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©')
    }

    // 4. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† requestHash Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
    if (requestData && existing.requestHash) {
      const currentHash = this.hashRequest(requestData)
      if (currentHash !== existing.requestHash) {
        throw new Error('Ø·Ù„Ø¨ Ù…ÙƒØ±Ø± Ø¨Ù…Ø¹Ø·ÙŠØ§Øª Ù…Ø®ØªÙ„ÙØ©')
      }
    }

    // 5. Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ response Ù…Ø®Ø²Ù†
    if (existing.response) {
      return {
        idempotent: true,
        response: existing.response,
        shouldProceed: false
      }
    }

    // 6. Ø§Ù„Ù…ÙØªØ§Ø­ Ù…ÙˆØ¬ÙˆØ¯ ÙˆÙ„ÙƒÙ† Ø¨Ø¯ÙˆÙ† response (Ù…Ø§Ø²Ø§Ù„ ÙŠØ¹Ù…Ù„)
    return { idempotent: true, shouldProceed: false }
  }

  /**
   * ğŸ’¾ Ø­ÙØ¸ Ù†ØªÙŠØ¬Ø© idempotent
   */
  static async saveResponse(
    key: string,
    userId: string,
    method: string,
    response: any,
    requestData?: any,
    ttlMinutes: number = 60
  ) {
    return prisma.idempotencyKey.upsert({
      where: { key },
      update: {
        response,
        expiresAt: addMinutes(new Date(), ttlMinutes)
      },
      create: {
        key,
        userId,
        method,
        requestHash: requestData ? this.hashRequest(requestData) : null,
        response,
        expiresAt: addMinutes(new Date(), ttlMinutes)
      }
    })
  }

  /**
   * ğŸ”¢ ØªÙˆÙ„ÙŠØ¯ Ù…ÙØªØ§Ø­ Ø¢Ù…Ù†
   */
  static generateKey(prefix: string = 'req'): string {
    const timestamp = Date.now()
    const random = Math.random().toString(36).substring(2, 15)
    return `${prefix}_${timestamp}_${random}`
  }

  /**
   * ğŸ” Ø­Ø³Ø§Ø¨ Ù‡Ø§Ø´ Ù„Ù„Ø·Ù„Ø¨
   */
  private static hashRequest(data: any): string {
    const str = JSON.stringify(data, Object.keys(data).sort())
    // Ø§Ø³ØªØ®Ø¯Ø§Ù… hash Ø¨Ø³ÙŠØ· - ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ¨Ø¯Ø§Ù„Ù‡ Ø¨Ù€ crypto
    let hash = 0
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i)
      hash = ((hash << 5) - hash) + char
      hash = hash & hash
    }
    return hash.toString(36)
  }
}
3ï¸âƒ£ HMAC Verifier (Ù…Ù„Ù Ø¬Ø¯ÙŠØ¯)
typescript
// lib/paymob/hmac-verifier.ts

import crypto from 'crypto'

export class PaymobHmacVerifier {
  private readonly apiKey: string

  constructor(apiKey: string) {
    this.apiKey = apiKey
  }

  /**
   * ğŸ” Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªÙˆÙ‚ÙŠØ¹ HMAC
   * @param data Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù€ webhook
   * @param receivedHmac Ø§Ù„Ù€ HMAC Ø§Ù„Ù…Ø³ØªÙ„Ù…
   * @returns boolean
   */
  verify(data: any, receivedHmac: string): boolean {
    try {
      // 1. ØªØ±ØªÙŠØ¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙƒÙ…Ø§ ØªØªÙˆÙ‚Ø¹ Paymob
      const orderedData = this.orderData(data)
      
      // 2. ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù€ string
      const dataString = JSON.stringify(orderedData)
      
      // 3. Ø­Ø³Ø§Ø¨ HMAC
      const calculatedHmac = crypto
        .createHmac('sha512', this.apiKey)
        .update(dataString)
        .digest('hex')
      
      // 4. Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø© (ØªÙˆÙ‚ÙŠØª Ø«Ø§Ø¨Øª Ù„Ù…Ù†Ø¹ timing attacks)
      return crypto.timingSafeEqual(
        Buffer.from(calculatedHmac, 'hex'),
        Buffer.from(receivedHmac, 'hex')
      )
    } catch (error) {
      console.error('HMAC verification error:', error)
      return false
    }
  }

  /**
   * ğŸ›¡ï¸ Replay Attack Protection
   * @param timestamp ØªÙˆÙ‚ÙŠØª Ø§Ù„Ø·Ù„Ø¨ (Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª)
   * @param maxAgeSeconds Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø¹Ù…Ø± (Ø«Ø§Ù†ÙŠØ©)
   * @returns boolean
   */
  isFresh(timestamp: number, maxAgeSeconds: number = 300): boolean {
    const now = Math.floor(Date.now() / 1000)
    const age = now - timestamp
    return age <= maxAgeSeconds && age >= 0
  }

  /**
   * ğŸ”¢ ØªØ±ØªÙŠØ¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø­Ø³Ø¨ Ù…ÙØªØ§Ø­ Paymob
   */
  private orderData(data: any): any {
    // ØªØ±ØªÙŠØ¨ Ø«Ø§Ø¨Øª Ø­Ø³Ø¨ ÙˆØ«Ø§Ø¦Ù‚ Paymob
    const ordered: any = {}
    
    // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø¨Ø§Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨
    if (data.amount_cents !== undefined) ordered.amount_cents = data.amount_cents
    if (data.created_at !== undefined) ordered.created_at = data.created_at
    if (data.currency !== undefined) ordered.currency = data.currency
    if (data.error_occured !== undefined) ordered.error_occured = data.error_occured
    if (data.has_parent_transaction !== undefined) ordered.has_parent_transaction = data.has_parent_transaction
    if (data.id !== undefined) ordered.id = data.id
    if (data.integration_id !== undefined) ordered.integration_id = data.integration_id
    if (data.is_3d_secure !== undefined) ordered.is_3d_secure = data.is_3d_secure
    if (data.is_auth !== undefined) ordered.is_auth = data.is_auth
    if (data.is_capture !== undefined) ordered.is_capture = data.is_capture
    if (data.is_refunded !== undefined) ordered.is_refunded = data.is_refunded
    if (data.is_standalone_payment !== undefined) ordered.is_standalone_payment = data.is_standalone_payment
    if (data.is_voided !== undefined) ordered.is_voided = data.is_voided
    if (data.order !== undefined) ordered.order = data.order
    if (data.owner !== undefined) ordered.owner = data.owner
    if (data.pending !== undefined) ordered.pending = data.pending
    if (data.source_data !== undefined) ordered.source_data = data.source_data
    if (data.success !== undefined) ordered.success = data.success
    
    return ordered
  }
}

// âœ… Export singleton instance
export const paymobHmacVerifier = new PaymobHmacVerifier(
  process.env.PAYMOB_HMAC_SECRET!
)
4ï¸âƒ£ Booking Orchestrator (Ù…ÙØ­Ø³Ù‘Ù†)
typescript
// lib/booking/orchestrator.ts

import { prisma } from '@/lib/prisma'
import { addMinutes } from 'date-fns'
import { checkBookingLimits } from '@/lib/time-slots/booking-limits'
import { DomainError } from '@/lib/errors/domain-errors'
import { IdempotencyGuard } from '@/lib/idempotency/idempotency-guard'
import { SLOT_STATUS, BOOKING_STATUS, PAYMENT_STATUS } from '@/lib/constants/status'

export class BookingOrchestrator {
  /**
   * ğŸ« Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø¬Ø² Ø¬Ø¯ÙŠØ¯ (Ù…Ø¹ Idempotency)
   */
  static async initiateBooking(params: {
    userId: string
    slotId: string
    fieldId: string
    idempotencyKey?: string
  }) {
    // ğŸ” Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Idempotency
    if (params.idempotencyKey) {
      const idempotencyCheck = await IdempotencyGuard.check(
        params.idempotencyKey,
        params.userId,
        'booking:create',
        { slotId: params.slotId, fieldId: params.fieldId }
      )

      if (!idempotencyCheck.shouldProceed) {
        if (idempotencyCheck.response) {
          return idempotencyCheck.response
        }
        throw new DomainError('BOOKING_IN_PROGRESS', 'Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø·Ù„Ø¨')
      }
    }

    return prisma.$transaction(async (tx) => {
      // 1. ğŸ” ØªØ£ÙƒØ¯ Ø£Ù† Slot Ù…Ù‚ÙÙˆÙ„Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
      const slot = await tx.slot.findUnique({
        where: {
          id: params.slotId,
          status: SLOT_STATUS.TEMP_LOCKED,
          lockedByUserId: params.userId,
          lockedUntil: { gt: new Date() }
        },
        include: { field: true }
      })

      if (!slot) {
        throw new DomainError('SLOT_NOT_FOUND', 'Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù„Ù… ÙŠØ¹Ø¯ Ù…ØªØ§Ø­Ø§Ù‹')
      }

      // 2. ğŸ“ ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø­Ø¬Ø² (Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø¯Ø© Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©)
      await checkBookingLimits({
        userId: params.userId,
        slotDate: new Date(slot.startTime),
        slotDurationMin: slot.durationMinutes
      })

      // 3. ğŸ« Ø¥Ù†Ø´Ø§Ø¡ Booking
      const booking = await tx.booking.create({
        data: {
          userId: params.userId,
          fieldId: params.fieldId,
          slotId: params.slotId,
          status: BOOKING_STATUS.DRAFT,
          paymentStatus: PAYMENT_STATUS.PENDING,
          totalAmount: slot.price,
          expiresAt: addMinutes(new Date(), 10),
          idempotencyKey: params.idempotencyKey
        }
      })

      const response = {
        bookingId: booking.id,
        needsConfirmation: !this.canBookDirectly(new Date(slot.startTime))
      }

      // ğŸ’¾ Ø­ÙØ¸ response Ù„Ù„Ù€ Idempotency
      if (params.idempotencyKey) {
        await IdempotencyGuard.saveResponse(
          params.idempotencyKey,
          params.userId,
          'booking:create',
          response,
          { slotId: params.slotId, fieldId: params.fieldId },
          60 // TTL: 60 Ø¯Ù‚ÙŠÙ‚Ø©
        )
      }

      return response
    })
  }

  /**
   * ğŸ’³ ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø¬Ø² ÙˆØ¥Ù†Ø´Ø§Ø¡ Payment
   */
  static async confirmBooking(
    bookingId: string, 
    paymentData: {
      amount: number
      currency: string
      paymentId: string
      orderId: string
    }
  ) {
    return prisma.$transaction(async (tx) => {
      // 1. ğŸ” Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Booking
      const booking = await tx.booking.findUnique({
        where: { 
          id: bookingId,
          status: BOOKING_STATUS.DRAFT
        },
        include: { slot: true }
      })

      if (!booking) {
        throw new DomainError('BOOKING_NOT_FOUND')
      }

      if (booking.expiresAt && booking.expiresAt < new Date()) {
        throw new DomainError('BOOKING_EXPIRED')
      }

      // 2. ğŸ”’ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† orderId ÙØ±ÙŠØ¯
      const existingPayment = await tx.payment.findUnique({
        where: { orderId: paymentData.orderId }
      })

      if (existingPayment) {
        throw new DomainError('DUPLICATE_PAYMENT', 'ØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… orderId Ù…Ø³Ø¨Ù‚Ø§Ù‹')
      }

      // 3. ğŸ’³ Ø¥Ù†Ø´Ø§Ø¡ Payment
      const payment = await tx.payment.create({
        data: {
          bookingId,
          amount: paymentData.amount,
          currency: paymentData.currency,
          paymentId: paymentData.paymentId,
          orderId: paymentData.orderId,
          status: 'PROCESSING'
        }
      })

      // 4. ğŸ”„ ØªØ­Ø¯ÙŠØ« Booking
      const updatedBooking = await tx.booking.update({
        where: { id: bookingId },
        data: {
          status: BOOKING_STATUS.PENDING_PAYMENT,
          paymentStatus: PAYMENT_STATUS.PROCESSING,
          paymentId: paymentData.paymentId,
          orderId: paymentData.orderId
        }
      })

      return {
        booking: updatedBooking,
        payment
      }
    })
  }

  /**
   * âœ… Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ø­Ø¬Ø² Ø¨Ø¹Ø¯ Ù†Ø¬Ø§Ø­ Ø§Ù„Ø¯ÙØ¹
   */
  static async finalizeBooking(
    bookingId: string, 
    paymentSuccess: boolean,
    paymentDetails?: any
  ) {
    return prisma.$transaction(async (tx) => {
      const booking = await tx.booking.findUnique({
        where: { id: bookingId },
        include: { slot: true }
      })

      if (!booking) {
        throw new DomainError('BOOKING_NOT_FOUND')
      }

      if (paymentSuccess) {
        // âœ… Ù†Ø¬Ø§Ø­ Ø§Ù„Ø¯ÙØ¹
        await tx.booking.update({
          where: { id: bookingId },
          data: {
            status: BOOKING_STATUS.CONFIRMED,
            paymentStatus: PAYMENT_STATUS.PAID
          }
        })

        // âœ… ØªØ­Ø¯ÙŠØ« Slot Ù…Ø¹ ØªÙ†Ø¸ÙŠÙ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚ÙÙ„
        await tx.slot.update({
          where: { id: booking.slotId },
          data: {
            status: SLOT_STATUS.BOOKED,
            lockedByUserId: null, // ğŸ§¹ ØªÙ†Ø¸ÙŠÙ
            lockedUntil: null     // ğŸ§¹ ØªÙ†Ø¸ÙŠÙ
          }
        })

        // ğŸ“¨ Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø±
        await tx.notification.create({
          data: {
            userId: booking.userId,
            type: 'PAYMENT_SUCCESS',
            title: 'ØªÙ… Ø§Ù„Ø¯ÙØ¹ Ø¨Ù†Ø¬Ø§Ø­',
            message: `ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø­Ø¬Ø²Ùƒ ÙÙŠ ${booking.fieldId}`,
            relatedId: bookingId,
            data: paymentDetails
          }
        })
      } else {
        // âŒ ÙØ´Ù„ Ø§Ù„Ø¯ÙØ¹
        await tx.booking.update({
          where: { id: bookingId },
          data: {
            status: BOOKING_STATUS.FAILED,
            paymentStatus: PAYMENT_STATUS.FAILED
          }
        })

        // ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© Slot Ù„Ù…ØªØ§Ø­
        await tx.slot.update({
          where: { id: booking.slotId },
          data: { status: SLOT_STATUS.AVAILABLE }
        })

        // ğŸ“¨ Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„ÙØ´Ù„
        await tx.notification.create({
          data: {
            userId: booking.userId,
            type: 'PAYMENT_FAILED',
            title: 'ÙØ´Ù„ Ø§Ù„Ø¯ÙØ¹',
            message: 'ÙØ´Ù„Øª Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¯ÙØ¹ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰',
            relatedId: bookingId
          }
        })
      }

      return { success: true }
    })
  }

  /**
   * â° Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† ÙŠÙ…ÙƒÙ† Ø§Ù„Ø­Ø¬Ø² Ù…Ø¨Ø§Ø´Ø±Ø©
   */
  private static canBookDirectly(start: Date): boolean {
    const diffMs = start.getTime() - Date.now()
    const diffHours = diffMs / (1000 * 60 * 60)
    return diffHours >= 24
  }
}
5ï¸âƒ£ Booking Limits (Ù…ÙØµÙ„Ø­)
typescript
// lib/time-slots/booking-limits.ts

import { prisma } from '@/lib/prisma'
import { startOfDay, addDays } from 'date-fns'
import { DomainError } from '@/lib/errors/domain-errors'

export async function checkBookingLimits({
  userId,
  slotDate,
  slotDurationMin
}: {
  userId: string
  slotDate: Date
  slotDurationMin: number
}) {
  const dayStart = startOfDay(slotDate)
  const dayEnd = addDays(dayStart, 1)
  
  // Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ ÙŠØ¨Ø¯Ø£ Ù…Ù† Ø§Ù„Ø³Ø¨Øª (Ø­Ø³Ø¨ Ù…ØµØ±)
  const dayOfWeek = dayStart.getDay()
  const weekStart = addDays(dayStart, -dayOfWeek)
  const weekEnd = addDays(weekStart, 7)

  // 1ï¸âƒ£ Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ© - Ø§Ø­Ø³Ø¨ Ø§Ù„Ù…Ø¯Ø© Ø§Ù„ÙØ¹Ù„ÙŠØ©
  const dailyBookings = await prisma.booking.findMany({
    where: {
      userId,
      status: { in: ['CONFIRMED', 'PENDING_PAYMENT'] },
      slot: {
        startTime: { gte: dayStart, lt: dayEnd }
      }
    },
    include: {
      slot: {
        select: {
          startTime: true,
          endTime: true,
          durationMinutes: true
        }
      }
    }
  })

  // ğŸ“ Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¯Ø© Ø§Ù„ÙŠÙˆÙ…ÙŠØ© (Ø¨Ø§Ù„Ø¯Ù‚Ø§Ø¦Ù‚)
  const dailyMinutes = dailyBookings.reduce((sum, booking) => {
    // Ø§Ø³ØªØ®Ø¯Ù… durationMinutes Ø¥Ø°Ø§ Ù…ÙˆØ¬ÙˆØ¯ØŒ ÙˆØ¥Ù„Ø§ Ø§Ø­Ø³Ø¨ Ù…Ù† startTime Ùˆ endTime
    if (booking.slot.durationMinutes) {
      return sum + booking.slot.durationMinutes
    }
    
    // Ø§Ø­Ø³Ø¨ Ø§Ù„ÙØ±Ù‚ Ø¨ÙŠÙ† startTime Ùˆ endTime
    const start = new Date(booking.slot.startTime)
    const end = new Date(booking.slot.endTime)
    const diffMinutes = Math.round((end.getTime() - start.getTime()) / (1000 * 60))
    return sum + diffMinutes
  }, 0)

  if (dailyMinutes + slotDurationMin > 120) { // Ø³Ø§Ø¹ØªÙŠÙ† = 120 Ø¯Ù‚ÙŠÙ‚Ø©
    throw new DomainError('BOOKING_LIMIT_EXCEEDED', 'ÙˆØµÙ„Øª Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ø§Ù„ÙŠÙˆÙ…ÙŠ (Ø³Ø§Ø¹ØªÙŠÙ†)')
  }

  // 2ï¸âƒ£ Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ÙŠØ©
  const weeklyBookings = await prisma.booking.findMany({
    where: {
      userId,
      status: { in: ['CONFIRMED', 'PENDING_PAYMENT'] },
      slot: {
        startTime: { gte: weekStart, lt: weekEnd }
      }
    },
    include: {
      slot: {
        select: {
          startTime: true,
          endTime: true,
          durationMinutes: true
        }
      }
    }
  })

  // ğŸ“ Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¯Ø© Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ÙŠØ©
  const weeklyMinutes = weeklyBookings.reduce((sum, booking) => {
    if (booking.slot.durationMinutes) {
      return sum + booking.slot.durationMinutes
    }
    
    const start = new Date(booking.slot.startTime)
    const end = new Date(booking.slot.endTime)
    const diffMinutes = Math.round((end.getTime() - start.getTime()) / (1000 * 60))
    return sum + diffMinutes
  }, 0)

  if (weeklyMinutes + slotDurationMin > 240) { // 4 Ø³Ø§Ø¹Ø§Øª = 240 Ø¯Ù‚ÙŠÙ‚Ø©
    throw new DomainError('BOOKING_LIMIT_EXCEEDED', 'ÙˆØµÙ„Øª Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ÙŠ (4 Ø³Ø§Ø¹Ø§Øª)')
  }

  return true
}
6ï¸âƒ£ Lock Slot API (Ù…ÙØ­Ø³Ù‘Ù† Ø¶Ø¯ Race Conditions)
typescript
// app/api/fields/[fieldId]/slots/[slotId]/lock/route.ts

import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { prisma } from '@/lib/prisma'
import { authOptions } from '@/lib/auth'
import { addMinutes } from 'date-fns'
import { DomainError, errorResponse } from '@/lib/errors/domain-errors'
import { assertSlotCanLock } from '@/lib/guards/assertBookingState'

const LOCK_DURATION_MINUTES = 5

export async function POST(
  request: NextRequest,
  { params }: { params: { fieldId: string; slotId: string } }
) {
  try {
    const session = await getServerSession(authOptions)
    const userId = session?.user?.id

    if (!userId) {
      return NextResponse.json(
        { error: 'ØºÙŠØ± Ù…ØµØ±Ø­' },
        { status: 401 }
      )
    }

    const { slotId, fieldId } = params
    const now = new Date()

    const result = await prisma.$transaction(async (tx) => {
      // ğŸ” Lock Ø¢Ù…Ù† Ø¶Ø¯ Race Conditions
      const updateResult = await tx.slot.updateMany({
        where: {
          id: slotId,
          fieldId: fieldId,
          // âš ï¸ Ø§Ù„Ø´Ø±Ø· Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ: Ø¥Ù…Ø§ AVAILABLE Ø£Ùˆ TEMP_LOCKED Ù…Ù†ØªÙ‡ÙŠ
          OR: [
            {
              status: 'AVAILABLE'
            },
            {
              status: 'TEMP_LOCKED',
              OR: [
                { lockedUntil: null },
                { lockedUntil: { lt: now } }
              ]
            }
          ]
        },
        data: {
          status: 'TEMP_LOCKED',
          lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES),
          lockedByUserId: userId
        }
      })

      if (updateResult.count === 0) {
        // ğŸ” Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø³Ø¨Ø¨
        const slot = await tx.slot.findUnique({
          where: { id: slotId }
        })

        if (!slot) {
          throw new DomainError('SLOT_NOT_FOUND')
        }

        if (slot.status === 'BOOKED') {
          throw new DomainError('SLOT_ALREADY_BOOKED')
        }

        if (slot.status === 'TEMP_LOCKED' && slot.lockedUntil && slot.lockedUntil > now) {
          if (slot.lockedByUserId === userId) {
            // ğŸ‘¤ Ù†ÙØ³ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… - Ù†Ù…Ø¯Ø¯ Ø§Ù„Ù‚ÙÙ„
            await tx.slot.update({
              where: { id: slotId },
              data: {
                lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES)
              }
            })
            return { success: true, extended: true }
          } else {
            throw new DomainError('SLOT_LOCKED_BY_OTHER')
          }
        }

        throw new DomainError('SLOT_CANNOT_BE_LOCKED')
      }

      return { success: true, locked: true }
    })

    return NextResponse.json(result)
  } catch (error: any) {
    console.error('Lock error:', error)
    return errorResponse(error)
  }
}
7ï¸âƒ£ Webhook Paymob (Ù…ÙØ­Ø³Ù‘Ù† Ø¨Ø§Ù„Ø£Ù…Ø§Ù†)
typescript
// app/api/webhooks/paymob/route.ts

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { BookingOrchestrator } from '@/lib/booking/orchestrator'
import { paymobHmacVerifier } from '@/lib/paymob/hmac-verifier'
import { DomainError, errorResponse } from '@/lib/errors/domain-errors'

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const hmac = request.headers.get('hmac')
    
    if (!hmac) {
      return NextResponse.json(
        { error: 'HMAC header missing' },
        { status: 401 }
      )
    }

    // 1ï¸âƒ£ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† HMAC
    if (!paymobHmacVerifier.verify(body.obj, hmac)) {
      console.error('Invalid HMAC signature')
      return NextResponse.json(
        { error: 'Invalid HMAC signature' },
        { status: 401 }
      )
    }

    // 2ï¸âƒ£ Replay Attack Protection
    if (!paymobHmacVerifier.isFresh(body.obj.created_at)) {
      return NextResponse.json(
        { error: 'Expired webhook request' },
        { status: 400 }
      )
    }

    const {
      success,
      amount_cents,
      id: transactionId,
      order: { id: orderId, merchant_order_id: bookingId },
      created_at,
      currency = 'EGP'
    } = body.obj

    // 3ï¸âƒ£ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø­Ø¬Ø² Ø§Ù„Ù…Ø±ØªØ¨Ø·
    const booking = await prisma.booking.findUnique({
      where: { id: bookingId },
      include: { slot: true, field: true }
    })

    if (!booking) {
      console.error('Booking not found:', bookingId)
      return NextResponse.json(
        { error: 'Booking not found' },
        { status: 404 }
      )
    }

    // 4ï¸âƒ£ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† orderId ÙØ±ÙŠØ¯ ÙˆÙ„Ù… ÙŠØªÙ… Ù…Ø¹Ø§Ù„Ø¬ØªÙ‡
    const existingPayment = await prisma.payment.findUnique({
      where: { orderId: orderId.toString() }
    })

    if (existingPayment) {
      console.log('Webhook already processed for order:', orderId)
      return NextResponse.json(
        { success: true, message: 'Already processed' }
      )
    }

    // 5ï¸âƒ£ Ø¥Ù†Ø´Ø§Ø¡ Ø³Ø¬Ù„ Ø§Ù„Ø¯ÙØ¹ Ø£ÙˆÙ„Ø§Ù‹
    const payment = await prisma.payment.create({
      data: {
        bookingId,
        amount: amount_cents / 100,
        currency,
        paymentId: transactionId.toString(),
        orderId: orderId.toString(),
        status: success ? 'PROCESSING' : 'FAILED',
        metadata: body.obj
      }
    })

    // 6ï¸âƒ£ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø­Ø¬Ø²
    await BookingOrchestrator.finalizeBooking(
      bookingId,
      success,
      {
        transactionId,
        amount: amount_cents / 100,
        currency
      }
    )

    // 7ï¸âƒ£ ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø¯ÙØ¹
    await prisma.payment.update({
      where: { id: payment.id },
      data: {
        status: success ? 'PAID' : 'FAILED'
      }
    })

    console.log(`Payment ${success ? 'successful' : 'failed'} for booking ${bookingId}`)
    return NextResponse.json({ success: true })

  } catch (error) {
    console.error('Webhook processing error:', error)
    return errorResponse(error)
  }
}
8ï¸âƒ£ Get Slots API (Ø§Ù„Ø¬Ø¯ÙŠØ¯)
typescript
// app/api/fields/[fieldId]/slots/route.ts

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { generateSlotsForDay } from '@/lib/time-slots/core-logic'
import { getUISlots } from '@/lib/slots/read-model'
import { FIELD_STATUS } from '@/lib/constants/status'
import { DomainError, errorResponse } from '@/lib/errors/domain-errors'

export async function GET(
  request: NextRequest,
  { params }: { params: { fieldId: string } }
) {
  try {
    const fieldId = params.fieldId
    const { searchParams } = new URL(request.url)
    const dateParam = searchParams.get('date')

    if (!fieldId) {
      throw new DomainError('VALIDATION_ERROR', 'Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ù„Ø¹Ø¨ Ù…Ø·Ù„ÙˆØ¨')
    }

    if (!dateParam) {
      throw new DomainError('VALIDATION_ERROR', 'Ø§Ù„ØªØ§Ø±ÙŠØ® Ù…Ø·Ù„ÙˆØ¨')
    }

    const date = new Date(dateParam)
    if (isNaN(date.getTime())) {
      throw new DomainError('VALIDATION_ERROR', 'ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ø±ÙŠØ® ØºÙŠØ± ØµØ§Ù„Ø­')
    }

    // ğŸ” Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ù„Ø¹Ø¨
    const field = await prisma.field.findUnique({
      where: { id: fieldId }
    })

    if (!field) {
      throw new DomainError('FIELD_NOT_FOUND', 'Ø§Ù„Ù…Ù„Ø¹Ø¨ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯')
    }

    // ğŸš« ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ù„Ø¹Ø¨
    if (field.status === FIELD_STATUS.CLOSED) {
      return NextResponse.json({
        slots: [],
        field,
        message: 'Ø§Ù„Ù…Ù„Ø¹Ø¨ Ù…ØºÙ„Ù‚ Ø­Ø§Ù„ÙŠØ§Ù‹'
      })
    }

    if (field.status === FIELD_STATUS.MAINTENANCE) {
      return NextResponse.json({
        slots: [],
        field,
        message: 'Ø§Ù„Ù…Ù„Ø¹Ø¨ ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©'
      })
    }

    // ğŸ§¹ ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù€ Locks Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ©
    await prisma.slot.updateMany({
      where: {
        fieldId,
        status: 'TEMP_LOCKED',
        lockedUntil: { lt: new Date() }
      },
      data: {
        status: 'AVAILABLE',
        lockedByUserId: null,
        lockedUntil: null
      }
    })

    // ğŸ¯ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù€ Slots
    const slots = await generateSlotsForDay({
      fieldId,
      date,
      now: new Date()
    })

    // ğŸ‘ï¸ ØªØ­ÙˆÙŠÙ„ Ù„Ù€ UI Slots
    const uiSlots = getUISlots(slots)

    return NextResponse.json({
      success: true,
      field: {
        id: field.id,
        name: field.name,
        description: field.description,
        status: field.status,
        pricePerHour: field.pricePerHour,
        depositPrice: field.depositPrice,
        openingTime: field.openingTime,
        closingTime: field.closingTime
      },
      slots: uiSlots,
      date: date.toISOString().split('T')[0]
    })

  } catch (error) {
    console.error('Get slots error:', error)
    return errorResponse(error)
  }
}
9ï¸âƒ£ ØµÙØ­Ø© Field Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ© (Ù…ÙØ¹Ø¯Ù‘Ù„Ø©)
tsx
// app/fields/[fieldId]/page.tsx
'use client'

import { useState, useEffect } from 'react'
import { useSession } from 'next-auth/react'
import { useParams, useRouter } from 'next/navigation'
import DaySelector from '@/app/components/booking/day-selector'
import SlotGrid from '@/app/components/booking/slot-grid'
import { generateNextDays } from '@/lib/time-slots/core-logic'
import { IdempotencyGuard } from '@/lib/idempotency/idempotency-guard'
import { ArrowLeft, Loader2, AlertCircle } from 'lucide-react'

interface Field {
  id: string
  name: string
  description?: string
  status: string
  pricePerHour: number
  depositPrice: number
  openingTime: string
  closingTime: string
}

export default function FieldPage() {
  const { data: session } = useSession()
  const params = useParams()
  const router = useRouter()
  const fieldId = params.fieldId as string

  const [selectedDate, setSelectedDate] = useState<Date>(new Date())
  const [slots, setSlots] = useState<any[]>([])
  const [field, setField] = useState<Field | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  
  const days = generateNextDays(10)

  useEffect(() => {
    if (fieldId) {
      fetchSlots()
    }
  }, [selectedDate, fieldId])

  const fetchSlots = async () => {
    try {
      setLoading(true)
      setError(null)
      
      const dateStr = selectedDate.toISOString().split('T')[0]
      const res = await fetch(`/api/fields/${fieldId}/slots?date=${dateStr}`)
      const data = await res.json()
      
      if (!res.ok) {
        throw new Error(data.error || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯')
      }
      
      setSlots(data.slots || [])
      setField(data.field)
    } catch (err: any) {
      console.error('Error fetching slots:', err)
      setError(err.message || 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª')
    } finally {
      setLoading(false)
    }
  }

  const handleSlotSelect = async (slot: any) => {
    if (!session) {
      router.push('/login')
      return
    }

    // ğŸ« ØªÙˆÙ„ÙŠØ¯ Idempotency Key Ø¢Ù…Ù†
    const idempotencyKey = IdempotencyGuard.generateKey('booking')
    
    try {
      // 1. Ù‚ÙÙ„ Ø§Ù„Ù€ Slot
      const lockRes = await fetch(`/api/fields/${fieldId}/slots/${slot.id}/lock`, {
        method: 'POST'
      })

      if (!lockRes.ok) {
        const error = await lockRes.json()
        throw new Error(error.error || 'ÙØ´Ù„ ÙÙŠ Ù‚ÙÙ„ Ø§Ù„Ù…ÙˆØ¹Ø¯')
      }

      // 2. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø¬Ø²
      const bookingRes = await fetch('/api/bookings', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          slotId: slot.id,
          fieldId,
          idempotencyKey
        })
      })

      const bookingData = await bookingRes.json()

      if (!bookingRes.ok) {
        throw new Error(bookingData.error || 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø¬Ø²')
      }

      if (slot.metadata?.needsConfirmation) {
        alert('ØªÙ… ØªÙ‚Ø¯ÙŠÙ… Ø·Ù„Ø¨ Ø§Ù„Ø­Ø¬Ø² Ø¨Ù†Ø¬Ø§Ø­! Ø³ÙŠØªÙ… ØªØ£ÙƒÙŠØ¯Ù‡ Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ù…ÙˆØ¸Ù.')
        router.push('/bookings')
      } else {
        router.push(`/payment/${bookingData.bookingId}`)
      }
    } catch (err: any) {
      console.error('Booking error:', err)
      alert(err.message || 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­Ø¬Ø²')
    }
  }

  if (loading && !field) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <Loader2 className="w-8 h-8 animate-spin text-blue-600" />
      </div>
    )
  }

  if (error) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <AlertCircle className="w-12 h-12 text-red-500 mx-auto mb-4" />
          <h2 className="text-xl font-semibold text-gray-900 mb-2">Ø­Ø¯Ø« Ø®Ø·Ø£</h2>
          <p className="text-gray-600 mb-4">{error}</p>
          <button
            onClick={() => router.back()}
            className="flex items-center gap-2 text-blue-600 hover:text-blue-800"
          >
            <ArrowLeft className="w-4 h-4" />
            Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø®Ù„Ù
          </button>
        </div>
      </div>
    )
  }

  if (!field) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <h2 className="text-xl font-semibold text-gray-900 mb-2">Ø§Ù„Ù…Ù„Ø¹Ø¨ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯</h2>
          <button
            onClick={() => router.push('/')}
            className="text-blue-600 hover:text-blue-800"
          >
            Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
          </button>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="container mx-auto px-4 py-8">
        {/* Header */}
        <header className="mb-8">
          <button
            onClick={() => router.back()}
            className="flex items-center gap-2 text-gray-600 hover:text-gray-900 mb-4"
          >
            <ArrowLeft className="w-5 h-5" />
            Ø§Ù„Ø¹ÙˆØ¯Ø©
          </button>
          
          <h1 className="text-3xl font-bold text-gray-900">{field.name}</h1>
          {field.description && (
            <p className="text-gray-600 mt-2">{field.description}</p>
          )}
          
          <div className="flex flex-wrap items-center gap-4 mt-4">
            <span className="bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm font-medium">
              {field.pricePerHour} Ø¬.Ù…/Ø³Ø§Ø¹Ø©
            </span>
            <span className="text-gray-600">
              Ù…ÙˆØ§Ø¹ÙŠØ¯ Ø§Ù„Ø¹Ù…Ù„: {field.openingTime} - {field.closingTime}
            </span>
            {field.status === 'CLOSED' && (
              <span className="bg-red-100 text-red-800 px-3 py-1 rounded-full text-sm">
                Ù…ØºÙ„Ù‚ Ø­Ø§Ù„ÙŠØ§Ù‹
              </span>
            )}
          </div>
        </header>

        {/* Content */}
        <div className="bg-white rounded-2xl shadow-lg p-6">
          <DaySelector
            days={days}
            selectedDate={selectedDate}
            onSelectDate={setSelectedDate}
          />

          {loading ? (
            <div className="text-center py-12">
              <Loader2 className="w-8 h-8 animate-spin text-blue-600 mx-auto" />
              <p className="mt-4 text-gray-600">Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯...</p>
            </div>
          ) : (
            <SlotGrid
              slots={slots}
              fieldId={fieldId}
              fieldName={field.name}
              userId={session?.user?.id}
              onSlotSelect={handleSlotSelect}
            />
          )}

          {/* Booking Rules */}
          <div className="mt-8 pt-6 border-t border-gray-200">
            <h3 className="font-semibold text-gray-900 mb-3">Ø´Ø±ÙˆØ· Ø§Ù„Ø­Ø¬Ø²:</h3>
            <ul className="space-y-2 text-sm text-gray-600">
              <li className="flex items-start gap-2">
                <span className="text-green-600">âœ“</span>
                <span>Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø­Ø¬Ø² Ø§Ù„ÙŠÙˆÙ…ÙŠ: Ø³Ø§Ø¹ØªÙŠÙ†</span>
              </li>
              <li className="flex items-start gap-2">
                <span className="text-green-600">âœ“</span>
                <span>Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø­Ø¬Ø² Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ÙŠ: 4 Ø³Ø§Ø¹Ø§Øª</span>
              </li>
              <li className="flex items-start gap-2">
                <span className="text-green-600">âœ“</span>
                <span>Ø§Ù„Ø­Ø¬Ø² Ù‚Ø¨Ù„ 24 Ø³Ø§Ø¹Ø© ÙŠØ­ØªØ§Ø¬ ØªØ£ÙƒÙŠØ¯ Ù…Ù† Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©</span>
              </li>
              <li className="flex items-start gap-2">
                <span className="text-green-600">âœ“</span>
                <span>Ø§Ù„Ù…ÙˆØ¹Ø¯ ÙŠØ¨Ù‚Ù‰ Ù…Ø­Ø¬ÙˆØ²Ø§Ù‹ Ù„Ùƒ Ù„Ù…Ø¯Ø© 5 Ø¯Ù‚Ø§Ø¦Ù‚ Ù„Ø¥ØªÙ…Ø§Ù… Ø§Ù„Ø­Ø¬Ø²</span>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  )
}
ğŸ”Ÿ Bookings API Ù…Ø¹ Pagination (Ù…ÙØ­Ø³Ù‘Ù†)
typescript
// app/api/bookings/route.ts

import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { prisma } from '@/lib/prisma'
import { authOptions } from '@/lib/auth'
import { BookingOrchestrator } from '@/lib/booking/orchestrator'
import { IdempotencyGuard } from '@/lib/idempotency/idempotency-guard'
import { DomainError, errorResponse } from '@/lib/errors/domain-errors'
import { BOOKING_STATUS } from '@/lib/constants/status'

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    const userId = session?.user?.id

    if (!userId) {
      throw new DomainError('UNAUTHORIZED')
    }

    const { searchParams } = new URL(request.url)
    const page = parseInt(searchParams.get('page') || '1')
    const limit = Math.min(parseInt(searchParams.get('limit') || '20'), 50) // ğŸ›¡ï¸ Ø­Ø¯ Ø£Ù‚ØµÙ‰ 50
    const status = searchParams.get('status')
    const skip = (page - 1) * limit

    // ğŸ¯ Ø¨Ù†Ø§Ø¡ where clause
    const where: any = { userId }
    
    if (status) {
      where.status = status
    } else {
      // Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ: Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©
      where.status = {
        in: [BOOKING_STATUS.CONFIRMED, BOOKING_STATUS.PENDING_PAYMENT]
      }
    }

    // ğŸ” Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ pagination
    const [bookings, total] = await Promise.all([
      prisma.booking.findMany({
        where,
        include: {
          field: {
            select: {
              id: true,
              name: true,
              pricePerHour: true
            }
          },
          slot: {
            select: {
              id: true,
              startTime: true,
              endTime: true,
              durationMinutes: true
            }
          },
          payments: {
            take: 1,
            orderBy: { createdAt: 'desc' }
          }
        },
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit
      }),
      prisma.booking.count({ where })
    ])

    return NextResponse.json({
      success: true,
      data: bookings,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
        hasMore: page * limit < total
      }
    })

  } catch (error) {
    console.error('Get bookings error:', error)
    return errorResponse(error)
  }
}

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    const userId = session?.user?.id

    if (!userId) {
      throw new DomainError('UNAUTHORIZED')
    }

    const { slotId, fieldId, idempotencyKey } = await request.json()

    if (!slotId || !fieldId) {
      throw new DomainError('VALIDATION_ERROR', 'Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø¬Ø² ØºÙŠØ± Ù…ÙƒØªÙ…Ù„Ø©')
    }

    // ğŸ” Ø§Ø³ØªØ®Ø¯Ø§Ù… Idempotency Key Ø§Ù„Ù…Ù‚Ø¯Ù… Ø£Ùˆ ØªÙˆÙ„ÙŠØ¯ ÙˆØ§Ø­Ø¯ Ø¬Ø¯ÙŠØ¯
    const finalKey = idempotencyKey || IdempotencyGuard.generateKey('booking')

    const result = await BookingOrchestrator.initiateBooking({
      userId,
      slotId,
      fieldId,
      idempotencyKey: finalKey
    })

    return NextResponse.json({
      success: true,
      ...result,
      idempotencyKey: finalKey // ğŸ”‘ Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ù…ÙØªØ§Ø­ Ù„Ù„Ø¹Ù…ÙŠÙ„
    })

  } catch (error) {
    console.error('Create booking error:', error)
    return errorResponse(error)
  }
}
