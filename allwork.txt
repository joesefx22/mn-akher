{
  "name": "sport-fields-booking",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "db:generate": "prisma generate",
    "db:push": "prisma db push",
    "db:migrate": "prisma migrate dev",
    "db:studio": "prisma studio",
    "db:seed": "tsx prisma/seed.ts",
    "typecheck": "tsc --noEmit",
    "fix": "rm -rf node_modules/.prisma node_modules/@prisma && npx prisma generate"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.10.0",
    "@prisma/client": "^5.10.2",
    "@tailwindcss/aspect-ratio": "^0.4.2",
    "@tailwindcss/forms": "^0.5.11",
    "@tailwindcss/typography": "^0.5.19",
    "@upstash/redis": "^1.36.1",
    "axios": "^1.13.2",
    "bcryptjs": "^2.4.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^3.6.0",
    "dotenv": "^16.6.1",
    "lucide-react": "^0.447.0",
    "next": "^15.5.9",
    "next-auth": "^4.24.13",
    "pino": "^9.14.0",
    "pino-pretty": "^11.3.0",
    "rate-limiter-flexible": "^5.0.5",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.71.0",
    "react-hot-toast": "^2.6.0",
    "react-icons": "^5.5.0",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "uuid": "^9.0.1",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/node": "^18.19.0",
    "@types/react": "^18.3.27",
    "@types/react-dom": "^18.3.7",
    "@types/uuid": "^10.0.0",
    "autoprefixer": "^10.4.23",
    "eslint": "^8.57.0",
    "eslint-config-next": "^15.5.9",
    "postcss": "^8.5.6",
    "prisma": "^5.10.2",
    "tailwindcss": "^3.4.19",
    "tsx": "^4.19.2",
    "typescript": "^5.4.5"
  },
  "engines": {
    "node": ">=18.17.0"
  }
}
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//////////////////// ENUMS ////////////////////

enum Role {
  PLAYER
  OWNER
  EMPLOYEE
  ADMIN
}

enum SkillLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
}

enum FieldType {
  FOOTBALL
  PADEL
  TENNIS
  BASKETBALL
  SWIMMING
}

enum FieldStatus {
  OPEN
  CLOSED
  MAINTENANCE
  UNDER_CONSTRUCTION
}

enum SlotStatus {
  AVAILABLE
  NEEDS_CONFIRMATION
  TEMP_LOCKED
  BOOKED
  UNAVAILABLE
  CANCELLED
}

enum BookingStatus {
  DRAFT
  PENDING_CONFIRMATION
  CONFIRMED
  CANCELLED
  FAILED
  EXPIRED
  PENDING_PAYMENT
  COMPLETED
}

enum PaymentStatus {
  PENDING
  PROCESSING
  PAID
  FAILED
  REFUNDED
  PARTIALLY_REFUNDED
  CANCELLED
}

enum NotificationType {
  SYSTEM
  BOOKING_CREATED
  BOOKING_CONFIRMED
  BOOKING_CANCELLED
  BOOKING_EXPIRED
  PAYMENT_INITIATED
  PAYMENT_SUCCESS
  PAYMENT_FAILED
  PAYMENT_REFUNDED
  SLOT_LOCKED
  SLOT_RELEASED
  USER_WELCOME
  PASSWORD_RESET
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  REGISTER
  PASSWORD_CHANGE
  PROFILE_UPDATE
}

//////////////////// USER ////////////////////

model User {
  id            String   @id @default(cuid())
  // Personal Info
  name          String
  email         String   @unique
  passwordHash  String
  phone         String?  @unique
  dateOfBirth   DateTime?
  avatarUrl     String?
  bio           String?  @db.Text
  
  // Skills & Preferences
  skillLevel    SkillLevel @default(BEGINNER)
  preferredPositions String[]
  
  // Role & Permissions
  role          Role @default(PLAYER)
  roleAssignedAt DateTime?
  
  // Auth & Security
  emailVerified Boolean   @default(false)
  emailVerifiedAt DateTime?
  isActive      Boolean   @default(true)
  lastLoginAt   DateTime?
  loginAttempts Int       @default(0)
  lockedUntil   DateTime?
  
  // Timestamps
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  deletedAt     DateTime?
  
  // üîó Relations
  bookings        Booking[]
  lockedSlots     Slot[]       @relation("SlotLockedByUser")
  notifications   Notification[]
  reviews         Review[]
  payments        Payment[]
  auditLogs       AuditLog[]
  idempotencyKeys IdempotencyKey[]
  
  // Indexes
  @@index([email, isActive])
  @@index([role, isActive])
  @@index([createdAt])
  @@map("users")
}

//////////////////// FIELD ////////////////////

model Field {
  id          String   @id @default(cuid())
  // Basic Info
  name        String
  description String?  @db.Text
  location    String
  address     String
  coordinates String?
  
  // Type & Media
  type        FieldType
  mainImage   String?
  gallery     String[]
  
  // Pricing
  pricePerHour    Decimal @db.Decimal(10, 2)
  depositAmount   Decimal @db.Decimal(10, 2) @default(0)
  currency        String  @default("EGP")
  
  // Schedule
  openingTime     String  @default("08:00")
  closingTime     String  @default("22:00")
  slotDuration    Int     @default(60)
  
  // Status & Facilities
  status          FieldStatus @default(OPEN)
  facilities      String[]
  capacity        Int?
  
  // Contact
  ownerId         String?
  ownerEmail      String?
  ownerPhone      String?
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // üîó Relations
  slots    Slot[]
  bookings Booking[]
  reviews  Review[]
  
  // Indexes
  @@index([location])
  @@index([type, status])
  @@index([pricePerHour])
  @@map("fields")
}

//////////////////// SLOT ////////////////////

model Slot {
  id      String   @id @default(cuid())
  
  // Field Relation
  fieldId String
  field   Field  @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  
  // Timing
  startTime   DateTime
  endTime     DateTime
  duration    Int     @default(60)
  
  // Pricing
  price       Decimal @db.Decimal(10, 2)
  deposit     Decimal @db.Decimal(10, 2) @default(0)
  
  // Status & Locking
  status      SlotStatus @default(AVAILABLE)
  lockedUntil DateTime?
  lockedById  String?
  lockedBy    User?     @relation("SlotLockedByUser", fields: [lockedById], references: [id], onDelete: SetNull)
  
  // Metadata
  isPeakHour  Boolean @default(false)
  discount    Decimal @db.Decimal(5, 2) @default(0)
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // üîó Relations
  bookings Booking[]
  
  // Constraints & Indexes
  @@unique([fieldId, startTime])
  @@index([status, lockedUntil])
  @@index([startTime, endTime])
  @@index([fieldId, status])
  @@map("slots")
}

//////////////////// BOOKING ////////////////////

model Booking {
  id String @id @default(cuid())
  
  // User Relation
  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Field & Slot Relations
  fieldId String
  field   Field @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  
  slotId String
  slot   Slot @relation(fields: [slotId], references: [id], onDelete: Cascade)
  
  // Status
  status        BookingStatus @default(DRAFT)
  paymentStatus PaymentStatus @default(PENDING)
  
  // Pricing
  totalAmount   Decimal @db.Decimal(10, 2)
  amountPaid    Decimal @db.Decimal(10, 2) @default(0)
  depositPaid   Decimal @db.Decimal(10, 2) @default(0)
  
  // Payment & Order Info
  orderId       String? @unique
  paymentId     String?
  gateway       String?
  
  // Timing
  expiresAt       DateTime?
  confirmedAt     DateTime?
  cancelledAt     DateTime?
  completedAt     DateTime?
  
  // Idempotency & Tracking
  idempotencyKey String? @unique
  ipAddress      String?
  userAgent      String?
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // üîó Relations
  payments      Payment[]
  notifications Notification[]
  
  // Indexes
  @@index([userId, status])
  @@index([slotId, status])
  @@index([orderId])
  @@index([createdAt])
  @@index([expiresAt])
  @@map("bookings")
}

//////////////////// PAYMENT ////////////////////

model Payment {
  id String @id @default(cuid())
  
  // Relations
  bookingId String
  booking   Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  
  userId    String
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Amount & Currency
  amount      Decimal @db.Decimal(10, 2)
  currency    String  @default("EGP")
  feeAmount   Decimal @db.Decimal(10, 2) @default(0)
  netAmount   Decimal @db.Decimal(10, 2)
  
  // Gateway Info
  gateway       String
  gatewayId     String? @unique
  orderId       String? @unique
  transactionId String? @unique
  
  // Status
  status      PaymentStatus @default(PENDING)
  refundedAmount Decimal @db.Decimal(10, 2) @default(0)
  
  // Metadata
  metadata    Json?
  receiptUrl  String?
  errorMessage String?
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  paidAt      DateTime?
  refundedAt  DateTime?
  
  // Indexes
  @@index([bookingId])
  @@index([userId])
  @@index([gatewayId])
  @@index([status, createdAt])
  @@map("payments")
}

//////////////////// NOTIFICATION ////////////////////

model Notification {
  id        String   @id @default(cuid())
  
  // User Relation
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Optional Booking Relation
  bookingId String?
  booking   Booking? @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  
  // Content
  type    NotificationType
  title   String
  message String  @db.Text
  data    Json?
  
  // Status
  isRead    Boolean   @default(false)
  isSent    Boolean   @default(true)
  sentAt    DateTime  @default(now())
  
  // Channels
  sentVia   String[]
  
  // Timestamps
  createdAt DateTime @default(now())
  readAt    DateTime?
  
  // Indexes
  @@index([userId, isRead])
  @@index([bookingId])
  @@index([type, createdAt])
  @@map("notifications")
}

//////////////////// REVIEW ////////////////////

model Review {
  id        String   @id @default(cuid())
  
  // Relations
  fieldId   String
  field     Field    @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  bookingId String?
  booking   Booking? @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  
  // Review Content
  rating    Int      @default(5)
  title     String?
  comment   String?  @db.Text
  
  // Metadata
  isVerified Boolean @default(false)
  helpfulVotes Int    @default(0)
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Constraints & Indexes
  @@unique([fieldId, userId, bookingId])
  @@index([fieldId, rating])
  @@index([userId])
  @@index([createdAt])
  @@map("reviews")
}

//////////////////// IDEMPOTENCY KEY ////////////////////

model IdempotencyKey {
  id          String   @id @default(cuid())
  
  // Key & User
  key         String
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Request Info
  requestHash String
  method      String
  path        String
  response    Json?
  
  // Expiry
  expiresAt   DateTime
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Constraints
  @@unique([key, userId])
  @@index([expiresAt])
  @@map("idempotency_keys")
}

//////////////////// AUDIT LOG ////////////////////

model AuditLog {
  id String @id @default(cuid())
  
  // User
  userId String?
  user   User? @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  // Action Details
  action     AuditAction
  entityType String?
  entityId   String?
  
  // Changes
  oldData    Json?
  newData    Json?
  
  // Request Info
  ipAddress  String?
  userAgent  String?
  endpoint   String?
  
  // Metadata
  success    Boolean @default(true)
  errorMessage String?
  
  // Timestamps
  createdAt DateTime @default(now())
  
  // Indexes
  @@index([userId, createdAt])
  @@index([action, entityType])
  @@index([createdAt])
  @@map("audit_logs")
}

//////////////////// FLAGGED USER ////////////////////

model FlaggedUser {
  id     String @id @default(cuid())
  
  // User
  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Flag Details
  reason    String   @db.Text
  category  String
  severity  String   @default("MEDIUM")
  
  // Resolution
  resolved   Boolean  @default(false)
  resolvedAt DateTime?
  resolvedBy String?
  resolutionNote String? @db.Text
  
  // Expiry
  expiresAt DateTime?
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Indexes
  @@index([userId, resolved])
  @@index([severity, createdAt])
  @@map("flagged_users")
}

import { DefaultSession, DefaultUser } from "next-auth"
import { JWT } from "next-auth/jwt"

export type SkillLevel = "WEAK" | "AVERAGE" | "GOOD" | "EXCELLENT" | "LEGENDARY"

declare module "next-auth" {
  interface User extends DefaultUser {
    id: string
    role: "PLAYER" | "OWNER" | "EMPLOYEE" | "ADMIN"
    email: string
    name?: string | null
    phoneNumber?: string | null
    age?: number | null
    description?: string | null
    skillLevel?: SkillLevel
    isActive?: boolean
    isVerified?: boolean
    lastLogin?: Date | null
  }

  interface Session {
    user: {
      id: string
      role: "PLAYER" | "OWNER" | "EMPLOYEE" | "ADMIN"
      email?: string | null
      name?: string | null
      phoneNumber?: string | null
      age?: number | null
      skillLevel?: SkillLevel
      isActive?: boolean
      isVerified?: boolean
      lastLogin?: Date | null
    } & DefaultSession["user"]
  }
}

declare module "next-auth/jwt" {
  interface JWT {
    id: string
    role: "PLAYER" | "OWNER" | "EMPLOYEE" | "ADMIN"
    phoneNumber?: string | null
    skillLevel?: SkillLevel
    isActive?: boolean
    isVerified?: boolean
    lastLogin?: Date | null
  }
}
// lib/shared/utils/index.ts

export const ROLES = {
  PLAYER: 'PLAYER',
  OWNER: 'OWNER',
  EMPLOYEE: 'EMPLOYEE',
  ADMIN: 'ADMIN'
} as const

export const TOKEN_TYPES = {
  EMAIL_VERIFICATION: 'EMAIL_VERIFICATION',
  PASSWORD_RESET: 'PASSWORD_RESET',
  REFRESH_TOKEN: 'REFRESH_TOKEN'
} as const

export const AUDIT_ACTIONS = {
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT',
  REGISTER: 'REGISTER',
  UPDATE_PROFILE: 'UPDATE_PROFILE',
  CHANGE_PASSWORD: 'CHANGE_PASSWORD',
  VERIFY_EMAIL: 'VERIFY_EMAIL',
  RESET_PASSWORD: 'RESET_PASSWORD',
  DELETE_ACCOUNT: 'DELETE_ACCOUNT'
} as const

export const ERROR_CODES = {
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  AUTHENTICATION_ERROR: 'AUTHENTICATION_ERROR',
  AUTHORIZATION_ERROR: 'AUTHORIZATION_ERROR',
  NOT_FOUND: 'NOT_FOUND',
  CONFLICT: 'CONFLICT',
  RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',
  TOKEN_EXPIRED: 'TOKEN_EXPIRED',
  INVALID_TOKEN: 'INVALID_TOKEN',
  SERVER_ERROR: 'SERVER_ERROR'
} as const

export const PASSWORD_POLICY = {
  MIN_LENGTH: 8,
  REQUIRE_UPPERCASE: true,
  REQUIRE_LOWERCASE: true,
  REQUIRE_NUMBER: true,
  REQUIRE_SPECIAL_CHAR: true
} as const

export const RATE_LIMITS = {
  LOGIN: {
    WINDOW_MS: 15 * 60 * 1000, // 15 minutes
    MAX_ATTEMPTS: 5
  },
  REGISTER: {
    WINDOW_MS: 60 * 60 * 1000, // 1 hour
    MAX_ATTEMPTS: 3
  },
  FORGOT_PASSWORD: {
    WINDOW_MS: 60 * 60 * 1000, // 1 hour
    MAX_ATTEMPTS: 3
  }
} as const

// ‚úÖ ÿ£ÿ∂ŸÅ ÿßŸÑŸÄ cn ŸáŸÜÿß
export function cn(...classes: (string | undefined | null | false)[]) {
  return classes.filter(Boolean).join(" ");
}
// lib/shared/rate-limit/index.ts
export class RateLimitService {
  private requests = new Map<string, { count: number; resetTime: number }>();

  check(key: string, limit: number, windowMs: number): boolean {
    const now = Date.now();
    const record = this.requests.get(key);

    if (!record || now > record.resetTime) {
      // New window
      this.requests.set(key, {
        count: 1,
        resetTime: now + windowMs
      });
      return true;
    }

    if (record.count >= limit) {
      return false;
    }

    record.count++;
    return true;
  }
}

export const rateLimitService = new RateLimitService();

// lib/shared/logger/index.ts
import pino from 'pino'

// ÿ•ŸÜÿ¥ÿßÿ° logger ÿ£ÿ≥ÿßÿ≥Ÿä
export const logger = pino({
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  transport: {
    target: 'pino-pretty',
    options: {
      colorize: true,
      translateTime: 'HH:MM:ss',
      ignore: 'pid,hostname'
    }
  }
})

// Loggers ŸÖÿ™ÿÆÿµÿµÿ©
export const authLogger = logger.child({ module: 'auth' })
export const bookingLogger = logger.child({ module: 'booking' })
export const paymentLogger = logger.child({ module: 'payment' })
export const apiLogger = logger.child({ module: 'api' })
export const cronLogger = logger.child({ module: 'cron' })

// ÿØÿßŸÑÿ© ŸÖÿ≥ÿßÿπÿØÿ© ŸÑŸÑŸÄ console.log ŸÅŸä development
export const devLogger = {
  log: (...args: any[]) => {
    if (process.env.NODE_ENV !== 'production') {
      console.log('[DEV]', ...args)
    }
  },
  error: (...args: any[]) => {
    if (process.env.NODE_ENV !== 'production') {
      console.error('[DEV ERROR]', ...args)
    }
  },
  warn: (...args: any[]) => {
    if (process.env.NODE_ENV !== 'production') {
      console.warn('[DEV WARN]', ...args)
    }
  }
}
// lib/shared/helpers/api-auth.ts
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'

/**
 * =========================
 * Custom Auth Errors
 * =========================
 */

export class AuthError extends Error {
  status: number
  code: string

  constructor(
    message: string = 'ÿ∫Ÿäÿ± ŸÖÿµÿ±ÿ≠',
    status: number = 401,
    code: string = 'UNAUTHORIZED'
  ) {
    super(message)
    this.name = 'AuthError'
    this.status = status
    this.code = code
  }
}

export class PermissionError extends Error {
  status = 403
  code = 'FORBIDDEN'

  constructor(message: string = 'ÿµŸÑÿßÿ≠Ÿäÿ© ÿ∫Ÿäÿ± ŸÉÿßŸÅŸäÿ©') {
    super(message)
    this.name = 'PermissionError'
  }
}

export class AccountError extends Error {
  status = 403
  code = 'ACCOUNT_INACTIVE'

  constructor(message: string = 'ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿ∫Ÿäÿ± ŸÜÿ¥ÿ∑') {
    super(message)
    this.name = 'AccountError'
  }
}

/**
 * =========================
 * Core Guards
 * =========================
 */

// ŸÑÿßÿ≤ŸÖ ŸäŸÉŸàŸÜ ÿπÿßŸÖŸÑ Login
export async function requireAuth() {
  const session = await getServerSession(authOptions)

  if (!session) {
    throw new AuthError()
  }

  return session
}

// ŸÑÿßÿ≤ŸÖ ŸäŸÉŸàŸÜ Role ŸÖÿπŸäŸÜ
export function requireRole(
  session: Awaited<ReturnType<typeof requireAuth>>,
  allowedRoles: string[]
) {
  if (!allowedRoles.includes(session.user.role)) {
    throw new PermissionError()
  }
}

// ÿßŸÑÿ≠ÿ≥ÿßÿ® ŸÑÿßÿ≤ŸÖ ŸäŸÉŸàŸÜ Active
export function requireActiveAccount(
  session: Awaited<ReturnType<typeof requireAuth>>
) {
  if (session.user.isActive === false) {
    throw new AccountError()
  }
}

/**
 * =========================
 * Optional helper (API only)
 * =========================
 */

export async function getSessionForAPI() {
  return getServerSession(authOptions)
}
// lib/shared/helpers/index.ts
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function formatDate(date: Date | string): string {
  const d = new Date(date)
  return d.toLocaleDateString('ar-EG', { // ÿ∫Ÿäÿ±ÿ™Ÿáÿß ŸÑŸÄ ar-EG
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  })
}

export function formatRole(role: string): string {
  const roleMap: Record<string, string> = {
    PLAYER: 'üéÆ ŸÑÿßÿπÿ®',
    OWNER: 'üèüÔ∏è ŸÖÿßŸÑŸÉ ŸÖŸÑÿπÿ®',
    EMPLOYEE: 'üë®‚Äçüíº ŸÖŸàÿ∏ŸÅ',
    ADMIN: 'üõ°Ô∏è ŸÖÿØŸäÿ±'
  }
  return roleMap[role] || role
}

export function formatSkillLevel(skillLevel: string): string {
  const skillMap: Record<string, string> = {
    WEAK: 'ÿ∂ÿπŸäŸÅ üòÖ',
    AVERAGE: 'ŸÖÿ™Ÿàÿ≥ÿ∑ üòä',
    GOOD: 'ÿ¨ŸäÿØ üòé',
    EXCELLENT: 'ŸÖŸÖÿ™ÿßÿ≤ üî•',
    LEGENDARY: 'ÿ£ÿ≥ÿ∑Ÿàÿ±Ÿä üëë'
  }
  return skillMap[skillLevel] || skillLevel
}

export function truncateText(text: string, maxLength: number = 50): string {
  if (text.length <= maxLength) return text
  return text.substring(0, maxLength) + '...'
}

export function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  return emailRegex.test(email)
}

export function isValidPhone(phone: string): boolean {
  // ÿØÿπŸÖ ŸÑŸÑÿ±ŸÇŸÖ ÿßŸÑŸÖÿµÿ±Ÿä ŸàÿßŸÑÿπÿ±ÿ®Ÿä
  const phoneRegex = /^(\+?\d{1,3}[-.\s]?)?\(?\d{1,4}\)?[-.\s]?\d{1,4}[-.\s]?\d{1,9}$/
  return phoneRegex.test(phone.replace(/\s/g, ''))
}

export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout
  
  return (...args: Parameters<T>) => {
    clearTimeout(timeout)
    timeout = setTimeout(() => func(...args), wait)
  }
}

export function generateRandomId(length: number = 8): string {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'
  let result = ''
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length))
  }
  return result
}

export function getGradientColor(level: string): string {
  const gradientMap: Record<string, string> = {
    WEAK: 'from-gray-400 to-gray-500',
    AVERAGE: 'from-blue-400 to-blue-500',
    GOOD: 'from-green-400 to-green-500',
    EXCELLENT: 'from-purple-400 to-purple-500',
    LEGENDARY: 'from-orange-400 to-orange-500'
  }
  return gradientMap[level] || 'from-gray-400 to-gray-500'
}

export function calculateAge(birthYear: number): number {
  const currentYear = new Date().getFullYear()
  return currentYear - birthYear
}

export function getInitials(name: string): string {
  return name
    .split(' ')
    .map(word => word.charAt(0))
    .join('')
    .toUpperCase()
    .slice(0, 2)
}

export function formatNumber(num: number): string {
  if (num >= 1000000) {
    return (num / 1000000).toFixed(1) + ' ŸÖŸÑŸäŸàŸÜ'
  }
  if (num >= 1000) {
    return (num / 1000).toFixed(1) + ' ÿ£ŸÑŸÅ'
  }
  return num.toString()
}

export function formatCurrency(amount: number): string {
  return amount.toLocaleString('ar-EG') + ' ÿ¨.ŸÖ'
}

export function getTimeAgo(date: Date | string): string {
  const now = new Date()
  const past = new Date(date)
  const diffMs = now.getTime() - past.getTime()
  const diffMins = Math.floor(diffMs / 60000)
  const diffHours = Math.floor(diffMs / 3600000)
  const diffDays = Math.floor(diffMs / 86400000)

  if (diffMins < 1) return 'ÿßŸÑÿ¢ŸÜ'
  if (diffMins < 60) return `ŸÇÿ®ŸÑ ${diffMins} ÿØŸÇŸäŸÇÿ©`
  if (diffHours < 24) return `ŸÇÿ®ŸÑ ${diffHours} ÿ≥ÿßÿπÿ©`
  if (diffDays < 30) return `ŸÇÿ®ŸÑ ${diffDays} ŸäŸàŸÖ`
  if (diffDays < 365) return `ŸÇÿ®ŸÑ ${Math.floor(diffDays / 30)} ÿ¥Ÿáÿ±`
  return `ŸÇÿ®ŸÑ ${Math.floor(diffDays / 365)} ÿ≥ŸÜÿ©`
}
import { z } from 'zod'

const envSchema = z.object({
  // === Database ===
  DATABASE_URL: z.string()
    .url()
    .refine(url => url.startsWith('postgresql://'), {
      message: 'DATABASE_URL must start with postgresql://'
    }),
  
  // === NextAuth ===
  NEXTAUTH_URL: z.string().url(),
  NEXTAUTH_SECRET: z.string()
    .min(32, 'NEXTAUTH_SECRET must be at least 32 characters'),
  
  // === Paymob ===
  PAYMOB_API_KEY: z.string().min(1),
  PAYMOB_HMAC_SECRET: z.string().min(1),
  PAYMOB_INTEGRATION_ID: z.string().min(1),
  PAYMOB_IFRAME_ID: z.string().default('default'),
  
  // === Cron ===
  CRON_SECRET: z.string()
    .min(32, 'CRON_SECRET must be at least 32 characters')
    .default('dev-cron-secret-change-in-production'),
  
  // === App ===
  APP_URL: z.string().url().default('http://localhost:3000'),
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  
  // === Logging ===
  LOG_LEVEL: z.enum(['debug', 'info', 'warn', 'error'])
    .default('info'),
  
  // === Email (Optional) ===
  RESEND_API_KEY: z.string().optional(),
  EMAIL_FROM: z.string().email().optional(),
  
  // === Google OAuth (Optional) ===
  GOOGLE_CLIENT_ID: z.string().optional(),
  GOOGLE_CLIENT_SECRET: z.string().optional(),
})

// Validate env
const env = envSchema.safeParse(process.env)

if (!env.success) {
  console.error('‚ùå Invalid environment variables:', env.error.flatten().fieldErrors)
  
  // ŸÅŸä development ŸÜÿπÿ∑Ÿä defaults ŸÑŸÑŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ©
  if (process.env.NODE_ENV === 'production') {
    throw new Error('Invalid environment variables')
  }
  
  console.warn('‚ö†Ô∏è  Running with default environment variables for development')
}

export const ENV = env.success ? env.data : {
  // Defaults for development
  NODE_ENV: 'development' as const,
  DATABASE_URL: process.env.DATABASE_URL || 'postgresql://localhost:5432/ihgezly',
  NEXTAUTH_URL: process.env.NEXTAUTH_URL || 'http://localhost:3000',
  NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET || 'dev-secret-change-in-production-32-chars-min',
  APP_URL: process.env.APP_URL || 'http://localhost:3000',
  CRON_SECRET: process.env.CRON_SECRET || 'dev-cron-secret-change-in-production',
  LOG_LEVEL: 'debug' as const,
  PAYMOB_API_KEY: process.env.PAYMOB_API_KEY || 'mock_api_key',
  PAYMOB_HMAC_SECRET: process.env.PAYMOB_HMAC_SECRET || 'mock_hmac_secret',
  PAYMOB_INTEGRATION_ID: process.env.PAYMOB_INTEGRATION_ID || 'mock_integration_id',
  PAYMOB_IFRAME_ID: process.env.PAYMOB_IFRAME_ID || 'default'
}
// lib/shared/env/startup-check.ts
import { ENV } from './env'
import { logger } from '@/lib/shared/logger'  // ‚úÖ ÿßŸÑŸÖÿ≥ÿßÿ± ÿßŸÑÿ¨ÿØŸäÿØ
import { prisma } from '@/lib/infrastructure/database/prisma'  // ‚úÖ ÿßŸÑŸÖÿ≥ÿßÿ± ÿßŸÑÿ¨ÿØŸäÿØ

export async function startupCheck(): Promise<void> {
  logger.info('Starting application...')
  
  const checks = [
    { name: 'Environment', check: checkEnvironment },
    { name: 'Database', check: checkDatabase },
    { name: 'Paymob Config', check: checkPaymob },
  ]
  
  const results = await Promise.allSettled(
    checks.map(async ({ name, check }) => {
      try {
        await check()
        return { name, status: '‚úÖ' }
      } catch (error: any) {
        return { name, status: '‚ùå', error: error.message }
      }
    })
  )
  
  console.log('\nüìä Startup Check Results:')
  console.log('========================')
  
  results.forEach(result => {
    if (result.status === 'fulfilled') {
      const value = result.value
      if (value.error) {
        console.log(`${value.status} ${value.name}: ${value.error}`)
      } else {
        console.log(`${value.status} ${value.name}`)
      }
    } else {
      console.log(`‚ùå Check failed`)
    }
  })
  
  console.log('========================\n')
  
  // Warn if not production ready
  if (ENV.NODE_ENV === 'production') {
    const missingForProduction = []
    
    if (!ENV.PAYMOB_API_KEY) missingForProduction.push('PAYMOB_API_KEY')
    if (!ENV.PAYMOB_HMAC_SECRET) missingForProduction.push('PAYMOB_HMAC_SECRET')
    if (!ENV.PAYMOB_INTEGRATION_ID) missingForProduction.push('PAYMOB_INTEGRATION_ID')
    
    if (missingForProduction.length > 0) {
      logger.warn({ missing: missingForProduction }, '‚ö†Ô∏è  Missing production configuration:')
    }
  }
  
  logger.info('Startup check completed')
}

async function checkEnvironment(): Promise<void> {
  const required = ['NODE_ENV', 'DATABASE_URL', 'NEXTAUTH_URL']
  const missing = required.filter(key => !process.env[key])
  
  if (missing.length > 0) {
    throw new Error(`Missing environment variables: ${missing.join(', ')}`)
  }
}

async function checkDatabase(): Promise<void> {
  try {
    await prisma.$queryRaw`SELECT 1`
    logger.info('Database connection successful')
  } catch (error: any) {
    throw new Error(`Database connection failed: ${error.message}`)
  }
}

async function checkPaymob(): Promise<void> {
  if (ENV.NODE_ENV === 'production') {
    const required = ['PAYMOB_API_KEY', 'PAYMOB_HMAC_SECRET', 'PAYMOB_INTEGRATION_ID']
    const missing = required.filter(key => !ENV[key as keyof typeof ENV])
    
    if (missing.length > 0) {
      throw new Error(`Missing Paymob configuration: ${missing.join(', ')}`)
    }
    logger.info('Paymob configuration is ready for production')
  } else {
    logger.info('Paymob configuration check skipped (development)')
  }
}

// lib/shared/context/request-context.ts
import { NextRequest, NextResponse } from 'next/server'
import { v4 as uuidv4 } from 'uuid'
import { getServerSession } from 'next-auth'
import { AsyncLocalStorage } from 'async_hooks'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'
import { logger } from '@/lib/shared/logger'

export class RequestContext {
  private static storage = new AsyncLocalStorage<Map<string, any>>()

  static get<T>(key: string): T | undefined {
    return this.storage.getStore()?.get(key)
  }

  static set(key: string, value: any): void {
    const store = this.storage.getStore()
    if (store) {
      store.set(key, value)
    }
  }

  // ‚úÖ ÿÆŸÑŸäŸáÿß generic ÿπŸÑÿ¥ÿßŸÜ ÿ™ÿ±ÿ¨ÿπ ŸÜŸÅÿ≥ ŸÜŸàÿπ callback
  static run<T>(context: Map<string, any>, callback: () => T): T {
    return this.storage.run(context, callback)
  }

  static getRequestId(): string {
    return this.get('requestId') || 'unknown'
  }

  static getUserId(): string | undefined {
    return this.get('userId')
  }

  static getSessionId(): string | undefined {
    return this.get('sessionId')
  }
}

// Middleware ŸÑÿ•ÿ∂ÿßŸÅÿ© Context
export function withRequestContext(
  handler: (req: NextRequest) => Promise<NextResponse>
) {
  return async (req: NextRequest): Promise<NextResponse> => {
    const context = new Map<string, any>()
    
    const requestId = uuidv4()
    context.set('requestId', requestId)
    
    try {
      const session = await getServerSession(authOptions)
      if (session?.user) {
        const user = session.user as any
        if (user.id) {
          context.set('userId', user.id)
        }
        // ‚ùå session.id ŸÖÿ¥ ŸÖŸàÿ¨ŸàÿØ ŸÅŸä ÿßŸÑŸÜŸàÿπ ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä
        // ŸÑŸà ŸÖÿ≠ÿ™ÿßÿ¨ sessionIdÿå ÿ∂ŸäŸÅŸá ÿ®ŸÜŸÅÿ≥ŸÉ ŸÅŸä JWT/session callback
      }
    } catch (error) {
      logger.warn({ error }, 'Failed to get session in request context')
    }
    
    context.set('userAgent', req.headers.get('user-agent'))
    context.set('ip', req.headers.get('x-forwarded-for') || req.headers.get('x-real-ip') || 'unknown')
    context.set('path', req.nextUrl.pathname)
    context.set('method', req.method)
    
    return RequestContext.run(context, async () => {
      logger.info({
        requestId,
        method: req.method,
        path: req.nextUrl.pathname,
        userId: RequestContext.getUserId()
      }, 'Request started')
      
      const startTime = Date.now()
      
      try {
        const response = await handler(req)
        
        const duration = Date.now() - startTime
        logger.info({
          requestId,
          durationMs: duration,
          status: response.status,
          path: req.nextUrl.pathname,
          userId: RequestContext.getUserId()
        }, 'Request completed')
        
        response.headers.set('X-Request-ID', requestId)
        return response
      } catch (error) {
        const duration = Date.now() - startTime
        logger.error({
          requestId,
          durationMs: duration,
          path: req.nextUrl.pathname,
          userId: RequestContext.getUserId(),
          error: error instanceof Error ? error.message : String(error)
        }, 'Request failed')
        
        throw error
      }
    })
  }
}
// lib/shared/constants/index.ts

// === ÿ≠ÿßŸÑÿ© ÿßŸÑÿ≥ŸÑÿßÿ™ (Slots) ===
export const SLOT_STATUS = {
  AVAILABLE: 'AVAILABLE',
  TEMP_LOCKED: 'TEMP_LOCKED',
  BOOKED: 'BOOKED',
  UNAVAILABLE: 'UNAVAILABLE',
  AVAILABLE_NEEDS_CONFIRM: 'AVAILABLE_NEEDS_CONFIRM'
} as const

// === ÿ≠ÿßŸÑÿ© ÿßŸÑÿ≠ÿ¨Ÿàÿ≤ÿßÿ™ (Bookings) ===
export const BOOKING_STATUS = {
  DRAFT: 'DRAFT',
  PENDING_PAYMENT: 'PENDING_PAYMENT',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED',
  FAILED: 'FAILED',
  EXPIRED: 'EXPIRED'
} as const

// === ÿ≠ÿßŸÑÿ© ÿßŸÑŸÖÿØŸÅŸàÿπÿßÿ™ (Payments) ===
export const PAYMENT_STATUS = {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  PAID: 'PAID',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED',
  PARTIALLY_REFUNDED: 'PARTIALLY_REFUNDED'
} as const

// === ÿ≠ÿßŸÑÿ© ÿßŸÑŸÖŸÑÿßÿπÿ® (Fields) ===
export const FIELD_STATUS = {
  OPEN: 'OPEN',
  CLOSED: 'CLOSED',
  MAINTENANCE: 'MAINTENANCE'
} as const

// === ÿ£ŸÜŸàÿßÿπ ÿßŸÑŸÖŸÑÿßÿπÿ® ===
export const FIELD_TYPES = {
  FOOTBALL: 'FOOTBALL',
  PADEL: 'PADEL',
  TENNIS: 'TENNIS',
  BASKETBALL: 'BASKETBALL'
} as const

// === ÿ£ŸÜŸàÿßÿπ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ===
export const NOTIFICATION_TYPE = {
  PAYMENT_SUCCESS: 'PAYMENT_SUCCESS',
  PAYMENT_FAILED: 'PAYMENT_FAILED',
  BOOKING_CONFIRMED: 'BOOKING_CONFIRMED',
  SLOT_REMINDER: 'SLOT_REMINDER'
} as const

// === ÿ£ÿØŸàÿßÿ± ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ (User Roles) ===
export const USER_ROLES = {
  ADMIN: 'ADMIN',
  PLAYER: 'PLAYER',
  OWNER: 'OWNER',
  EMPLOYEE: 'EMPLOYEE'
} as const

// === ŸÖŸáÿßÿ±ÿßÿ™ ÿßŸÑŸÑÿßÿπÿ®ŸäŸÜ ===
export const SKILL_LEVELS = {
  WEAK: 'WEAK',
  AVERAGE: 'AVERAGE',
  GOOD: 'GOOD',
  EXCELLENT: 'EXCELLENT',
  LEGENDARY: 'LEGENDARY'
} as const

// === ÿ£ŸÜŸàÿßÿπ ŸÑŸÑŸÖÿ≥ÿßÿπÿØÿ© ŸÅŸä TypeScript ===
export type SlotStatus = typeof SLOT_STATUS[keyof typeof SLOT_STATUS]
export type BookingStatus = typeof BOOKING_STATUS[keyof typeof BOOKING_STATUS]
export type PaymentStatus = typeof PAYMENT_STATUS[keyof typeof PAYMENT_STATUS]
export type FieldStatus = typeof FIELD_STATUS[keyof typeof FIELD_STATUS]
export type FieldType = typeof FIELD_TYPES[keyof typeof FIELD_TYPES]
export type NotificationType = typeof NOTIFICATION_TYPE[keyof typeof NOTIFICATION_TYPE]
export type UserRole = typeof USER_ROLES[keyof typeof USER_ROLES]
export type SkillLevel = typeof SKILL_LEVELS[keyof typeof SKILL_LEVELS]
// lib/shared/api/api-error-handler.ts
import { NextResponse } from 'next/server'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { ERROR_CODES } from '@/lib/core/errors/error-codes'

export function apiErrorHandler(error: unknown): NextResponse {
  console.error('API Error:', error)

  // Handle DomainError
  if (error instanceof DomainError) {
    const status = getHttpStatus(error.code)
    return NextResponse.json(
      {
        error: true,
        code: ERROR_CODES[error.code],
        message: error.message,
        details: error.details
      },
      { status }
    )
  }

  // Handle Zod validation errors
  if (error instanceof Error && error.name === 'ZodError') {
    return NextResponse.json(
      {
        error: true,
        code: 'VALIDATION_ERROR',
        message: 'ÿ®ŸäÿßŸÜÿßÿ™ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ©',
        details: error.message
      },
      { status: 400 }
    )
  }

  // Handle Prisma errors
  if (error instanceof Error && error.name.includes('Prisma')) {
    return NextResponse.json(
      {
        error: true,
        code: 'DATABASE_ERROR',
        message: 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™'
      },
      { status: 500 }
    )
  }

  // Default error
  return NextResponse.json(
    {
      error: true,
      code: 'INTERNAL_SERVER_ERROR',
      message: 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ'
    },
    { status: 500 }
  )
}

function getHttpStatus(errorCode: keyof typeof ERROR_CODES): number {
  const code = ERROR_CODES[errorCode]
  
  if (code.startsWith('AUTH')) return 401
  if (code.startsWith('VAL')) return 400
  if (code.startsWith('SLOT') || code.startsWith('BOOK') || code.startsWith('PAY')) return 400
  if (code.startsWith('FIELD')) return 404
  return 500
}
// lib/infrastructure/security/password.ts
import bcrypt from 'bcryptjs'

export async function hashPassword(password: string): Promise<string> {
  const salt = await bcrypt.genSalt(12)
  return bcrypt.hash(password, salt)
}

export async function comparePassword(
  rawPassword: string, 
  hashedPassword: string
): Promise<boolean> {
  if (!hashedPassword) return false
  return bcrypt.compare(rawPassword, hashedPassword)
}
//lib/infrastructure/payments/providers/paymob.ts
import axios from 'axios'
import { ENV } from '@/lib/shared/env/env'
import { paymentLogger } from '@/lib/shared/logger'

const PAYMOB_BASE_URL = 'https://accept.paymob.com/api'

export interface PaymobOrder {
  id: number
  amount_cents: number
  currency: string
  merchant_order_id: string
}

export interface PaymobPaymentKey {
  token: string
  orderId: number
}

export interface PaymobBillingData {
  apartment?: string
  email: string
  floor?: string
  first_name: string
  street?: string
  building?: string
  phone_number: string
  shipping_method?: string
  postal_code?: string
  city?: string
  country?: string
  last_name?: string
  state?: string
}

export class PaymobService {
  private apiKey: string
  private integrationId: string
  private hmacSecret: string

  constructor() {
    this.apiKey = ENV.PAYMOB_API_KEY || ''
    this.integrationId = ENV.PAYMOB_INTEGRATION_ID || ''
    this.hmacSecret = ENV.PAYMOB_HMAC_SECRET || ''
  }

  // 1. ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ Authentication Token
  async getAuthToken(): Promise<string> {
    try {
      paymentLogger.info({ 
        msg: 'Requesting Paymob auth token' 
      })
      
      const response = await axios.post(`${PAYMOB_BASE_URL}/auth/tokens`, {
        api_key: this.apiKey
      })
      
      paymentLogger.info({ 
        msg: 'Paymob auth token received' 
      })
      return response.data.token
    } catch (error: any) {
      paymentLogger.error({ 
        msg: 'Error getting Paymob auth token',
        error: error.message 
      })
      throw new Error('ŸÅÿ¥ŸÑ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿÆÿØŸÖÿ© ÿßŸÑÿØŸÅÿπ')
    }
  }

  // 2. ÿ•ŸÜÿ¥ÿßÿ° Order ŸÅŸä Paymob
  async createOrder({
    amount,
    currency = 'EGP',
    bookingId,
    userId
  }: {
    amount: number
    currency?: string
    bookingId: string
    userId: string
  }): Promise<PaymobOrder> {
    try {
      const authToken = await this.getAuthToken()
      
      paymentLogger.info({ 
        msg: 'Creating Paymob order',
        bookingId, 
        userId, 
        amount 
      })
      
      const response = await axios.post(
        `${PAYMOB_BASE_URL}/ecommerce/orders`,
        {
          auth_token: authToken,
          delivery_needed: 'false',
          amount_cents: amount * 100,
          currency,
          items: [],
          merchant_order_id: bookingId
        },
        { timeout: 10000 }
      )

      paymentLogger.info({ 
        msg: 'Paymob order created',
        orderId: response.data.id,
        bookingId 
      })

      return response.data
    } catch (error: any) {
      paymentLogger.error({ 
        msg: 'Error creating Paymob order',
        error: error.message,
        bookingId,
        amount
      })
      throw error
    }
  }

  // 3. ÿ•ŸÜÿ¥ÿßÿ° Payment Key ŸÑŸÅÿ™ÿ≠ Iframe
  async getPaymentKey({
    orderId,
    amount,
    billingData,
    bookingId
  }: {
    orderId: string | number
    amount: number
    billingData: PaymobBillingData
    bookingId: string
  }): Promise<string> {
    try {
      const authToken = await this.getAuthToken()
      
      paymentLogger.info({ 
        msg: 'Getting Paymob payment key',
        orderId, 
        bookingId 
      })
      
      const response = await axios.post(
        `${PAYMOB_BASE_URL}/acceptance/payment_keys`,
        {
          auth_token: authToken,
          amount_cents: amount * 100,
          expiration: 3600,
          order_id: orderId,
          billing_data: billingData,
          currency: 'EGP',
          integration_id: this.integrationId,
          lock_order_when_paid: 'false',
          extra: {
            booking_id: bookingId
          }
        },
        { timeout: 10000 }
      )

      paymentLogger.info({ 
        msg: 'Paymob payment key received',
        orderId 
      })
      return response.data.token
    } catch (error: any) {
      paymentLogger.error({ 
        msg: 'Error getting Paymob payment key',
        error: error.message,
        orderId
      })
      throw error
    }
  }

  // 4. ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµÿ≠ÿ© ÿßŸÑŸÄ HMAC (ŸÑŸÄ Webhook)
  verifyHMAC(data: any, receivedHMAC: string): boolean {
    try {
      const { 
        amount_cents, created_at, currency, error_occured, has_parent_transaction, 
        id, integration_id, is_3d_secure, is_auth, is_capture, is_refunded, 
        is_standalone_payment, is_voided, order, owner, pending, source_data, success 
      } = data

      const orderId = order?.id || ''
      const pan = source_data?.pan || ''
      const sub_type = source_data?.sub_type || ''
      const type = source_data?.type || ''

      const stringToHash = 
        amount_cents + 
        created_at + 
        currency + 
        error_occured + 
        has_parent_transaction + 
        id + 
        integration_id + 
        is_3d_secure + 
        is_auth + 
        is_capture + 
        is_refunded + 
        is_standalone_payment + 
        is_voided + 
        orderId + 
        owner + 
        pending + 
        pan + 
        sub_type + 
        type + 
        success

      const crypto = require('crypto')
      const calculatedHMAC = crypto
        .createHmac('sha512', this.hmacSecret)
        .update(stringToHash)
        .digest('hex')

      const isValid = calculatedHMAC === receivedHMAC
      
      paymentLogger.info({ 
        msg: 'HMAC verification',
        isValid,
        orderId: data.order?.id 
      })
      
      return isValid
    } catch (error: any) {
      paymentLogger.error({ 
        msg: 'HMAC verification error',
        error: error.message 
      })
      return false
    }
  }

  // 5. Mock mode ŸÑŸÑÿ™ŸÜŸÖŸäÿ©
  isMockMode(): boolean {
    return ENV.NODE_ENV !== 'production' || !this.apiKey
  }

  // 6. ÿ•ŸÜÿ¥ÿßÿ° order ŸàŸáŸÖŸä ŸÑŸÑÿ™ŸÜŸÖŸäÿ©
  async createMockOrder(params: {
    amount: number
    currency: string
    bookingId: string
  }): Promise<PaymobOrder> {
    paymentLogger.info({ 
      msg: 'Creating mock Paymob order',
      ...params 
    })
    
    return {
      id: Date.now(),
      amount_cents: params.amount * 100,
      currency: params.currency,
      merchant_order_id: params.bookingId
    }
  }

  // 7. ŸÖŸÅÿ™ÿßÿ≠ ÿØŸÅÿπ ŸàŸáŸÖŸä ŸÑŸÑÿ™ŸÜŸÖŸäÿ©
  async getMockPaymentKey(params: {
    orderId: number
  }): Promise<string> {
    paymentLogger.info({ 
      msg: 'Creating mock payment key',
      ...params 
    })
    return `mock_token_${Date.now()}_${params.orderId}`
  }
}

export const paymobService = new PaymobService()

// lib/infrastructure/payments/providers/index.ts
export { paymobService } from './paymob'
export { paymobHmacVerifier } from './hmac-verifier'

// Re-export types
export type {
  PaymobOrder,
  PaymobPaymentKey,
  PaymobBillingData
} from './paymob'
// lib/infrastructure/payments/providers/hmac-verifier.ts
import crypto from 'crypto'
import { ENV } from '@/lib/shared/env/env'
import { paymentLogger } from '@/lib/shared/logger'

export class PaymobHmacVerifier {
  private readonly hmacSecret: string

  constructor() {
    this.hmacSecret = ENV.PAYMOB_HMAC_SECRET || ''
    
    if (!this.hmacSecret) {
      paymentLogger.warn({
        msg: 'PAYMOB_HMAC_SECRET is not set. HMAC verification will fail.'
      })
    }
  }

  verify(data: any, receivedHmac: string): boolean {
    try {
      // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿßŸÑŸÖŸÅÿ™ÿßÿ≠ ÿßŸÑÿ≥ÿ±Ÿä
      if (!this.hmacSecret) {
        paymentLogger.error({
          msg: 'HMAC verification failed - secret not configured'
        })
        return false
      }

      const orderedData = this.orderData(data)
      const dataString = JSON.stringify(orderedData)
      
      const calculatedHmac = crypto
        .createHmac('sha512', this.hmacSecret)
        .update(dataString)
        .digest('hex')
      
      const isValid = crypto.timingSafeEqual(
        Buffer.from(calculatedHmac, 'hex'),
        Buffer.from(receivedHmac, 'hex')
      )

      paymentLogger.info({
        msg: 'HMAC verification completed',
        isValid,
        orderId: data.order?.id 
      })
      
      return isValid
    } catch (error: any) {
      paymentLogger.error({
        msg: 'HMAC verification error',
        error: error.message,
        stack: error.stack
      })
      return false
    }
  }

  isFresh(timestamp: number, maxAgeSeconds: number = 300): boolean {
    const now = Math.floor(Date.now() / 1000)
    const age = now - timestamp
    
    const isFresh = age <= maxAgeSeconds && age >= 0
    
    paymentLogger.debug({
      msg: 'Timestamp freshness check',
      timestamp,
      now,
      age,
      maxAgeSeconds,
      isFresh
    })
    
    return isFresh
  }

  private orderData(data: any): any {
    const ordered: any = {}
    
    const fields = [
      'amount_cents',
      'created_at',
      'currency',
      'error_occured',
      'has_parent_transaction',
      'id',
      'integration_id',
      'is_3d_secure',
      'is_auth',
      'is_capture',
      'is_refunded',
      'is_standalone_payment',
      'is_voided',
      'order',
      'owner',
      'pending',
      'source_data',
      'success',
    ]

    fields.forEach(field => {
      if (data[field] !== undefined) {
        ordered[field] = data[field]
      }
    })
    
    return ordered
  }

  // ÿØÿßŸÑÿ© ŸÖÿ≥ÿßÿπÿØÿ© ŸÑŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ™ŸÉŸàŸäŸÜ ÿßŸÑŸÄ HMAC
  testConfiguration(): boolean {
    const testData = { test: 'data' }
    const testHmac = 'test-hmac'
    
    try {
      const result = this.verify(testData, testHmac)
      
      paymentLogger.info({
        msg: 'HMAC configuration test',
        hasSecret: !!this.hmacSecret,
        testResult: result // ŸÖŸÜ ÿßŸÑŸÖÿ™ŸàŸÇÿπ ÿ£ŸÜ ÿ™ŸÉŸàŸÜ false ŸÑÿ£ŸÜ HMAC ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠
      })
      
      return !!this.hmacSecret
    } catch (error: any) {
      paymentLogger.error({
        msg: 'HMAC configuration test failed',
        error: error.message
      })
      return false
    }
  }
}

export const paymobHmacVerifier = new PaymobHmacVerifier()
// lib/infrastructure/notifications/notification-service.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { logger } from '@/lib/shared/logger'

// ‚úÖ ÿ™ÿπÿ±ŸäŸÅ NotificationType ŸÖÿ≠ŸÑŸäÿßŸã
export type NotificationType = 
  | 'SYSTEM'
  | 'BOOKING_CREATED'
  | 'BOOKING_CONFIRMED'
  | 'BOOKING_CANCELLED'
  | 'BOOKING_EXPIRED'
  | 'PAYMENT_INITIATED'
  | 'PAYMENT_SUCCESS'
  | 'PAYMENT_FAILED'
  | 'PAYMENT_REFUNDED'
  | 'SLOT_LOCKED'
  | 'SLOT_RELEASED'
  | 'USER_WELCOME'
  | 'PASSWORD_RESET'

export interface NotificationParams {
  userId: string
  type: NotificationType
  title: string
  message: string
  relatedId?: string
  data?: any
  channel?: 'APP' | 'EMAIL' | 'SMS'
}

export class NotificationService {
  async send(params: NotificationParams): Promise<void> {
    try {
      // 1. Save to DB
      await prisma.notification.create({
        data: {
          userId: params.userId,
          type: params.type,
          title: params.title,
          message: params.message,
          bookingId: params.data?.bookingId || null,
          data: params.data || {},
          isRead: false,
          isSent: true,
          sentVia: params.channel ? [params.channel] : ['APP']
        }
      })

      // 2. Send via channels
      if (params.channel) {
        switch (params.channel) {
          case 'EMAIL':
            await this.sendEmail(params)
            break
          case 'SMS':
            await this.sendSMS(params)
            break
        }
      }

      logger.info({
        msg: 'Notification sent successfully',
        userId: params.userId,
        type: params.type
      })
    } catch (error: any) {
      logger.error({
        msg: 'Failed to send notification',
        error: error.message,
        userId: params.userId
      })
    }
  }

  async sendEmail(params: NotificationParams): Promise<void> {
    // TODO: Implement email sending
    logger.info({
      msg: 'Email notification would be sent',
      userId: params.userId,
      email: params.data?.email
    })
  }

  async sendSMS(params: NotificationParams): Promise<void> {
    // TODO: Implement SMS sending
    logger.info({
      msg: 'SMS notification would be sent',
      userId: params.userId,
      phone: params.data?.phone
    })
  }

  async getUserNotifications(userId: string, limit: number = 20) {
    try {
      return await prisma.notification.findMany({
        where: { 
          userId,
          isSent: true
        },
        orderBy: { createdAt: 'desc' },
        take: limit
      })
    } catch (error: any) {
      logger.error({
        msg: 'Failed to get user notifications',
        error: error.message,
        userId
      })
      return []
    }
  }

  async markAsRead(notificationId: string, userId: string) {
    try {
      return await prisma.notification.update({
        where: { 
          id: notificationId,
          userId
        },
        data: { 
          isRead: true,
          readAt: new Date()
        }
      })
    } catch (error: any) {
      logger.error({
        msg: 'Failed to mark notification as read',
        error: error.message,
        notificationId,
        userId
      })
      throw error
    }
  }

  async markAllAsRead(userId: string) {
    try {
      return await prisma.notification.updateMany({
        where: { 
          userId,
          isRead: false
        },
        data: { 
          isRead: true,
          readAt: new Date()
        }
      })
    } catch (error: any) {
      logger.error({
        msg: 'Failed to mark all notifications as read',
        error: error.message,
        userId
      })
      throw error
    }
  }

  async deleteNotification(notificationId: string, userId: string) {
    try {
      return await prisma.notification.delete({
        where: { 
          id: notificationId,
          userId
        }
      })
    } catch (error: any) {
      logger.error({
        msg: 'Failed to delete notification',
        error: error.message,
        notificationId,
        userId
      })
      throw error
    }
  }
}

export const notificationService = new NotificationService()
// lib/infrastructure/database/prisma.ts
import { PrismaClient } from '@prisma/client'

console.log('PrismaClient:', typeof PrismaClient)

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

// ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿ¥ÿ±ÿ∑ ÿ™ÿ≠ŸÇŸÇ ÿ•ÿ∂ÿßŸÅŸä
let prismaInstance: PrismaClient

if (process.env.NODE_ENV === 'production') {
  prismaInstance = new PrismaClient()
} else {
  if (!globalForPrisma.prisma) {
    globalForPrisma.prisma = new PrismaClient({
      log: ['query', 'error', 'warn']
    })
  }
  prismaInstance = globalForPrisma.prisma
}

export const prisma = prismaInstance
export default prisma
// lib/infrastructure/auth/validators.ts
import { z } from 'zod'

export const emailSchema = z.string()
  .email('ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠')
  .min(1, 'ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä ŸÖÿ∑ŸÑŸàÿ®')
  .max(100, 'ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä ÿ∑ŸàŸäŸÑ ÿ¨ÿØÿßŸã')

export const passwordSchema = z.string()
  .min(6, 'ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ŸÉŸàŸÜ 6 ÿ£ÿ≠ÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ')
  .max(72, 'ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿ∑ŸàŸäŸÑÿ© ÿ¨ÿØÿßŸã')

export const nameSchema = z.string()
  .min(2, 'ÿßŸÑÿßÿ≥ŸÖ Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ≠ÿ±ŸÅŸäŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ')
  .max(100, 'ÿßŸÑÿßÿ≥ŸÖ ÿ∑ŸàŸäŸÑ ÿ¨ÿØÿßŸã')
  .regex(/^[a-zA-Z\u0600-\u06FF\s]*$/, 'ÿßŸÑÿßÿ≥ŸÖ ŸäŸÖŸÉŸÜ ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ŸÅŸÇÿ∑ ÿπŸÑŸâ ÿ£ÿ≠ÿ±ŸÅ ŸàŸÖÿ≥ÿßŸÅÿßÿ™')

export const phoneSchema = z.string()
  .min(10, 'ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ 10 ÿ£ÿ±ŸÇÿßŸÖ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ')
  .max(15, 'ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ ÿ∑ŸàŸäŸÑ ÿ¨ÿØÿßŸã')
  .regex(/^[0-9+\-\s()]*$/, 'ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠')

export const ageSchema = z.number()
  .min(13, 'ÿßŸÑÿπŸÖÿ± Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ 13 ÿ≥ŸÜÿ© ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ')
  .max(100, 'ÿßŸÑÿπŸÖÿ± Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ 100 ÿ≥ŸÜÿ© ÿπŸÑŸâ ÿßŸÑÿ£ŸÉÿ´ÿ±')

export const skillLevelSchema = z.enum(['WEAK', 'AVERAGE', 'GOOD', 'EXCELLENT', 'LEGENDARY'])

export const registerSchema = z.object({
  name: nameSchema,
  email: emailSchema,
  password: passwordSchema,
  confirmPassword: z.string(),
  phoneNumber: phoneSchema,
  age: ageSchema,
  description: z.string().max(500, 'ÿßŸÑŸàÿµŸÅ ÿ∑ŸàŸäŸÑ ÿ¨ÿØÿßŸã (500 ÿ≠ÿ±ŸÅ ŸÉÿ≠ÿØ ÿ£ŸÇÿµŸâ)').optional(),
  skillLevel: skillLevelSchema
}).refine(data => data.password === data.confirmPassword, {
  message: "ŸÉŸÑŸÖÿßÿ™ ÿßŸÑŸÖÿ±Ÿàÿ± ÿ∫Ÿäÿ± ŸÖÿ™ÿ∑ÿßÿ®ŸÇÿ©",
  path: ["confirmPassword"]
})

export const loginSchema = z.object({
  email: emailSchema,
  password: z.string().min(1, 'ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÖÿ∑ŸÑŸàÿ®ÿ©')
})

export const updateProfileSchema = z.object({
  name: nameSchema.optional(),
  email: emailSchema.optional(),
  phoneNumber: phoneSchema.optional(),
  age: ageSchema.optional(),
  description: z.string().max(500).optional(),
  skillLevel: skillLevelSchema.optional()
}).refine(data => Object.keys(data).length > 0, {
  message: "Ÿäÿ¨ÿ® ÿ™ŸÇÿØŸäŸÖ ÿ≠ŸÇŸÑ Ÿàÿßÿ≠ÿØ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ"
})

export const changePasswordSchema = z.object({
  currentPassword: z.string().min(1, 'ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿßŸÑÿ≠ÿßŸÑŸäÿ© ŸÖÿ∑ŸÑŸàÿ®ÿ©'),
  newPassword: passwordSchema,
  confirmPassword: z.string()
}).refine(data => data.newPassword === data.confirmPassword, {
  message: "ŸÉŸÑŸÖÿßÿ™ ÿßŸÑŸÖÿ±Ÿàÿ± ÿ∫Ÿäÿ± ŸÖÿ™ÿ∑ÿßÿ®ŸÇÿ©",
  path: ["confirmPassword"]
})

export type RegisterInput = z.infer<typeof registerSchema>
export type LoginInput = z.infer<typeof loginSchema>
export type UpdateProfileInput = z.infer<typeof updateProfileSchema>
export type ChangePasswordInput = z.infer<typeof changePasswordSchema>
export type RegisterFormInput = RegisterInput & {
  skillLevel: 'WEAK' | 'AVERAGE' | 'GOOD' | 'EXCELLENT' | 'LEGENDARY'
}

// lib/infrastructure/auth/responses.ts
export interface ApiResponse<T = any> {
  success: boolean
  message: string
  data?: T
  errorCode?: string
  details?: any
  timestamp: string
  path?: string
}

export const successResponse = <T>(
  message: string, 
  data?: T,
  path?: string
): ApiResponse<T> => ({
  success: true,
  message,
  data,
  timestamp: new Date().toISOString(),
  path
})

export const errorResponse = (
  message: string,
  errorCode?: string,
  details?: any,
  path?: string
): ApiResponse => ({
  success: false,
  message,
  errorCode,
  details,
  timestamp: new Date().toISOString(),
  path
})

export const validationErrorResponse = (
  errors: any[],
  path?: string
): ApiResponse => ({
  success: false,
  message: 'Validation failed',
  errorCode: 'VALIDATION_ERROR',
  details: { errors },
  timestamp: new Date().toISOString(),
  path
})
import { z } from 'zod'
import { authLogger } from '@/lib/shared/logger'

export class AppError extends Error {
  constructor(
    public message: string,
    public statusCode: number = 500,
    public errorCode?: string,
    public details?: unknown
  ) {
    super(message)
    this.name = this.constructor.name
    Error.captureStackTrace(this, this.constructor)
    authLogger.error({ statusCode, errorCode, details }, `AppError: ${message}`)
  }
}

export class ValidationError extends AppError {
  constructor(message: string, details?: unknown) {
    super(message, 400, 'VALIDATION_ERROR', details)
  }
}

export class AuthenticationError extends AppError {
  constructor(message = 'Authentication required') {
    super(message, 401, 'AUTHENTICATION_ERROR')
  }
}

export class AuthorizationError extends AppError {
  constructor(message = 'Insufficient permissions') {
    super(message, 403, 'AUTHORIZATION_ERROR')
  }
}

export class NotFoundError extends AppError {
  constructor(resource = 'Resource') {
    super(`${resource} not found`, 404, 'NOT_FOUND')
  }
}

export class ConflictError extends AppError {
  constructor(message = 'Resource already exists') {
    super(message, 409, 'CONFLICT')
  }
}

export class RateLimitError extends AppError {
  constructor(message = 'Too many requests') {
    super(message, 429, 'RATE_LIMIT_EXCEEDED')
  }
}

export class TokenExpiredError extends AppError {
  constructor(message = 'Token has expired') {
    super(message, 401, 'TOKEN_EXPIRED')
  }
}

export class InvalidTokenError extends AppError {
  constructor(message = 'Invalid token') {
    super(message, 401, 'INVALID_TOKEN')
  }
}

// Error handler
export const handleError = (error: unknown): AppError => {
  if (error instanceof AppError) {
    return error
  }
  
  if (error instanceof z.ZodError) {
    return new ValidationError(
      'Validation failed',
      error.issues.map((e: z.ZodIssue) => ({
        path: e.path.join('.'),
        message: e.message
      }))
    )
  }
  
  authLogger.error({ error }, 'Unexpected error')
  
  return new AppError(
    'An unexpected error occurred',
    500,
    'INTERNAL_SERVER_ERROR'
  )
}
// lib/infrastructure/auth/auth-options.ts
import { NextAuthOptions } from 'next-auth'
import CredentialsProvider from 'next-auth/providers/credentials'
import GoogleProvider from 'next-auth/providers/google'
import { RateLimiterMemory } from 'rate-limiter-flexible'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { comparePassword } from '@/lib/infrastructure/security/password'
import { z } from 'zod'
import { authLogger } from '@/lib/shared/logger'
import { USER_ROLES, UserRole } from '@/lib/shared/constants'
import { ENV } from '@/lib/shared/env/env'

// Rate Limiter
const loginRateLimiter = new RateLimiterMemory({
  points: 5,
  duration: 15 * 60,
})

// Validation schema for login
const loginSchema = z.object({
  email: z.string().email('ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠'),
  password: z.string().min(1, 'ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÖÿ∑ŸÑŸàÿ®ÿ©')
})

const normalizeEmail = (email: string): string => {
  return email.toLowerCase().trim()
}

export const authOptions: NextAuthOptions = {
  providers: [
    CredentialsProvider({
      name: 'credentials',
      credentials: {
        email: { label: 'ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä', type: 'email' },
        password: { label: 'ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±', type: 'password' }
      },
      async authorize(credentials) {
        try {
          await loginRateLimiter.consume(credentials?.email || 'unknown')
          
          const validated = loginSchema.parse(credentials)
          const normalizedEmail = normalizeEmail(validated.email)

          const user = await prisma.user.findUnique({
            where: { email: normalizedEmail }
          })

          if (!user) {
            authLogger.warn({ email: normalizedEmail }, 'User not found')
            throw new Error('ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä ÿ£Ÿà ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©')
          }

          if (!user.isActive) {
            authLogger.warn({ userId: user.id }, 'Inactive account attempt')
            throw new Error('ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿ∫Ÿäÿ± ŸÜÿ¥ÿ∑')
          }

          if (user.lockedUntil && user.lockedUntil > new Date()) {
            authLogger.warn({ userId: user.id }, 'Locked account attempt')
            throw new Error('ÿßŸÑÿ≠ÿ≥ÿßÿ® ŸÖÿ§ŸÇÿ™ ŸÖÿ∫ŸÑŸÇÿå ÿ≠ÿßŸàŸÑ ŸÑÿßÿ≠ŸÇÿßŸã')
          }

          if (!user.passwordHash) {
            authLogger.warn({ userId: user.id }, 'No password hash for credentials login')
            throw new Error('ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä ÿ£Ÿà ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©')
          }

          const isValid = await comparePassword(validated.password, user.passwordHash)
          
          if (!isValid) {
            await prisma.user.update({
              where: { id: user.id },
              data: {
                loginAttempts: { increment: 1 },
                ...(user.loginAttempts + 1 >= 5 ? {
                  lockedUntil: new Date(Date.now() + 15 * 60 * 1000)
                } : {})
              }
            })
            authLogger.warn({ userId: user.id }, 'Invalid password attempt')
            throw new Error('ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä ÿ£Ÿà ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©')
          }

          await prisma.user.update({
            where: { id: user.id },
            data: {
              loginAttempts: 0,
              lockedUntil: null,
              lastLogin: new Date()
            }
          })

          authLogger.info({ userId: user.id }, 'User authenticated successfully')
          
          return {
            id: user.id,
            name: user.name,
            email: user.email,
            role: user.role as UserRole,
            isActive: user.isActive,
            isVerified: user.isVerified
          }

        } catch (error: any) {
          if (error instanceof Error && error.message.includes('RateLimiter')) {
            authLogger.warn({ email: credentials?.email }, 'Rate limit exceeded')
            throw new Error('ŸÑŸÇÿØ ÿ™ÿ¨ÿßŸàÿ≤ÿ™ ÿßŸÑÿ≠ÿØ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ ÿ®Ÿá ŸÖŸÜ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿßÿ™')
          }
          authLogger.error({ error }, 'Authentication error')
          throw new Error(error.message || 'ŸÅÿ¥ŸÑ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ')
        }
      }
    }),

    GoogleProvider({
      clientId: ENV.GOOGLE_CLIENT_ID || '',
      clientSecret: ENV.GOOGLE_CLIENT_SECRET || '',
      authorization: {
        params: {
          prompt: "consent",
          access_type: "offline",
          response_type: "code",
          scope: "openid email profile"
        }
      },
      async profile(profile) {
        const normalizedEmail = normalizeEmail(profile.email)
        
        try {
          let user = await prisma.user.findUnique({
            where: { email: normalizedEmail }
          })

          if (!user) {
            user = await prisma.user.create({
              data: {
                email: normalizedEmail,
                name: profile.name || profile.email.split('@')[0],
                passwordHash: null,
                role: USER_ROLES.PLAYER,
                isActive: true,
                isVerified: true,
                lastLogin: new Date(),
                phone: null,
                phoneNumber: null,
                age: null,
                description: null,
                skillLevel: 'AVERAGE'
              }
            })
            authLogger.info({ userId: user.id }, 'New OAuth user created')
          } else {
            await prisma.user.update({
              where: { id: user.id },
              data: { 
                lastLogin: new Date(),
                name: profile.name || user.name
              }
            })
          }

          if (!user.isActive) {
            authLogger.warn({ userId: user.id }, 'Inactive OAuth account')
            throw new Error('ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿ∫Ÿäÿ± ŸÜÿ¥ÿ∑')
          }

          authLogger.info({ userId: user.id }, 'OAuth user authenticated')
          
          return {
            id: user.id,
            name: user.name,
            email: user.email,
            role: user.role as UserRole,
            isActive: user.isActive,
            isVerified: user.isVerified
          }
        } catch (error: any) {
          authLogger.error({ error }, 'OAuth profile error')
          throw error
        }
      }
    })
  ],

  session: {
    strategy: 'jwt',
    maxAge: 30 * 24 * 60 * 60,
  },

  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id
        token.role = (user as any).role
        token.isActive = (user as any).isActive
        token.isVerified = (user as any).isVerified
      }
      return token
    },

    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.id as string
        session.user.role = token.role as UserRole
        session.user.isActive = token.isActive as boolean
        session.user.isVerified = token.isVerified as boolean
      }
      return session
    },

    async signIn() {
      try {
        return true
      } catch (error) {
        authLogger.error({ error }, 'Sign in callback error')
        return false
      }
    },

    async redirect({ url, baseUrl }) {
      if (url.startsWith('/')) {
        return `${baseUrl}${url}`
      } else if (new URL(url).origin === baseUrl) {
        return url
      }
      return baseUrl
    }
  },

  pages: {
    signIn: '/login',
    signOut: '/login',
    error: '/login'
  },

  debug: ENV.NODE_ENV === 'development',
  secret: ENV.NEXTAUTH_SECRET
}
// lib/domain/slots/read-model.ts
import { SLOT_STATUS } from '@/lib/shared/constants'  // ‚úÖ ÿßŸÑŸÖÿ≥ÿßÿ± ÿßŸÑÿ¨ÿØŸäÿØ
import { DomainError } from '@/lib/core/errors/domain-errors'  // ‚úÖ ÿßŸÑŸÖÿ≥ÿßÿ± ÿßŸÑÿ¨ÿØŸäÿØ

export type UISlotView = {
  id: string
  startTime: Date
  endTime: Date
  uiStatus: 'AVAILABLE' | 'LOCKED_ME' | 'LOCKED_OTHER' | 'BOOKED'
  originalStatus: string
  price: number
  deposit: number
  metadata?: {
    needsConfirmation?: boolean
    lockedUntil?: Date
    lockedByUserId?: string
  }
}

export class SlotReadModel {
  static toUISlot(dbSlot: any, currentUserId?: string | null): UISlotView {
    const now = new Date()
    const startTime = new Date(dbSlot.startTime)
    
    const dbStatus = this.normalizeDbStatus(dbSlot.status)
    
    let uiStatus: UISlotView['uiStatus']
    let needsConfirmation = false

    switch (dbStatus) {
      case SLOT_STATUS.BOOKED:
        uiStatus = 'BOOKED'
        break

      case SLOT_STATUS.TEMP_LOCKED:
        if (dbSlot.lockedByUserId === currentUserId) {
          uiStatus = 'LOCKED_ME'
        } else {
          uiStatus = 'LOCKED_OTHER'
        }
        break

      case SLOT_STATUS.AVAILABLE:
        uiStatus = 'AVAILABLE'
        const diffHours = (startTime.getTime() - now.getTime()) / (1000 * 60 * 60)
        if (diffHours < 24) {
          needsConfirmation = true
        }
        break

      default:
        throw new DomainError(
          'SLOT_NOT_FOUND', 
          `ÿ≠ÿßŸÑÿ© ÿ∫Ÿäÿ± ŸÇÿßÿ®ŸÑÿ© ŸÑŸÑÿπÿ±ÿ∂: ${dbSlot.status}`
        )
    }

    return {
      id: dbSlot.id,
      startTime,
      endTime: new Date(dbSlot.endTime),
      uiStatus,
      originalStatus: dbSlot.status,
      price: dbSlot.price,
      deposit: dbSlot.deposit,
      metadata: {
        needsConfirmation,
        lockedUntil: dbSlot.lockedUntil ? new Date(dbSlot.lockedUntil) : undefined,
        lockedByUserId: dbSlot.lockedByUserId
      }
    }
  }
  
  private static normalizeDbStatus(dbStatus: string): string {
    switch (dbStatus) {
      case SLOT_STATUS.AVAILABLE:
      case 'AVAILABLE_NEEDS_CONFIRM':
      case 'PENDING_CONFIRMATION':
        return SLOT_STATUS.AVAILABLE
      case SLOT_STATUS.TEMP_LOCKED:
        return SLOT_STATUS.TEMP_LOCKED
      case SLOT_STATUS.BOOKED:
        return SLOT_STATUS.BOOKED
      case SLOT_STATUS.UNAVAILABLE:
        return SLOT_STATUS.UNAVAILABLE
      default:
        return SLOT_STATUS.UNAVAILABLE
    }
  }

  static filterVisibleSlots(dbSlots: any[], currentUserId?: string | null): UISlotView[] {
    return dbSlots
      .map((slot: any) => this.toUISlot(slot, currentUserId)) // ‚úÖ ÿ£ÿ∂ŸÅ type ŸáŸÜÿß
      .filter(slot => ['AVAILABLE', 'LOCKED_ME', 'LOCKED_OTHER', 'BOOKED'].includes(slot.uiStatus))
  }

  static async getAvailableSlots(fieldId: string, date: Date, userId?: string): Promise<UISlotView[]> {
    const { prisma } = await import('@/lib/infrastructure/database/prisma')  // ‚úÖ ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ ÿØŸäŸÜÿßŸÖŸäŸÉŸä
    
    const dayStart = new Date(date.getFullYear(), date.getMonth(), date.getDate())
    const dayEnd = new Date(dayStart.getTime() + 24 * 60 * 60 * 1000)

    const dbSlots = await prisma.slot.findMany({
      where: {
        fieldId,
        startTime: {
          gte: dayStart,
          lt: dayEnd
        }
      },
      include: {
        bookings: {
          where: {
            status: { in: ['CONFIRMED', 'PENDING_PAYMENT'] }
          }
        }
      }
    })

    const availableSlots = dbSlots.filter((slot: any) => {
      // ÿßÿ≥ÿ™ÿ®ÿπÿßÿØ ÿßŸÑÿ≥ŸÑÿßÿ™ ÿßŸÑŸÖÿ≠ÿ¨Ÿàÿ≤ÿ©
      const hasActiveBooking = slot.bookings.length > 0
      if (hasActiveBooking) return false
      
      // ÿßÿ≥ÿ™ÿ®ÿπÿßÿØ ÿßŸÑÿ≥ŸÑÿßÿ™ ÿ∫Ÿäÿ± ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©
      if (slot.status === SLOT_STATUS.UNAVAILABLE) return false
      
      // ÿßŸÑÿ≥ŸÖÿßÿ≠ ÿ®ÿßŸÑÿ≥ŸÑÿßÿ™ ÿßŸÑŸÖÿ™ÿßÿ≠ÿ© ÿ£Ÿà ÿßŸÑŸÖŸÇŸÅŸàŸÑÿ© ÿ®Ÿàÿßÿ≥ÿ∑ÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
      if (slot.status === SLOT_STATUS.TEMP_LOCKED && slot.lockedByUserId !== userId) {
        return false
      }
      
      return true
    })

    return this.filterVisibleSlots(availableSlots, userId)
  }
}

export function getUISlots(slots: any[], userId?: string): UISlotView[] {
  return SlotReadModel.filterVisibleSlots(slots, userId)
}
//lib/domain/slots/time-slots/booking-limits.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { startOfDay, addDays } from 'date-fns'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { BOOKING_STATUS } from '@/lib/shared/constants'

type BookingWithSlot = {
  slot: {
    startTime: Date
    endTime: Date
    durationMinutes: number | null
  }
}

export async function checkBookingLimits({
  userId,
  slotDate,
  slotDurationMin
}: {
  userId: string
  slotDate: Date
  slotDurationMin: number
}) {
  const dayStart = startOfDay(slotDate)
  const dayEnd = addDays(dayStart, 1)

  const dayOfWeek = dayStart.getDay()
  const weekStart = addDays(dayStart, -dayOfWeek)
  const weekEnd = addDays(weekStart, 7)

  const dailyBookings: BookingWithSlot[] = await prisma.booking.findMany({
    where: {
      userId,
      status: {
        in: [BOOKING_STATUS.CONFIRMED, BOOKING_STATUS.PENDING_PAYMENT]
      },
      slot: {
        startTime: { gte: dayStart, lt: dayEnd }
      }
    },
    include: {
      slot: {
        select: {
          startTime: true,
          endTime: true,
          durationMinutes: true
        }
      }
    }
  })

  const dailyMinutes = dailyBookings.reduce((sum: number, booking: BookingWithSlot) => {
    if (booking.slot.durationMinutes) {
      return sum + booking.slot.durationMinutes
    }
    const start = new Date(booking.slot.startTime)
    const end = new Date(booking.slot.endTime)
    const diffMinutes = Math.round((end.getTime() - start.getTime()) / (1000 * 60))
    return sum + diffMinutes
  }, 0)

  if (dailyMinutes + slotDurationMin > 120) {
    throw new DomainError('BOOKING_LIMIT_EXCEEDED', 'ŸàÿµŸÑÿ™ ŸÑŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ÿßŸÑŸäŸàŸÖŸä (ÿ≥ÿßÿπÿ™ŸäŸÜ)')
  }

  const weeklyBookings: BookingWithSlot[] = await prisma.booking.findMany({
    where: {
      userId,
      status: {
        in: [BOOKING_STATUS.CONFIRMED, BOOKING_STATUS.PENDING_PAYMENT]
      },
      slot: {
        startTime: { gte: weekStart, lt: weekEnd }
      }
    },
    include: {
      slot: {
        select: {
          startTime: true,
          endTime: true,
          durationMinutes: true
        }
      }
    }
  })

  const weeklyMinutes = weeklyBookings.reduce((sum: number, booking: BookingWithSlot) => {
    if (booking.slot.durationMinutes) {
      return sum + booking.slot.durationMinutes
    }
    const start = new Date(booking.slot.startTime)
    const end = new Date(booking.slot.endTime)
    const diffMinutes = Math.round((end.getTime() - start.getTime()) / (1000 * 60))
    return sum + diffMinutes
  }, 0)

  if (weeklyMinutes + slotDurationMin > 240) {
    throw new DomainError('BOOKING_LIMIT_EXCEEDED', 'ŸàÿµŸÑÿ™ ŸÑŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ÿßŸÑÿ£ÿ≥ÿ®ŸàÿπŸä (4 ÿ≥ÿßÿπÿßÿ™)')
  }

  return true
}
// lib/domain/slots/time-slots/core-logic.ts
import { addMinutes, startOfDay, addDays, getHours, getMinutes } from 'date-fns'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { SLOT_STATUS, FIELD_STATUS } from '@/lib/shared/constants'
import { DomainError } from '@/lib/core/errors/domain-errors'

// ‚úÖ ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ ÿßŸÑÿ£ŸÜŸàÿßÿπ ÿßŸÑŸÖŸàÿ≠ÿØÿ© ÿ£Ÿà ÿ™ÿπÿ±ŸäŸÅŸáÿß ŸÖÿ≠ŸÑŸäÿßŸã ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©
import type { Day, Slot, SlotStatus } from '@/lib/core/types'

const CONFIRMATION_WINDOW_HOURS = 24
const LOCK_DURATION_MINUTES = 5

function normalizeToMinute(date: Date): number {
  return Math.floor(date.getTime() / 60000) * 60000
}

export function canBookDirectly(start: Date): boolean {
  const diffMs = start.getTime() - Date.now()
  const diffHours = diffMs / (1000 * 60 * 60)
  return diffHours >= CONFIRMATION_WINDOW_HOURS
}

function normalizeDbStatus(status: string | null | undefined): SlotStatus {
  if (!status) return SLOT_STATUS.AVAILABLE
  switch (status) {
    case SLOT_STATUS.AVAILABLE:
    case SLOT_STATUS.TEMP_LOCKED:
    case SLOT_STATUS.BOOKED:
    case SLOT_STATUS.UNAVAILABLE:
      return status as SlotStatus
    case 'AVAILABLE_NEEDS_CONFIRM':
    case 'PENDING_CONFIRMATION':
      return SLOT_STATUS.AVAILABLE as SlotStatus
    default:
      return SLOT_STATUS.UNAVAILABLE as SlotStatus
  }
}

function resolveSlotStatus({
  field,
  slotStart,
  dbSlot,
  now
}: {
  field: any
  slotStart: Date
  dbSlot?: any
  now: Date
}): SlotStatus | null {
  const diffMs = slotStart.getTime() - now.getTime()
  const diffHours = diffMs / (1000 * 60 * 60)

  if (diffHours < 0) return null

  if (field.status !== FIELD_STATUS.OPEN && !dbSlot) {
    return SLOT_STATUS.UNAVAILABLE as SlotStatus
  }

  if (dbSlot) {
    const dbStatus = normalizeDbStatus(dbSlot.status)

    if (
      dbStatus === SLOT_STATUS.TEMP_LOCKED &&
      dbSlot.lockedUntil &&
      new Date(dbSlot.lockedUntil) > now
    ) {
      return SLOT_STATUS.TEMP_LOCKED as SlotStatus
    }

    if (dbStatus === SLOT_STATUS.BOOKED) {
      return SLOT_STATUS.BOOKED as SlotStatus
    }

    if (dbStatus === SLOT_STATUS.UNAVAILABLE) {
      return SLOT_STATUS.UNAVAILABLE as SlotStatus
    }
  }

  return SLOT_STATUS.AVAILABLE as SlotStatus
}

export async function generateSlotsForDay({
  fieldId,
  date,
  now
}: {
  fieldId: string
  date: Date
  now: Date
}) {
  const field = await prisma.field.findUnique({
    where: { id: fieldId }
  })

  if (!field) {
    throw new DomainError('FIELD_NOT_FOUND')
  }

  const dayStart = startOfDay(date)
  const dayEnd = addDays(dayStart, 1)

  const existingSlots = await prisma.slot.findMany({
    where: {
      fieldId,
      startTime: {
        gte: dayStart,
        lt: dayEnd
      }
    }
  })

  const slotsMap = new Map<number, any>(
    existingSlots.map((slot: any) => [
      normalizeToMinute(new Date(slot.startTime)),
      slot
    ])
  )

  const openH = getHours(field.openingTime)
  const openM = getMinutes(field.openingTime)
  const closeH = getHours(field.closingTime)
  const closeM = getMinutes(field.closingTime)

  let current = startOfDay(date)
  current.setHours(openH, openM, 0, 0)

  const end = startOfDay(date)
  end.setHours(closeH, closeM, 0, 0)

  const slots: Slot[] = []

  while (addMinutes(current, field.slotDurationMin) <= end) {
    const slotStart = new Date(current)
    const slotEnd = addMinutes(slotStart, field.slotDurationMin)

    const key = normalizeToMinute(slotStart)
    const dbSlot = slotsMap.get(key)

    const status = resolveSlotStatus({
      field,
      slotStart,
      dbSlot,
      now
    })

    if (status) {
      slots.push({
        id: dbSlot?.id ?? `${fieldId}-${slotStart.toISOString()}`,
        fieldId,
        startTime: slotStart,
        endTime: slotEnd,
        status,
        price: field.pricePerHour,
        deposit: field.depositPrice
      } as Slot)
    }

    current = slotEnd
  }

  return slots
}

export async function generateSlotsForRange({
  fieldId,
  startDate,
  endDate,
  now
}: {
  fieldId: string
  startDate: Date
  endDate: Date
  now: Date
}) {
  const allSlots: Slot[] = []
  let currentDate = startOfDay(startDate)

  while (currentDate <= endDate) {
    const daySlots = await generateSlotsForDay({
      fieldId,
      date: currentDate,
      now
    })

    allSlots.push(...daySlots)
    currentDate = addDays(currentDate, 1)
  }

  return allSlots
}

export async function lockSlot({
  slotId,
  userId
}: {
  slotId: string
  userId: string
}) {
  const now = new Date()

  return await prisma.$transaction(async (tx: any) => {
    const slot = await tx.slot.findUnique({
      where: { id: slotId }
    })

    if (!slot) {
      throw new DomainError('SLOT_NOT_FOUND')
    }

    const status = normalizeDbStatus(slot.status)
    const canLock = status === SLOT_STATUS.AVAILABLE

    if (!canLock) {
      throw new DomainError('SLOT_UNAVAILABLE')
    }

    await tx.slot.update({
      where: { id: slotId },
      data: {
        status: SLOT_STATUS.TEMP_LOCKED,
        lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES),
        lockedByUserId: userId
      }
    })

    return { success: true }
  })
}

// ‚úÖ ÿ™ÿπÿØŸäŸÑ generateNextDays ŸÑŸäŸàŸÑŸëÿØ ŸÉŸÑ ÿßŸÑÿÆÿµÿßÿ¶ÿµ ÿßŸÑÿ¨ÿØŸäÿØÿ©
export function generateNextDays(count: number = 10): Day[] {
  const days: Day[] = []
  const today = startOfDay(new Date())

  for (let i = 0; i < count; i++) {
    const date = addDays(today, i)

    const weekday = date.toLocaleDateString('ar-EG', { weekday: 'long' })
    const dayNumber = date.toLocaleDateString('ar-EG', { day: 'numeric' })
    const monthName = date.toLocaleDateString('ar-EG', { month: 'long' })

    days.push({
      date: date.toISOString(),
      isWeekend: [5, 6].includes(date.getDay()), // ÿßŸÑÿ¨ŸÖÿπÿ©/ÿßŸÑÿ≥ÿ®ÿ™
      slotsAvailable: 0,
      slots: [],
      isToday: i === 0,
      isTomorrow: i === 1,
      weekday,
      dayNumber,
      monthName
    } as Day)
  }

  return days
}

export function generateNextTenDays(): Day[] {
  return generateNextDays(10)
}
// lib/domain/guards/slot-guards.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { SLOT_STATUS } from '@/lib/shared/constants'
import { StateTransitionValidator } from '@/lib/application/services/booking-transitions'

export class SlotStateGuard {
  static async assertCanBeLocked(params: {
    slotId: string
    userId: string
    fieldId: string
  }) {
    const slot = await prisma.slot.findUnique({
      where: { id: params.slotId },
      include: { field: true }
    })

    if (!slot) {
      throw new DomainError('SLOT_NOT_FOUND')
    }

    if (slot.fieldId !== params.fieldId) {
      throw new DomainError('SLOT_NOT_FOUND', 'ÿßŸÑŸÖŸàÿπÿØ ŸÑÿß ŸäŸÜÿ™ŸÖŸä ŸÑŸáÿ∞ÿß ÿßŸÑŸÖŸÑÿπÿ®')
    }

    const now = new Date()

    if (slot.status === SLOT_STATUS.BOOKED) {
      throw new DomainError('SLOT_ALREADY_BOOKED')
    }

    // ÿ•ÿµŸÑÿßÿ≠: ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÖŸÇÿßÿ±ŸÜÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©
    if (slot.status === SLOT_STATUS.UNAVAILABLE) {
      throw new DomainError('SLOT_UNAVAILABLE')
    }

    if (new Date(slot.startTime) <= now) {
      throw new DomainError('TIME_IN_PAST')
    }

    if (slot.status === SLOT_STATUS.TEMP_LOCKED && slot.lockedUntil && slot.lockedUntil > now) {
      if (slot.lockedByUserId === params.userId) {
        return { slot, canExtend: true }
      } else {
        throw new DomainError('SLOT_LOCKED_BY_OTHER')
      }
    }

    return { slot, canExtend: false }
  }

  static async assertIsLockedToUser(params: {
    slotId: string
    userId: string
  }) {
    const slot = await prisma.slot.findUnique({
      where: { id: params.slotId }
    })

    if (!slot) {
      throw new DomainError('SLOT_NOT_FOUND')
    }

    const now = new Date()

    // ÿ•ÿµŸÑÿßÿ≠: ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÖŸÇÿßÿ±ŸÜÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© ŸÖÿπ ÿßŸÑÿ´ÿßÿ®ÿ™
    if (slot.status !== SLOT_STATUS.TEMP_LOCKED) {
      throw new DomainError('SLOT_CANNOT_BE_LOCKED', 'ÿßŸÑŸÖŸàÿπÿØ ÿ∫Ÿäÿ± ŸÖŸÇŸÅŸàŸÑ')
    }

    if (!slot.lockedUntil || slot.lockedUntil <= now) {
      throw new DomainError('SLOT_LOCK_EXPIRED')
    }

    if (slot.lockedByUserId !== params.userId) {
      throw new DomainError('SLOT_LOCKED_BY_OTHER')
    }

    return slot
  }

  static async assertCanTransition(params: {
    slotId: string
    targetStatus: string
    userId?: string
  }) {
    const slot = await prisma.slot.findUnique({
      where: { id: params.slotId }
    })

    if (!slot) {
      throw new DomainError('SLOT_NOT_FOUND')
    }

    // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÄ validator ÿßŸÑÿ¨ÿØŸäÿØ ÿßŸÑÿ∞Ÿä Ÿäÿ±ŸÖŸä DomainError
    StateTransitionValidator.validateSlotTransition(
      slot.status,
      params.targetStatus,
      params.userId,
      slot
    )

    return slot
  }

  static async cleanupExpiredLocks() {
    const now = new Date()
    
    const result = await prisma.slot.updateMany({
      where: {
        status: SLOT_STATUS.TEMP_LOCKED,
        lockedUntil: { lt: now }
      },
      data: {
        status: SLOT_STATUS.AVAILABLE,
        lockedByUserId: null,
        lockedUntil: null
      }
    })

    return result.count
  }
}

export const assertSlotCanLock = SlotStateGuard.assertCanBeLocked.bind(SlotStateGuard)
export const assertSlotLocked = SlotStateGuard.assertIsLockedToUser.bind(SlotStateGuard)
export const assertSlotTransition = SlotStateGuard.assertCanTransition.bind(SlotStateGuard)
// lib/domain/guards/payment-guards.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { 
  PAYMENT_STATUS, 
  PaymentStatus,   // ‚úÖ ÿßŸÑŸÜŸàÿπ ÿ¨ÿßŸáÿ≤ ŸÖŸÜ constants
  BOOKING_STATUS
} from '@/lib/shared/constants'
import { StateTransitionValidator } from '@/lib/application/services/booking-transitions'

export class PaymentStateGuard {
  static async assertCanProcessPayment(params: {
    bookingId: string
    userId: string
  }) {
    const booking = await prisma.booking.findUnique({
      where: { id: params.bookingId },
      include: {
        slot: true,
        payments: {
          orderBy: { createdAt: 'desc' },
          take: 1
        }
      }
    })

    if (!booking) throw new DomainError('BOOKING_NOT_FOUND')
    if (booking.userId !== params.userId) throw new DomainError('BOOKING_NOT_OWNED')

    if (booking.status !== BOOKING_STATUS.DRAFT) {
      throw new DomainError(
        'BOOKING_INVALID_STATE',
        `ŸÑÿß ŸäŸÖŸÉŸÜ ÿßŸÑÿØŸÅÿπ ŸÑÿ≠ÿ¨ÿ≤ ÿ®ÿ≠ÿßŸÑÿ© ${booking.status}`
      )
    }

    if (booking.expiresAt && booking.expiresAt < new Date()) {
      throw new DomainError('BOOKING_EXPIRED')
    }

    if (booking.slot.status !== 'TEMP_LOCKED') {
      throw new DomainError('SLOT_LOCK_EXPIRED')
    }

    const lastPayment = booking.payments[0]
    if (lastPayment?.status === PAYMENT_STATUS.PAID) {
      throw new DomainError('PAYMENT_ALREADY_PROCESSED')
    }

    return { booking, lastPayment }
  }

  static async assertCanUpdatePayment(params: {
    paymentId: string
    targetStatus: PaymentStatus   // ‚úÖ ÿßŸÑŸÜŸàÿπ ÿßŸÑÿµÿ≠Ÿäÿ≠
    orderId?: string
  }) {
    const payment = await prisma.payment.findUnique({
      where: { id: params.paymentId },
      include: { booking: true }
    })

    if (!payment) throw new DomainError('PAYMENT_NOT_FOUND')

    if (params.orderId) {
      const existingWithOrderId = await prisma.payment.findUnique({
        where: { orderId: params.orderId }
      })
      
      if (existingWithOrderId && existingWithOrderId.id !== payment.id) {
        throw new DomainError('DUPLICATE_PAYMENT', 'ÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ orderId ŸÖÿ≥ÿ®ŸÇÿßŸã')
      }
    }

    const validation = StateTransitionValidator.validatePaymentTransition(
      payment.status,
      params.targetStatus,
      payment
    )

    if (!validation.allowed) {
      throw new DomainError('PAYMENT_FAILED', validation.reason)
    }

    return payment
  }

  static async assertWebhookValid(params: {
    orderId: string
    transactionId: string
    amount: number
  }) {
    const existingPayment = await prisma.payment.findUnique({
      where: { orderId: params.orderId }
    })

    if (existingPayment) {
      if (existingPayment.status === PAYMENT_STATUS.PAID) {
        throw new DomainError('PAYMENT_ALREADY_PROCESSED')
      }
      
      if (existingPayment.paymentId === params.transactionId) {
        throw new DomainError('DUPLICATE_PAYMENT', 'ÿ™ŸÖ ŸÖÿπÿßŸÑÿ¨ÿ© Ÿáÿ∞Ÿá ÿßŸÑÿπŸÖŸÑŸäÿ© ŸÖÿ≥ÿ®ŸÇÿßŸã')
      }
    }

    const payment = await prisma.payment.findFirst({
      where: { 
        orderId: params.orderId,
        status: PAYMENT_STATUS.PROCESSING
      },
      include: { 
        booking: {
          include: {
            slot: true,
            user: true
          }
        }
      }
    })

    if (!payment) {
      throw new DomainError('PAYMENT_NOT_FOUND', `ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿØŸÅÿπÿ© ÿ® orderId: ${params.orderId}`)
    }

    if (payment.amount !== params.amount) {
      throw new DomainError(
        'PAYMENT_FAILED',
        `ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿ∫Ÿäÿ± ŸÖÿ™ÿ∑ÿßÿ®ŸÇ: ÿßŸÑŸÖÿ™ŸàŸÇÿπ ${payment.amount}ÿå ÿßŸÑŸÖÿ≥ÿ™ŸÑŸÖ ${params.amount}`
      )
    }

    if (payment.booking.status !== BOOKING_STATUS.PENDING_PAYMENT) {
      throw new DomainError(
        'BOOKING_INVALID_STATE',
        `ÿ≠ÿßŸÑÿ© ÿßŸÑÿ≠ÿ¨ÿ≤ ÿ∫Ÿäÿ± ŸÖŸÜÿßÿ≥ÿ®ÿ©: ${payment.booking.status}`
      )
    }

    return payment
  }

  static async validatePaymentDetails(params: {
    paymentId: string
    userId: string
  }) {
    const payment = await prisma.payment.findUnique({
      where: { id: params.paymentId },
      include: { booking: true }
    })

    if (!payment) throw new DomainError('PAYMENT_NOT_FOUND')
    if (payment.booking.userId !== params.userId) throw new DomainError('BOOKING_NOT_OWNED')

    return payment
  }
}

// ‚úÖ Bind ÿßŸÑÿØŸàÿßŸÑ ÿπŸÑÿ¥ÿßŸÜ ÿ™ÿ≥ÿ™ÿÆÿØŸÖ ÿ®ÿ≥ŸáŸàŸÑÿ©
export const assertPaymentCanProcess = PaymentStateGuard.assertCanProcessPayment.bind(PaymentStateGuard)
export const assertPaymentUpdate = PaymentStateGuard.assertCanUpdatePayment.bind(PaymentStateGuard)
export const assertWebhookValid = PaymentStateGuard.assertWebhookValid.bind(PaymentStateGuard)
export const validatePaymentDetails = PaymentStateGuard.validatePaymentDetails.bind(PaymentStateGuard)
// lib/domain/guards/index.ts
export { 
  BookingGuard,
  assertBooking,
  assertSlotLocked,
  assertSlotCanLock 
} from './booking-guards'

export { 
  SlotStateGuard,
  assertSlotTransition 
} from './slot-guards'

export { 
  PaymentStateGuard,
  assertPaymentCanProcess,
  assertPaymentUpdate,
  assertWebhookValid 
} from './payment-guards'
// lib/domain/guards/booking-guards.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { 
  SLOT_STATUS, 
  BOOKING_STATUS 
} from '@/lib/shared/constants'
import { StateTransitionValidator } from '@/lib/application/services/booking-transitions'

export class BookingGuard {
  static async assertBookingState(params: {
    bookingId: string
    expectedStatuses: string[] // ‚úÖ ÿ•ÿµŸÑÿßÿ≠: ÿßÿ≥ÿ™ÿÆÿØŸÖ string[] ÿ®ÿØŸÑÿßŸã ŸÖŸÜ BOOKING_STATUS[]
    userId?: string
    customCheck?: (booking: any) => Promise<void>
  }) {
    const booking = await prisma.booking.findUnique({
      where: { id: params.bookingId },
      include: { 
        slot: true, 
        field: true,
        payments: {
          orderBy: { createdAt: 'desc' },
          take: 1
        }
      }
    })

    if (!booking) {
      throw new DomainError('BOOKING_NOT_FOUND')
    }

    if (params.userId && booking.userId !== params.userId) {
      throw new DomainError('BOOKING_NOT_OWNED')
    }

    if (!params.expectedStatuses.includes(booking.status)) {
      throw new DomainError(
        'BOOKING_INVALID_STATE',
        `ÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ© (${booking.status}) ŸÑÿß ÿ™ÿ≥ŸÖÿ≠ ÿ®Ÿáÿ∞Ÿá ÿßŸÑÿπŸÖŸÑŸäÿ©. ` +
        `ÿßŸÑÿ≠ÿßŸÑÿßÿ™ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ÿ©: ${params.expectedStatuses.join(', ')}`
      )
    }

    // ‚úÖ ÿ•ÿµŸÑÿßÿ≠: ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿ®ÿØŸÑÿßŸã ŸÖŸÜ ÿ™ÿ¨ÿßŸáŸÑŸáÿß
    try {
      // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≠ÿßŸÑÿ© ÿßŸÑŸÄ slot
      const slotValidation = StateTransitionValidator.validateCompleteBookingFlow(
        booking.slot.status,
        booking.status,
        booking.paymentStatus
      )
      
      // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿ•ÿ∞ÿß ŸÜÿ¨ÿ≠
      console.log('Slot validation passed:', slotValidation);
    } catch (error: any) {
      throw new DomainError('BOOKING_INVALID_STATE', error.message)
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ¢ÿÆÿ± ÿØŸÅÿπ
    const lastPayment = booking.payments[0]
    if (lastPayment) {
      try {
        const paymentValidation = StateTransitionValidator.validatePaymentTransition(
          lastPayment.status,
          booking.paymentStatus,
          lastPayment
        )
        
        // ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿ•ÿ∞ÿß ŸÜÿ¨ÿ≠
        console.log('Payment validation passed:', paymentValidation);
      } catch (error: any) {
        throw new DomainError('PAYMENT_FAILED', error.message)
      }
    }

    if (params.customCheck) {
      await params.customCheck(booking)
    }

    return booking
  }

  static async assertSlotLockedToUser(params: {
    slotId: string
    userId: string
  }) {
    const slot = await prisma.slot.findUnique({
      where: { id: params.slotId },
      include: {
        field: {
          select: { id: true, name: true }
        }
      }
    })

    if (!slot) {
      throw new DomainError('SLOT_NOT_FOUND')
    }

    const now = new Date()

    // ‚úÖ ÿ•ÿµŸÑÿßÿ≠: ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÖŸÇÿßÿ±ŸÜÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©
    if (slot.status !== SLOT_STATUS.TEMP_LOCKED) {
      throw new DomainError('SLOT_CANNOT_BE_LOCKED')
    }

    if (!slot.lockedUntil || slot.lockedUntil <= now) {
      throw new DomainError('SLOT_LOCK_EXPIRED')
    }

    if (slot.lockedByUserId !== params.userId) {
      throw new DomainError('SLOT_LOCKED_BY_OTHER', 
        `ÿßŸÑŸÖŸàÿπÿØ ŸÖŸÇŸÅŸàŸÑ ÿ®Ÿàÿßÿ≥ÿ∑ÿ© ŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ¢ÿÆÿ±. ÿßŸÑŸÖŸÑÿπÿ®: ${slot.field?.name || 'ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ'}`
      )
    }

    return slot
  }

  static async assertSlotCanBeLocked(params: {
    slotId: string
    userId: string
  }) {
    const slot = await prisma.slot.findUnique({
      where: { id: params.slotId },
      include: {
        field: {
          select: { id: true, name: true, status: true }
        }
      }
    })

    if (!slot) {
      throw new DomainError('SLOT_NOT_FOUND')
    }

    const now = new Date()

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≠ÿßŸÑÿ© ÿßŸÑŸÖŸÑÿπÿ®
    if (slot.field?.status !== 'OPEN') {
      throw new DomainError(
        'FIELD_NOT_FOUND',
        `ÿßŸÑŸÖŸÑÿπÿ® ${slot.field?.name || ''} ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ ÿ≠ÿßŸÑŸäÿßŸã`
      )
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≠ÿßŸÑÿ© ÿßŸÑŸÄ slot
    if (slot.status === SLOT_STATUS.BOOKED) {
      throw new DomainError('SLOT_ALREADY_BOOKED')
    }

    // ‚úÖ ÿ•ÿµŸÑÿßÿ≠: ÿ£ÿ≤ŸÑ ÿßŸÑŸÖŸÇÿßÿ±ŸÜÿ© ŸÖÿπ UNAVAILABLE ÿ£Ÿà ÿßÿ≥ÿ™ÿÆÿØŸÖ string ŸÖÿ®ÿßÿ¥ÿ±ÿ©
    if (slot.status === 'UNAVAILABLE') {
      throw new DomainError('SLOT_UNAVAILABLE')
    }

    if (new Date(slot.startTime) <= now) {
      throw new DomainError('TIME_IN_PAST')
    }

    if (
      slot.status === SLOT_STATUS.TEMP_LOCKED &&
      slot.lockedUntil &&
      slot.lockedUntil > now
    ) {
      if (slot.lockedByUserId === params.userId) {
        return { slot, canExtend: true }
      } else {
        throw new DomainError('SLOT_LOCKED_BY_OTHER')
      }
    }

    return { slot, canExtend: false }
  }

  // ÿØÿßŸÑÿ© ŸÖÿ≥ÿßÿπÿØÿ© ŸÑŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≠ÿØŸàÿØ ÿßŸÑÿ≠ÿ¨ÿ≤
  static async assertBookingLimits(params: {
    userId: string
    date: Date
    maxDailyBookings?: number
    maxWeeklyBookings?: number
  }) {
    const startOfDay = new Date(params.date)
    startOfDay.setHours(0, 0, 0, 0)
    
    const endOfDay = new Date(params.date)
    endOfDay.setHours(23, 59, 59, 999)

    const startOfWeek = new Date(params.date)
    startOfWeek.setDate(startOfWeek.getDate() - startOfWeek.getDay())
    startOfWeek.setHours(0, 0, 0, 0)
    
    const endOfWeek = new Date(startOfWeek)
    endOfWeek.setDate(endOfWeek.getDate() + 6)
    endOfWeek.setHours(23, 59, 59, 999)

    // ÿπÿØÿØ ÿßŸÑÿ≠ÿ¨Ÿàÿ≤ÿßÿ™ ÿßŸÑŸäŸàŸÖŸäÿ©
    const dailyBookings = await prisma.booking.count({
      where: {
        userId: params.userId,
        createdAt: {
          gte: startOfDay,
          lte: endOfDay
        },
        status: {
          in: [BOOKING_STATUS.CONFIRMED, 'PENDING_PAYMENT'] // ‚úÖ ÿßÿ≥ÿ™ÿÆÿØŸÖ string ŸÖÿ®ÿßÿ¥ÿ±ÿ©
        }
      }
    })

    // ÿπÿØÿØ ÿßŸÑÿ≠ÿ¨Ÿàÿ≤ÿßÿ™ ÿßŸÑÿ£ÿ≥ÿ®ŸàÿπŸäÿ©
    const weeklyBookings = await prisma.booking.count({
      where: {
        userId: params.userId,
        createdAt: {
          gte: startOfWeek,
          lte: endOfWeek
        },
        status: {
          in: [BOOKING_STATUS.CONFIRMED, 'PENDING_PAYMENT'] // ‚úÖ ÿßÿ≥ÿ™ÿÆÿØŸÖ string ŸÖÿ®ÿßÿ¥ÿ±ÿ©
        }
      }
    })

    const maxDaily = params.maxDailyBookings || 2
    const maxWeekly = params.maxWeeklyBookings || 5

    if (dailyBookings >= maxDaily) {
      throw new DomainError(
        'BOOKING_LIMIT_EXCEEDED',
        `ŸàÿµŸÑÿ™ ŸÑŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑŸÑÿ≠ÿ¨Ÿàÿ≤ÿßÿ™ ÿßŸÑŸäŸàŸÖŸäÿ© (${maxDaily})`
      )
    }

    if (weeklyBookings >= maxWeekly) {
      throw new DomainError(
        'BOOKING_LIMIT_EXCEEDED',
        `ŸàÿµŸÑÿ™ ŸÑŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑŸÑÿ≠ÿ¨Ÿàÿ≤ÿßÿ™ ÿßŸÑÿ£ÿ≥ÿ®ŸàÿπŸäÿ© (${maxWeekly})`
      )
    }

    return { dailyBookings, weeklyBookings }
  }
}

export const assertBooking = BookingGuard.assertBookingState.bind(BookingGuard)
export const assertSlotLocked = BookingGuard.assertSlotLockedToUser.bind(BookingGuard)
export const assertSlotCanLock = BookingGuard.assertSlotCanBeLocked.bind(BookingGuard)
export const assertBookingLimits = BookingGuard.assertBookingLimits.bind(BookingGuard)
// lib/domain/booking/types.ts
import { 
  BookingStatus, 
  PaymentStatus 
} from '@/lib/shared/constants'  // ‚úÖ ÿßŸÑŸÖÿ≥ÿßÿ± ÿßŸÑÿ¨ÿØŸäÿØ

export interface BookingCreateInput {
  slotId: string
  fieldId: string
  userId: string
  idempotencyKey?: string
}

export interface BookingCreateResult {
  bookingId: string
  needsConfirmation: boolean
  idempotencyKey?: string
}

export interface BookingUpdateInput {
  bookingId: string
  status?: BookingStatus
  paymentStatus?: PaymentStatus
  paymentId?: string
  orderId?: string
}

export interface PaymentInitInput {
  bookingId: string
  amount: number
  currency?: string
  idempotencyKey?: string
}

export interface PaymentInitResult {
  paymentUrl: string
  orderId: string
  idempotencyKey?: string
}

export interface SlotLockInput {
  slotId: string
  userId: string
  fieldId: string
}

export interface SlotLockResult {
  success: boolean
  locked?: boolean
  extended?: boolean
  lockedUntil?: Date
}

// Response types for APIs
export interface ApiResponse<T = any> {
  success: boolean
  data?: T
  error?: {
    code: string
    message: string
    details?: any
  }
  pagination?: {
    page: number
    limit: number
    total: number
    totalPages: number
    hasMore: boolean
  }
}

// Webhook types
export interface PaymobWebhookPayload {
  obj: {
    id: number
    amount_cents: number
    success: boolean
    order: {
      id: number
      merchant_order_id: string
    }
    created_at: number
    currency: string
    source_data?: any
  }
}

export type BookingWithRelations = any // ÿ≥Ÿäÿ≠ÿØÿØ ŸÖŸÜ Prisma
export type SlotWithRelations = any
// lib/core/types/index.ts
import { 
  SLOT_STATUS, 
  BOOKING_STATUS, 
  FIELD_STATUS, 
  FIELD_TYPES,
  PAYMENT_STATUS 
} from '@/lib/shared/constants'

export type SlotStatus = typeof SLOT_STATUS[keyof typeof SLOT_STATUS]
export type BookingStatus = typeof BOOKING_STATUS[keyof typeof BOOKING_STATUS]
export type FieldStatus = typeof FIELD_STATUS[keyof typeof FIELD_STATUS]
export type FieldType = typeof FIELD_TYPES[keyof typeof FIELD_TYPES]
export type PaymentStatus = typeof PAYMENT_STATUS[keyof typeof PAYMENT_STATUS]

export interface User {
  id: string
  email: string
  name: string
  phone?: string
  avatar?: string
  createdAt: Date
}

export interface Field {
  id: string
  name: string
  description?: string | null
  location: string
  address?: string | null
  pricePerHour: number
  depositPrice: number
  imageUrl?: string | null
  gallery: string[]
  type: FieldType
  status: FieldStatus
  openingTime: string
  closingTime: string
  slotDurationMin: number
  facilities: string[]
  rules: string[]
  rating: number
  reviewCount: number
  createdAt: Date
  updatedAt: Date
}

export interface Slot {
  id: string
  fieldId: string
  startTime: Date
  endTime: Date
  status: SlotStatus
  price: number
  deposit: number
  lockedUntil?: Date
  lockedByUserId?: string
}

export interface Booking {
  id: string
  userId: string
  fieldId: string
  slotId: string
  status: BookingStatus
  paymentStatus: PaymentStatus
  totalAmount: number
  depositPaid: number
  refundableUntil?: Date
  cancellationReason?: string
  createdAt: Date
  updatedAt: Date
  field?: Field
  slot?: Slot
  user?: User
}

export interface Payment {
  id: string
  bookingId: string
  amount: number
  currency: string
  paymentId: string
  orderId: string
  status: PaymentStatus
  metadata?: Record<string, any>
  createdAt: Date
}

// ‚úÖ Day type ÿßŸÑŸÖŸàÿ≥ÿπ ÿπÿ¥ÿßŸÜ Ÿäÿ™ŸàÿßŸÅŸÇ ŸÖÿπ DaySelector
export interface Day {
  date: string
  isWeekend: boolean
  slotsAvailable: number
  slots?: Slot[]
  isToday?: boolean
  isTomorrow?: boolean
  weekday?: string
  dayNumber?: string
  monthName?: string
}

// ‚úÖ SlotGridProps ŸÖÿπ userId ÿßÿÆÿ™Ÿäÿßÿ±Ÿä
export interface SlotGridProps {
  slots: Slot[]
  fieldId: string
  fieldName: string
  userId?: string
  onSlotSelect?: (slot: Slot) => void
}

// ‚úÖ ÿ™ÿπÿ±ŸäŸÅÿßÿ™ ŸÑŸÑŸÄ UI
export interface UISlot {
  id: string
  startTime: Date
  endTime: Date
  price: number
  deposit: number
  uiStatus: 'AVAILABLE' | 'LOCKED_ME' | 'LOCKED_OTHER' | 'BOOKED'
  needsConfirmation: boolean
}

export interface SlotBookingModalProps {
  slot: UISlot
  fieldId: string
  fieldName: string
  onClose: () => void
}
// lib/core/errors/error-codes.ts
export const ERROR_CODES = {
  // Auth (1xx)
  UNAUTHORIZED: 'AUTH_001',
  INVALID_CREDENTIALS: 'AUTH_002',
  SESSION_EXPIRED: 'AUTH_003',
  
  // Validation (2xx)
  VALIDATION_ERROR: 'VAL_004', // ‚úÖ ÿ£ÿ∂ŸÅ Ÿáÿ∞ÿß
  INVALID_INPUT: 'VAL_001',
  MISSING_FIELD: 'VAL_002',
  INVALID_DATE: 'VAL_003',
  
  // Slot (3xx)
  SLOT_NOT_FOUND: 'SLOT_001',
  SLOT_UNAVAILABLE: 'SLOT_002',
  SLOT_LOCKED_BY_OTHER: 'SLOT_003',
  SLOT_LOCK_EXPIRED: 'SLOT_004',
  SLOT_ALREADY_BOOKED: 'SLOT_005',
  SLOT_CANNOT_BE_LOCKED: 'SLOT_006',
  
  // Booking (4xx)
  BOOKING_NOT_FOUND: 'BOOK_001',
  BOOKING_NOT_OWNED: 'BOOK_002',
  BOOKING_INVALID_STATE: 'BOOK_003',
  BOOKING_LIMIT_EXCEEDED: 'BOOK_004',
  BOOKING_EXPIRED: 'BOOK_005',
  BOOKING_IN_PROGRESS: 'BOOK_006',
  
  // Payment (5xx)
  PAYMENT_ALREADY_PROCESSED: 'PAY_001',
  PAYMENT_FAILED: 'PAY_002',
  DUPLICATE_PAYMENT: 'PAY_003',
  PAYMENT_NOT_FOUND: 'PAY_004',
  
  // Time (6xx)
  TIME_IN_PAST: 'TIME_001',
  TIME_TOO_CLOSE: 'TIME_002',
  
  // Field (7xx)
  FIELD_NOT_FOUND: 'FIELD_001',
  FIELD_CLOSED: 'FIELD_002',
  FIELD_MAINTENANCE: 'FIELD_003',
  
  // System (9xx)
  INTERNAL_ERROR: 'SYS_001',
  RATE_LIMITED: 'SYS_002',
  SERVICE_UNAVAILABLE: 'SYS_003'
} as const

export type ErrorCode = typeof ERROR_CODES[keyof typeof ERROR_CODES]
export type ErrorCodeKey = keyof typeof ERROR_CODES
// lib/core/errors/domain-errors.ts
import { ERROR_CODES } from './error-codes'

const ERROR_MESSAGES: Record<keyof typeof ERROR_CODES, string> = {
  // Auth
  UNAUTHORIZED: 'ÿ∫Ÿäÿ± ŸÖÿµÿ±ÿ≠',
  INVALID_CREDENTIALS: 'ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿØÿÆŸàŸÑ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©',
  SESSION_EXPIRED: 'ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑÿ¨ŸÑÿ≥ÿ©ÿå Ÿäÿ±ÿ¨Ÿâ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ',
  
  // Validation
  INVALID_INPUT: 'ÿ®ŸäÿßŸÜÿßÿ™ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ©',
  MISSING_FIELD: 'ÿ≠ŸÇŸÑ ŸÖÿ∑ŸÑŸàÿ®',
  INVALID_DATE: 'ÿ™ÿßÿ±ŸäÿÆ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠',
  VALIDATION_ERROR: 'ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™',
  
  // Slot
  SLOT_NOT_FOUND: 'ÿßŸÑŸÖŸàÿπÿØ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ',
  SLOT_UNAVAILABLE: 'ÿßŸÑŸÖŸàÿπÿØ ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ ŸÑŸÑÿ≠ÿ¨ÿ≤',
  SLOT_LOCKED_BY_OTHER: 'ÿßŸÑŸÖŸàÿπÿØ ŸÖŸÇŸÅŸàŸÑ ŸÖÿ§ŸÇÿ™ÿßŸã',
  SLOT_LOCK_EXPIRED: 'ÿßŸÜÿ™Ÿáÿ™ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑŸÇŸÅŸÑ',
  SLOT_ALREADY_BOOKED: 'ÿßŸÑŸÖŸàÿπÿØ ŸÖÿ≠ÿ¨Ÿàÿ≤ ÿ®ÿßŸÑŸÅÿπŸÑ',
  SLOT_CANNOT_BE_LOCKED: 'ŸÑÿß ŸäŸÖŸÉŸÜ ŸÇŸÅŸÑ Ÿáÿ∞ÿß ÿßŸÑŸÖŸàÿπÿØ',
  
  // Booking
  BOOKING_NOT_FOUND: 'ÿßŸÑÿ≠ÿ¨ÿ≤ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ',
  BOOKING_NOT_OWNED: 'ÿ∫Ÿäÿ± ŸÖÿµÿ±ÿ≠ ÿ®ÿßŸÑŸàÿµŸàŸÑ ŸÑŸáÿ∞ÿß ÿßŸÑÿ≠ÿ¨ÿ≤',
  BOOKING_INVALID_STATE: 'ÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ© ŸÑÿß ÿ™ÿ≥ŸÖÿ≠ ÿ®Ÿáÿ∞Ÿá ÿßŸÑÿπŸÖŸÑŸäÿ©',
  BOOKING_LIMIT_EXCEEDED: 'ŸàÿµŸÑÿ™ ŸÑŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑŸÑÿ≠ÿ¨ÿ≤',
  BOOKING_EXPIRED: 'ÿßŸÜÿ™Ÿáÿ™ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑÿ≠ÿ¨ÿ≤',
  BOOKING_IN_PROGRESS: 'ÿ¨ÿßÿ±Ÿä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ∑ŸÑÿ®',
  
  // Payment
  PAYMENT_ALREADY_PROCESSED: 'ÿ™ŸÖ ÿØŸÅÿπ Ÿáÿ∞ÿß ÿßŸÑÿ≠ÿ¨ÿ≤ ŸÖÿ≥ÿ®ŸÇÿßŸã',
  PAYMENT_FAILED: 'ŸÅÿ¥ŸÑ ÿπŸÖŸÑŸäÿ© ÿßŸÑÿØŸÅÿπ',
  DUPLICATE_PAYMENT: 'ÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ orderId ŸÖÿ≥ÿ®ŸÇÿßŸã',
  PAYMENT_NOT_FOUND: 'ÿπŸÖŸÑŸäÿ© ÿßŸÑÿØŸÅÿπ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©',
  
  // Time
  TIME_IN_PAST: 'ŸÑÿß ŸäŸÖŸÉŸÜ ÿ≠ÿ¨ÿ≤ ŸàŸÇÿ™ ŸÖÿ∂Ÿâ',
  TIME_TOO_CLOSE: 'ÿßŸÑŸàŸÇÿ™ ŸÇÿ±Ÿäÿ® ÿ¨ÿØÿßŸã',
  
  // Field
  FIELD_NOT_FOUND: 'ÿßŸÑŸÖŸÑÿπÿ® ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ',
  FIELD_CLOSED: 'ÿßŸÑŸÖŸÑÿπÿ® ŸÖÿ∫ŸÑŸÇ ÿ≠ÿßŸÑŸäÿßŸã',
  FIELD_MAINTENANCE: 'ÿßŸÑŸÖŸÑÿπÿ® ÿ™ÿ≠ÿ™ ÿßŸÑÿµŸäÿßŸÜÿ©',
  
  // System
  INTERNAL_ERROR: 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ',
  RATE_LIMITED: 'ÿ™ŸÖ ÿ™ÿ¨ÿßŸàÿ≤ ÿßŸÑÿ≠ÿØ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠',
  SERVICE_UNAVAILABLE: 'ÿßŸÑÿÆÿØŸÖÿ© ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ÿ© ÿ≠ÿßŸÑŸäÿßŸã'
} as const

export class DomainError extends Error {
  constructor(
    public code: keyof typeof ERROR_CODES,
    message?: string,
    public details?: any
  ) {
    // ÿ≠ŸÑ ÿßŸÑŸÖÿ¥ŸÉŸÑÿ©: ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ message ÿØÿßÿ¶ŸÖŸãÿß string
    super(message || ERROR_MESSAGES[code] || code);
    this.name = 'DomainError';
    
    // ŸÑÿ≠ŸÅÿ∏ stack trace ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, DomainError);
    }
  }
  
  toResponse() {
    return {
      error: true,
      code: ERROR_CODES[this.code],
      message: this.message,
      details: this.details
    }
  }
  
  toJSON() {
    return this.toResponse()
  }
}

// Helper function for API responses
export function errorResponse(error: unknown) {
  if (error instanceof DomainError) {
    return {
      status: getStatusCode(error.code),
      body: error.toResponse()
    }
  }
  
  console.error('Unhandled error:', error)
  
  return {
    status: 500,
    body: {
      error: true,
      code: ERROR_CODES.INTERNAL_ERROR,
      message: 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ'
    }
  }
}

function getStatusCode(code: keyof typeof ERROR_CODES): number {
  const codeStr = ERROR_CODES[code]
  const codePrefix = codeStr ? codeStr.split('_')[0] : ''
  
  switch (codePrefix) {
    case 'AUTH':
      return 401
    case 'VAL':
      return 400
    case 'SLOT':
    case 'BOOK':
    case 'PAY':
    case 'TIME':
    case 'FIELD':
      return 400
    case 'SYS':
      return 500
    default:
      return 400
  }
}
// lib/application/services/booking-transitions.ts
import { 
  SLOT_STATUS, 
  BOOKING_STATUS, 
  PAYMENT_STATUS 
} from '@/lib/shared/constants'
import { DomainError } from '@/lib/core/errors/domain-errors'

export class StateTransitionValidator {
  // Slot transitions
  static canTransitionSlot(
    currentStatus: string,
    targetStatus: string,
    userId?: string,
    slotData?: any
  ): { allowed: boolean; reason?: string } {
    
    const allowedTransitions: Record<string, string[]> = {
      [SLOT_STATUS.AVAILABLE]: [
        SLOT_STATUS.TEMP_LOCKED,
        SLOT_STATUS.UNAVAILABLE
      ],
      [SLOT_STATUS.TEMP_LOCKED]: [
        SLOT_STATUS.AVAILABLE, // timeout or manual release
        SLOT_STATUS.BOOKED     // after payment success
      ],
      [SLOT_STATUS.BOOKED]: [
        SLOT_STATUS.AVAILABLE  // admin only
      ],
      [SLOT_STATUS.UNAVAILABLE]: [
        SLOT_STATUS.AVAILABLE  // admin only
      ]
    }

    if (!allowedTransitions[currentStatus]?.includes(targetStatus)) {
      return {
        allowed: false,
        reason: `ÿ∫Ÿäÿ± ŸÖÿ≥ŸÖŸàÿ≠ ÿßŸÑÿ™ÿ≠ŸàŸÑ ŸÖŸÜ ${currentStatus} ÿ•ŸÑŸâ ${targetStatus}`
      }
    }

    // Additional checks
    if (currentStatus === SLOT_STATUS.TEMP_LOCKED && targetStatus === SLOT_STATUS.AVAILABLE) {
      if (slotData?.lockedByUserId && slotData.lockedByUserId !== userId) {
        return {
          allowed: false,
          reason: 'ŸÑÿß ŸäŸÖŸÉŸÜ ÿ•ŸÑÿ∫ÿßÿ° ŸÇŸÅŸÑ ŸÖŸàÿπÿØ ŸÖŸÇŸÅŸàŸÑ ÿ®Ÿàÿßÿ≥ÿ∑ÿ© ŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ¢ÿÆÿ±'
        }
      }
    }

    if (currentStatus === SLOT_STATUS.BOOKED && targetStatus === SLOT_STATUS.AVAILABLE) {
      // Only admin can release booked slots
      if (userId && !this.isAdmin(userId)) {
        return {
          allowed: false,
          reason: 'ŸÅŸÇÿ∑ ÿßŸÑŸÖÿØŸäÿ± ŸäŸÖŸÉŸÜŸá ÿ•ŸÑÿ∫ÿßÿ° ÿ≠ÿ¨ÿ≤ ŸÖŸàÿπÿØ'
        }
      }
    }

    return { allowed: true }
  }

  // Helper method that throws DomainError
  static validateSlotTransition(
    currentStatus: string,
    targetStatus: string,
    userId?: string,
    slotData?: any
  ) {
    const validation = this.canTransitionSlot(currentStatus, targetStatus, userId, slotData)
    
    if (!validation.allowed) {
      throw new DomainError(
        'SLOT_CANNOT_BE_LOCKED',
        validation.reason
      )
    }
    
    return validation
  }

  // Booking transitions
  static canTransitionBooking(
    currentStatus: string,
    targetStatus: string,
    userId?: string,
    bookingData?: any
  ): { allowed: boolean; reason?: string } {
    
    const allowedTransitions: Record<string, string[]> = {
      [BOOKING_STATUS.DRAFT]: [
        BOOKING_STATUS.PENDING_PAYMENT,
        BOOKING_STATUS.EXPIRED,
        BOOKING_STATUS.CANCELLED
      ],
      [BOOKING_STATUS.PENDING_PAYMENT]: [
        BOOKING_STATUS.CONFIRMED,
        BOOKING_STATUS.FAILED,
        BOOKING_STATUS.CANCELLED
      ],
      [BOOKING_STATUS.CONFIRMED]: [
        BOOKING_STATUS.CANCELLED // with refund logic
      ],
      [BOOKING_STATUS.CANCELLED]: [],
      [BOOKING_STATUS.FAILED]: [],
      [BOOKING_STATUS.EXPIRED]: []
    }

    if (!allowedTransitions[currentStatus]?.includes(targetStatus)) {
      return {
        allowed: false,
        reason: `ÿ∫Ÿäÿ± ŸÖÿ≥ŸÖŸàÿ≠ ÿ™ÿ∫ŸäŸäÿ± ÿ≠ÿßŸÑÿ© ÿßŸÑÿ≠ÿ¨ÿ≤ ŸÖŸÜ ${currentStatus} ÿ•ŸÑŸâ ${targetStatus}`
      }
    }

    // Ownership check
    if (bookingData?.userId && userId && bookingData.userId !== userId) {
      if (!this.isAdmin(userId)) {
        return {
          allowed: false,
          reason: 'ŸÑÿß ŸäŸÖŸÉŸÜŸÉ ÿ™ÿπÿØŸäŸÑ ÿ≠ÿ¨ÿ≤ ŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ¢ÿÆÿ±'
        }
      }
    }

    return { allowed: true }
  }

  // Helper method that throws DomainError for bookings
  static validateBookingTransition(
    currentStatus: string,
    targetStatus: string,
    userId?: string,
    bookingData?: any
  ) {
    const validation = this.canTransitionBooking(currentStatus, targetStatus, userId, bookingData)
    
    if (!validation.allowed) {
      throw new DomainError(
        'BOOKING_INVALID_STATE',
        validation.reason
      )
    }
    
    return validation
  }

  // Payment transitions
  static canTransitionPayment(
    currentStatus: string,
    targetStatus: string,
    _paymentData?: any
  ): { allowed: boolean; reason?: string } {
    
    const allowedTransitions: Record<string, string[]> = {
      [PAYMENT_STATUS.PENDING]: [
        PAYMENT_STATUS.PROCESSING,
        PAYMENT_STATUS.FAILED
      ],
      [PAYMENT_STATUS.PROCESSING]: [
        PAYMENT_STATUS.PAID,
        PAYMENT_STATUS.FAILED
      ],
      [PAYMENT_STATUS.PAID]: [
        PAYMENT_STATUS.REFUNDED
      ],
      [PAYMENT_STATUS.FAILED]: [
        PAYMENT_STATUS.PROCESSING // retry
      ],
      [PAYMENT_STATUS.REFUNDED]: []
    }

    if (!allowedTransitions[currentStatus]?.includes(targetStatus)) {
      return {
        allowed: false,
        reason: `ÿ∫Ÿäÿ± ŸÖÿ≥ŸÖŸàÿ≠ ÿ™ÿ∫ŸäŸäÿ± ÿ≠ÿßŸÑÿ© ÿßŸÑÿØŸÅÿπ ŸÖŸÜ ${currentStatus} ÿ•ŸÑŸâ ${targetStatus}`
      }
    }

    return { allowed: true }
  }

  // Helper method that throws DomainError for payments
  static validatePaymentTransition(
    currentStatus: string,
    targetStatus: string,
    paymentData?: any
  ) {
    const validation = this.canTransitionPayment(currentStatus, targetStatus, paymentData)
    
    if (!validation.allowed) {
      throw new DomainError(
        'PAYMENT_FAILED',
        validation.reason
      )
    }
    
    return validation
  }

  // Helper to validate complete flow
  static validateBookingFlow(
    slotStatus: string,
    bookingStatus: string,
    paymentStatus: string
  ): string[] {
    const errors: string[] = []

    // Valid state combinations
    const validCombinations = [
      // Draft booking on locked slot
      { slot: SLOT_STATUS.TEMP_LOCKED, booking: BOOKING_STATUS.DRAFT, payment: PAYMENT_STATUS.PENDING },
      
      // Payment in progress
      { slot: SLOT_STATUS.TEMP_LOCKED, booking: BOOKING_STATUS.PENDING_PAYMENT, payment: PAYMENT_STATUS.PROCESSING },
      
      // Confirmed
      { slot: SLOT_STATUS.BOOKED, booking: BOOKING_STATUS.CONFIRMED, payment: PAYMENT_STATUS.PAID },
      
      // Failed/Cancelled
      { slot: SLOT_STATUS.AVAILABLE, booking: BOOKING_STATUS.FAILED, payment: PAYMENT_STATUS.FAILED },
      { slot: SLOT_STATUS.AVAILABLE, booking: BOOKING_STATUS.CANCELLED, payment: PAYMENT_STATUS.REFUNDED },
      { slot: SLOT_STATUS.AVAILABLE, booking: BOOKING_STATUS.EXPIRED, payment: PAYMENT_STATUS.FAILED }
    ]

    const isValid = validCombinations.some(combo => 
      combo.slot === slotStatus && 
      combo.booking === bookingStatus && 
      combo.payment === paymentStatus
    )

    if (!isValid) {
      errors.push(`ŸÖÿ¨ŸÖŸàÿπÿ© ÿßŸÑÿ≠ÿßŸÑÿßÿ™ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ©: Slot=${slotStatus}, Booking=${bookingStatus}, Payment=${paymentStatus}`)
    }

    return errors
  }

  // Helper method that throws DomainError for complete flow
  static validateCompleteBookingFlow(
    slotStatus: string,
    bookingStatus: string,
    paymentStatus: string
  ) {
    const errors = this.validateBookingFlow(slotStatus, bookingStatus, paymentStatus)
    
    if (errors.length > 0) {
      throw new DomainError(
        'BOOKING_INVALID_STATE',
        errors.join(' | ')
      )
    }
    
    return { valid: true }
  }

  private static isAdmin(_userId: string): boolean {
    // TODO: Implement admin check from database
    // For now, return false
    return false
  }
}
// lib/application/services/booking-orchestrator.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { addMinutes } from 'date-fns'
import { 
  SLOT_STATUS, 
  BOOKING_STATUS, 
  PAYMENT_STATUS 
} from '@/lib/shared/constants'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { IdempotencyGuard } from '@/lib/application/idempotency/idempotency-guard'
import { checkBookingLimits } from '@/lib/domain/slots/time-slots/booking-limits'
import { notificationService } from '@/lib/infrastructure/notifications/notification-service'
import { paymobService } from '@/lib/infrastructure/payments/providers'
import { bookingLogger } from '@/lib/shared/logger'
import type { 
  BookingCreateInput, 
  BookingCreateResult,
  PaymentInitInput,
  PaymentInitResult
} from '@/lib/domain/booking/types'
import { ENV } from '@/lib/shared/env/env'

export class BookingOrchestrator {
  /**
   * üé´ 1. ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ¨ÿ≤ ÿ¨ÿØŸäÿØ
   */
  static async createBooking(input: BookingCreateInput): Promise<BookingCreateResult> {
    const startTime = Date.now()
    const requestId = `booking_create_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

    bookingLogger.info({
      msg: 'Creating booking',
      requestId,
      userId: input.userId,
      slotId: input.slotId,
      fieldId: input.fieldId,
      idempotencyKey: input.idempotencyKey
    })

    try {
      // üîê Idempotency check
      if (input.idempotencyKey) {
        const check = await IdempotencyGuard.check(
          input.idempotencyKey,
          input.userId,
          'booking:create',
          { slotId: input.slotId, fieldId: input.fieldId }
        )

        if (!check.shouldProceed) {
          if (check.response) {
            bookingLogger.info({
              msg: 'Idempotent response returned',
              requestId
            })
            return check.response as BookingCreateResult
          }
          throw new DomainError('BOOKING_IN_PROGRESS', 'ÿ¨ÿßÿ±Ÿä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ∑ŸÑÿ®')
        }
      }

      const result = await prisma.$transaction(async (tx: any) => {
        // 1. üîê ÿ™ÿ£ŸÉÿØ ÿ£ŸÜ Slot ŸÖŸÇŸÅŸàŸÑÿ© ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
        const slot = await tx.slot.findUnique({
          where: {
            id: input.slotId,
            fieldId: input.fieldId,
            status: SLOT_STATUS.TEMP_LOCKED,
            lockedByUserId: input.userId,
            lockedUntil: { gt: new Date() }
          },
          include: { field: true }
        })

        if (!slot) {
          throw new DomainError('SLOT_NOT_FOUND', 'ÿßŸÑŸÖŸàÿπÿØ ŸÑŸÖ ŸäÿπÿØ ŸÖÿ™ÿßÿ≠ÿßŸã ÿ£Ÿà ÿßŸÜÿ™ŸáŸâ ŸÇŸÅŸÑŸá')
        }

        // 2. üìè ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≠ÿØŸàÿØ ÿßŸÑÿ≠ÿ¨ÿ≤
        await checkBookingLimits({
          userId: input.userId,
          slotDate: new Date(slot.startTime),
          slotDurationMin: slot.durationMinutes || 60
        })

        // 3. üé´ ÿ•ŸÜÿ¥ÿßÿ° Booking
        const booking = await tx.booking.create({
          data: {
            userId: input.userId,
            fieldId: input.fieldId,
            slotId: input.slotId,
            status: BOOKING_STATUS.DRAFT,
            paymentStatus: PAYMENT_STATUS.PENDING,
            totalAmount: slot.price,
            expiresAt: addMinutes(new Date(), 10),
            idempotencyKey: input.idempotencyKey || null
          }
        })

        const result: BookingCreateResult = {
          bookingId: booking.id,
          needsConfirmation: !this.canBookDirectly(new Date(slot.startTime))
        }

        // üíæ ÿ≠ŸÅÿ∏ ŸÑŸÑŸÄ Idempotency
        if (input.idempotencyKey) {
          await IdempotencyGuard.saveResponse(
            input.idempotencyKey,
            input.userId,
            'booking:create',
            result,
            { slotId: input.slotId, fieldId: input.fieldId },
            60
          )
        }

        bookingLogger.info({
          msg: 'Booking created successfully',
          requestId,
          bookingId: booking.id,
          durationMs: Date.now() - startTime
        })

        return result
      })

      return result

    } catch (error: any) {
      bookingLogger.error({
        msg: 'Booking creation failed',
        requestId,
        error: error.message,
        userId: input.userId,
        durationMs: Date.now() - startTime
      })
      
      if (error instanceof DomainError) {
        throw error
      }
      throw new DomainError('INTERNAL_ERROR', 'ŸÅÿ¥ŸÑ ŸÅŸä ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ≠ÿ¨ÿ≤')
    }
  }

  /**
   * üí≥ 2. ÿ®ÿØÿ° ÿπŸÖŸÑŸäÿ© ÿßŸÑÿØŸÅÿπ
   */
  static async initiatePayment(input: PaymentInitInput & { userId: string }): Promise<PaymentInitResult> {
    const startTime = Date.now()
    const requestId = `payment_init_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

    bookingLogger.info({
      msg: 'Initiating payment',
      requestId,
      bookingId: input.bookingId,
      userId: input.userId,
      amount: input.amount
    })

    try {
      // 1. üîç ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ Booking
      const booking = await prisma.booking.findUnique({
        where: { id: input.bookingId },
        include: { 
          slot: true,
          field: true,
          user: true
        }
      })

      if (!booking) {
        throw new DomainError('BOOKING_NOT_FOUND')
      }

      // 2. üîê ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÖŸÑŸÉŸäÿ©
      if (booking.userId !== input.userId) {
        throw new DomainError('BOOKING_NOT_OWNED')
      }

      // 3. üîê ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ≠ÿ¨ÿ≤
      if (booking.status !== BOOKING_STATUS.DRAFT) {
        throw new DomainError(
          'BOOKING_INVALID_STATE',
          `ŸÑÿß ŸäŸÖŸÉŸÜ ÿßŸÑÿØŸÅÿπ ŸÑÿ≠ÿ¨ÿ≤ ÿ®ÿ≠ÿßŸÑÿ© ${booking.status}`
        )
      }

      // 4. ‚è∞ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿ©
      if (booking.expiresAt && booking.expiresAt < new Date()) {
        throw new DomainError('BOOKING_EXPIRED')
      }

      // 5. üîê ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ŸÜ Slot ŸÑÿß ÿ™ÿ≤ÿßŸÑ ŸÖŸÇŸÅŸàŸÑÿ©
      if (booking.slot.status !== SLOT_STATUS.TEMP_LOCKED) {
        throw new DomainError('SLOT_LOCK_EXPIRED')
      }

      // 6. üí≥ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿØŸÅÿπ ÿ≥ÿßÿ®ŸÇ ŸÜÿßÿ¨ÿ≠
      const lastPayment = await prisma.payment.findFirst({
        where: { bookingId: input.bookingId },
        orderBy: { createdAt: 'desc' }
      })

      if (lastPayment?.status === PAYMENT_STATUS.PAID) {
        throw new DomainError('PAYMENT_ALREADY_PROCESSED')
      }

      // 7. üîê Idempotency ŸÑŸÑÿØŸÅÿπ
      const idempotencyKey = input.idempotencyKey || IdempotencyGuard.generateKey('payment')
      
      const check = await IdempotencyGuard.check(
        idempotencyKey,
        input.userId,
        'payment:initiate',
        { bookingId: input.bookingId, amount: input.amount }
      )

      if (!check.shouldProceed) {
        if (check.response) {
          bookingLogger.info({
            msg: 'Idempotent payment response',
            requestId
          })
          return check.response as PaymentInitResult
        }
        throw new DomainError('BOOKING_IN_PROGRESS')
      }

      const result = await prisma.$transaction(async (tx: any) => {
        // 8. üì¶ ÿ•ŸÜÿ¥ÿßÿ° Order ŸÅŸä Paymob
        let orderId: string
        let paymentToken: string

        if (paymobService.isMockMode()) {
          const mockOrder = await paymobService.createMockOrder({
            amount: input.amount,
            currency: input.currency || 'EGP',
            bookingId: input.bookingId
          })
          orderId = mockOrder.id.toString()
          paymentToken = await paymobService.getMockPaymentKey({ orderId: mockOrder.id })
        } else {
          const order = await paymobService.createOrder({
            amount: input.amount,
            currency: input.currency || 'EGP',
            bookingId: input.bookingId,
            userId: input.userId
          })
          orderId = order.id.toString()
          
          // ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÅŸàÿßÿ™Ÿäÿ±
          const billingData = {
            apartment: "NA",
            email: booking.user.email,
            floor: "NA",
            first_name: booking.user.name?.split(' ')[0] || "ÿπŸÖŸäŸÑ",
            street: "NA",
            building: "NA",
            phone_number: booking.user.phone || "01000000000",
            shipping_method: "NA",
            postal_code: "NA",
            city: "NA",
            country: "NA",
            last_name: booking.user.name?.split(' ').slice(1).join(' ') || "ŸÖÿ≥ÿ™ÿÆÿØŸÖ",
            state: "NA"
          }

          paymentToken = await paymobService.getPaymentKey({
            orderId: order.id,
            amount: input.amount,
            billingData,
            bookingId: input.bookingId
          })
        }

        // 9. üí≥ ÿ•ŸÜÿ¥ÿßÿ° Payment
        const payment = await tx.payment.create({
          data: {
            bookingId: input.bookingId,
            amount: input.amount,
            currency: input.currency || 'EGP',
            paymentId: `pay_${orderId}`,
            orderId: orderId,
            status: PAYMENT_STATUS.PROCESSING
          }
        })

        // 10. üîÑ ÿ™ÿ≠ÿØŸäÿ´ Booking
        await tx.booking.update({
          where: { id: input.bookingId },
          data: {
            status: BOOKING_STATUS.PENDING_PAYMENT,
            paymentStatus: PAYMENT_STATUS.PROCESSING,
            paymentId: payment.id,
            orderId: orderId
          }
        })

        const result: PaymentInitResult = {
          paymentUrl: paymobService.isMockMode() 
            ? `/payment/mock/${orderId}` 
            : `https://accept.paymob.com/api/acceptance/iframes/${ENV.PAYMOB_IFRAME_ID || 'default'}?payment_token=${paymentToken}`,
          orderId,
          idempotencyKey
        }

        // üíæ ÿ≠ŸÅÿ∏ ŸÑŸÑŸÄ Idempotency
        await IdempotencyGuard.saveResponse(
          idempotencyKey,
          input.userId,
          'payment:initiate',
          result,
          { bookingId: input.bookingId, amount: input.amount },
          30
        )

        bookingLogger.info({
          msg: 'Payment initiated successfully',
          requestId,
          orderId,
          paymentId: payment.id,
          durationMs: Date.now() - startTime
        })

        return result
      })

      return result

    } catch (error: any) {
      bookingLogger.error({
        msg: 'Payment initiation failed',
        requestId,
        error: error.message,
        bookingId: input.bookingId,
        durationMs: Date.now() - startTime
      })
      
      if (error instanceof DomainError) {
        throw error
      }
      throw new DomainError('INTERNAL_ERROR', 'ŸÅÿ¥ŸÑ ŸÅŸä ÿ®ÿØÿ° ÿπŸÖŸÑŸäÿ© ÿßŸÑÿØŸÅÿπ')
    }
  }

  /**
   * ‚úÖ 3. ÿ•ŸÉŸÖÿßŸÑ ÿßŸÑÿ≠ÿ¨ÿ≤ ÿ®ÿπÿØ ÿßŸÑÿØŸÅÿπ
   */
  static async completeBooking(params: {
    bookingId: string
    success: boolean
    paymentDetails: {
      transactionId: string
      orderId: string
      amount: number
      currency: string
    }
  }) {
    const startTime = Date.now()
    const requestId = `complete_booking_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

    bookingLogger.info({
      msg: 'Completing booking',
      requestId,
      bookingId: params.bookingId,
      success: params.success,
      orderId: params.paymentDetails.orderId
    })

    let booking: any

    try {
      // Transaction ŸÑŸÑÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑÿ≠ÿ±ÿ¨ÿ©
      await prisma.$transaction(async (tx: any) => {
        booking = await tx.booking.findUnique({
          where: { id: params.bookingId },
          include: { 
            slot: true, 
            field: true, 
            user: true 
          }
        })

        if (!booking) {
          throw new DomainError('BOOKING_NOT_FOUND')
        }

        // ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ payment ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ orderId ÿ£ŸàŸÑÿßŸã
        const existingPayment = await tx.payment.findFirst({
          where: { orderId: params.paymentDetails.orderId }
        })

        if (existingPayment) {
          if (existingPayment.status === PAYMENT_STATUS.PAID) {
            throw new DomainError('PAYMENT_ALREADY_PROCESSED')
          }
          
          if (existingPayment.bookingId !== params.bookingId) {
            throw new DomainError('DUPLICATE_PAYMENT', 'ÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ orderId ŸÅŸä ÿ≠ÿ¨ÿ≤ ÿ¢ÿÆÿ±')
          }
        }

        if (params.success) {
          // ‚úÖ ŸÜÿ¨ÿßÿ≠ ÿßŸÑÿØŸÅÿπ
          await tx.booking.update({
            where: { id: params.bookingId },
            data: {
              status: BOOKING_STATUS.CONFIRMED,
              paymentStatus: PAYMENT_STATUS.PAID
            }
          })

          await tx.slot.update({
            where: { id: booking.slotId },
            data: {
              status: SLOT_STATUS.BOOKED,
              lockedByUserId: null,
              lockedUntil: null
            }
          })

          await tx.payment.updateMany({
            where: { bookingId: params.bookingId },
            data: {
              status: PAYMENT_STATUS.PAID,
              paymentId: params.paymentDetails.transactionId,
              metadata: params.paymentDetails
            }
          })

          bookingLogger.info({
            msg: 'Payment succeeded',
            requestId,
            bookingId: params.bookingId,
            transactionId: params.paymentDetails.transactionId
          })

        } else {
          // ‚ùå ŸÅÿ¥ŸÑ ÿßŸÑÿØŸÅÿπ
          await tx.booking.update({
            where: { id: params.bookingId },
            data: {
              status: BOOKING_STATUS.FAILED,
              paymentStatus: PAYMENT_STATUS.FAILED
            }
          })

          await tx.slot.update({
            where: { id: booking.slotId },
            data: { 
              status: SLOT_STATUS.AVAILABLE,
              lockedByUserId: null,
              lockedUntil: null
            }
          })

          await tx.payment.updateMany({
            where: { bookingId: params.bookingId },
            data: {
              status: PAYMENT_STATUS.FAILED,
              metadata: params.paymentDetails
            }
          })

          bookingLogger.warn({
            msg: 'Payment failed',
            requestId,
            bookingId: params.bookingId
          })
        }
      })

      // ‚úÖ ÿ•ÿ±ÿ≥ÿßŸÑ Notifications ÿÆÿßÿ±ÿ¨ Transaction
      await this.sendPostTransactionNotifications(booking, params.success, params.paymentDetails)

      bookingLogger.info({
        msg: 'Booking completed successfully',
        requestId,
        bookingId: params.bookingId,
        durationMs: Date.now() - startTime
      })

      return { success: true }

    } catch (error: any) {
      bookingLogger.error({
        msg: 'Booking completion failed',
        requestId,
        error: error.message,
        bookingId: params.bookingId,
        durationMs: Date.now() - startTime
      })
      
      if (error instanceof DomainError) {
        throw error
      }
      throw new DomainError('INTERNAL_ERROR', 'ŸÅÿ¥ŸÑ ŸÅŸä ÿ•ŸÉŸÖÿßŸÑ ÿßŸÑÿ≠ÿ¨ÿ≤')
    }
  }

  /**
   * üßπ 4. ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ≠ÿ¨Ÿàÿ≤ÿßÿ™ ÿßŸÑŸÖŸÜÿ™ŸáŸäÿ©
   */
  static async cleanupExpiredBookings() {
    const startTime = Date.now()
    const jobId = `cleanup_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

    bookingLogger.info({
      msg: 'Starting expired bookings cleanup',
      jobId
    })

    try {
      const now = new Date()
      
      const expiredBookings = await prisma.booking.findMany({
        where: {
          status: BOOKING_STATUS.DRAFT,
          expiresAt: { lt: now }
        },
        include: { slot: true }
      })

      bookingLogger.info({
        msg: `Found ${expiredBookings.length} expired bookings`,
        jobId
      })

      let cleaned = 0

      for (const booking of expiredBookings) {
        try {
          await prisma.$transaction(async (tx: any) => {
            await tx.booking.update({
              where: { id: booking.id },
              data: {
                status: BOOKING_STATUS.EXPIRED,
                paymentStatus: PAYMENT_STATUS.FAILED
              }
            })

            await tx.slot.update({
              where: { id: booking.slotId },
              data: { 
                status: SLOT_STATUS.AVAILABLE,
                lockedByUserId: null,
                lockedUntil: null
              }
            })

            cleaned++
          })

          // ÿ•ÿ¥ÿπÿßÿ± ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
          await notificationService.send({
            userId: booking.userId,
            type: 'BOOKING_EXPIRED',
            title: 'ÿßŸÜÿ™Ÿáÿ™ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑÿ≠ÿ¨ÿ≤',
            message: 'ÿßŸÜÿ™Ÿáÿ™ ÿµŸÑÿßÿ≠Ÿäÿ© ÿ≠ÿ¨ÿ≤ŸÉÿå Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ',
            relatedId: booking.id
          })

        } catch (error: any) {
          bookingLogger.error({
            msg: `Failed to clean up booking ${booking.id}`,
            jobId,
            error: error.message
          })
        }
      }

      bookingLogger.info({
        msg: 'Cleanup completed',
        jobId,
        cleaned,
        durationMs: Date.now() - startTime
      })

      return { success: true, cleaned }

    } catch (error: any) {
      bookingLogger.error({
        msg: 'Cleanup job failed',
        jobId,
        error: error.message,
        durationMs: Date.now() - startTime
      })
      
      return { success: false, error: error.message }
    }
  }

  /**
   * üîì 5. ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ≥ŸÑÿßÿ™ ÿßŸÑŸÖŸÇŸÅŸàŸÑÿ© ÿßŸÑŸÖŸÜÿ™ŸáŸäÿ©
   */
  static async cleanupExpiredLocks() {
    const startTime = Date.now()
    const jobId = `unlock_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

    bookingLogger.info({
      msg: 'Starting expired locks cleanup',
      jobId
    })

    try {
      const now = new Date()
      
      const result = await prisma.slot.updateMany({
        where: {
          status: SLOT_STATUS.TEMP_LOCKED,
          lockedUntil: { lt: now }
        },
        data: {
          status: SLOT_STATUS.AVAILABLE,
          lockedByUserId: null,
          lockedUntil: null
        }
      })

      bookingLogger.info({
        msg: 'Locks cleanup completed',
        jobId,
        unlockedSlots: result.count,
        durationMs: Date.now() - startTime
      })

      return { success: true, unlockedSlots: result.count }

    } catch (error: any) {
      bookingLogger.error({
        msg: 'Locks cleanup failed',
        jobId,
        error: error.message,
        durationMs: Date.now() - startTime
      })
      
      return { success: false, error: error.message }
    }
  }

  /**
   * üîí Private helpers
   */

  private static async sendPostTransactionNotifications(
    booking: any,
    success: boolean,
    paymentDetails: any
  ): Promise<void> {
    try {
      if (success) {
        await notificationService.send({
          userId: booking.userId,
          type: 'PAYMENT_SUCCESS',
          title: 'ÿ™ŸÖ ÿßŸÑÿØŸÅÿπ ÿ®ŸÜÿ¨ÿßÿ≠',
          message: `ÿ™ŸÖ ÿ™ÿ£ŸÉŸäÿØ ÿ≠ÿ¨ÿ≤ŸÉ ŸÅŸä ${booking.field.name} ÿ®ÿ™ÿßÿ±ŸäÿÆ ${new Date(booking.slot.startTime).toLocaleDateString('ar-EG')}`,
          relatedId: booking.id,
          data: {
            amount: paymentDetails.amount,
            fieldName: booking.field.name,
            date: booking.slot.startTime
          }
        })
      } else {
        await notificationService.send({
          userId: booking.userId,
          type: 'PAYMENT_FAILED',
          title: 'ŸÅÿ¥ŸÑ ÿßŸÑÿØŸÅÿπ',
          message: 'ŸÅÿ¥ŸÑÿ™ ÿπŸÖŸÑŸäÿ© ÿßŸÑÿØŸÅÿπÿå Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ',
          relatedId: booking.id
        })
      }
    } catch (error: any) {
      bookingLogger.error({
        msg: 'Failed to send notifications',
        error: error.message,
        bookingId: booking.id
      })
      // ŸÑÿß ÿ™ÿ±ŸÖŸä error - notifications ŸÅÿ¥ŸÑÿ™ ŸÑŸÉŸÜ ÿßŸÑÿπŸÖŸÑŸäÿ© ŸÜÿ¨ÿ≠ÿ™
    }
  }

  private static canBookDirectly(start: Date): boolean {
    const diffMs = start.getTime() - Date.now()
    const diffHours = diffMs / (1000 * 60 * 60)
    return diffHours >= 24
  }
}

export const bookingOrchestrator = new BookingOrchestrator()
// lib/application/jobs/unlock-slots.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { SLOT_STATUS, BOOKING_STATUS } from '@/lib/shared/constants'
import { bookingLogger } from '@/lib/shared/logger'
import { DomainError } from '@/lib/core/errors/domain-errors'

export async function unlockSlotsJob() {
  const jobId = `unlock_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  bookingLogger.info({ 
    msg: 'üîì Starting unlock slots job...',
    jobId 
  })
  
  const now = new Date()
  let unlockedCount = 0
  let orphanedCount = 0
  let errorsCount = 0

  try {
    const expiredSlots = await prisma.slot.findMany({
      where: {
        status: SLOT_STATUS.TEMP_LOCKED,
        lockedUntil: { lt: now }
      },
      include: {
        lockedByUser: { select: { id: true, email: true, name: true } },
        field: { select: { id: true, name: true } }
      }
    })

    bookingLogger.info({ 
      msg: `üìä Found ${expiredSlots.length} expired locked slots`,
      jobId,
      count: expiredSlots.length 
    })

    if (expiredSlots.length > 0) {
      bookingLogger.debug({
        msg: 'üìù Expired slots details:',
        jobId,
        slots: expiredSlots.map((slot: any) => ({
          id: slot.id,
          startTime: slot.startTime,
          userId: slot.lockedByUserId,
          userEmail: slot.lockedByUser?.email,
          fieldName: slot.field?.name,
          lockedUntil: slot.lockedUntil
        }))
      })
    }

    const result = await prisma.slot.updateMany({
      where: { status: SLOT_STATUS.TEMP_LOCKED, lockedUntil: { lt: now } },
      data: { status: SLOT_STATUS.AVAILABLE, lockedByUserId: null, lockedUntil: null }
    })

    unlockedCount = result.count
    
    bookingLogger.info({ 
      msg: `üîì Unlocked ${unlockedCount} expired slots`,
      jobId,
      unlockedCount 
    })

    const orphanedSlots = await prisma.slot.findMany({
      where: {
        status: SLOT_STATUS.TEMP_LOCKED,
        bookings: {
          none: {
            status: { in: [BOOKING_STATUS.DRAFT, BOOKING_STATUS.PENDING_PAYMENT] }
          }
        }
      },
      include: { field: { select: { id: true, name: true } } }
    })

    if (orphanedSlots.length > 0) {
      bookingLogger.warn({
        msg: `‚ö†Ô∏è Found ${orphanedSlots.length} orphaned locked slots`,
        jobId,
        orphanedCount: orphanedSlots.length,
        orphanedSlots: orphanedSlots.map((s: any) => ({
          id: s.id,
          field: s.field?.name,
          startTime: s.startTime
        }))
      })
      
      const orphanedResult = await prisma.slot.updateMany({
        where: { id: { in: orphanedSlots.map((s: any) => s.id) } },
        data: { status: SLOT_STATUS.AVAILABLE, lockedByUserId: null, lockedUntil: null }
      })

      orphanedCount = orphanedResult.count
      
      bookingLogger.info({ 
        msg: `üîÑ Unlocked ${orphanedCount} orphaned slots`,
        jobId,
        orphanedCount 
      })
    }

    const totalUnlocked = unlockedCount + orphanedCount
    const jobDuration = Date.now() - now.getTime()
    
    bookingLogger.info({
      msg: '‚úÖ Unlock slots job completed',
      jobId,
      durationMs: jobDuration,
      stats: {
        expiredSlotsFound: expiredSlots.length,
        unlockedExpiredSlots: unlockedCount,
        orphanedSlotsFound: orphanedSlots.length,
        unlockedOrphanedSlots: orphanedCount,
        totalUnlocked,
        errors: errorsCount
      }
    })

    return {
      success: true,
      stats: {
        unlockedSlots: totalUnlocked,
        orphanedSlots: orphanedCount,
        expiredSlots: expiredSlots.length,
        timestamp: now.toISOString(),
        durationMs: jobDuration
      }
    }

  } catch (error: any) {
    bookingLogger.error({
      msg: '‚ùå Fatal error in unlock slots job',
      jobId,
      error: error.message,
      stack: error.stack
    })
    
    throw new DomainError('INTERNAL_ERROR', `Job failed: ${error.message}`)
  }
}

export async function runUnlockSlotsJob() {
  const requestId = `run_unlock_${Date.now()}`
  
  try {
    bookingLogger.info({ 
      msg: 'Starting scheduled unlock slots job',
      requestId 
    })
    
    const result = await unlockSlotsJob()
    
    bookingLogger.info({ 
      msg: '‚úÖ Scheduled unlock slots job completed',
      requestId,
      result 
    })
    
    return result
  } catch (error: any) {
    bookingLogger.error({ 
      msg: '‚ùå Scheduled unlock slots job failed',
      requestId,
      error: error.message,
      stack: error.stack 
    })
    
    return { 
      success: false, 
      error: error.message,
      timestamp: new Date().toISOString()
    }
  }
}
import { prisma } from '@/lib/infrastructure/database/prisma'
import { 
  BOOKING_STATUS, 
  PAYMENT_STATUS,
  SLOT_STATUS 
} from '@/lib/shared/constants'
import { bookingLogger } from '@/lib/shared/logger'
import { DomainError } from '@/lib/core/errors/domain-errors'

export async function expireBookingsJob() {
  const jobId = `expire_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  bookingLogger.info({ jobId }, 'üöÄ Starting expire bookings job...')
  
  const now = new Date()
  let expiredCount = 0
  let unlockedSlots = 0
  let errorsCount = 0

  try {
    const expiredBookings = await prisma.booking.findMany({
      where: {
        status: BOOKING_STATUS.DRAFT,
        expiresAt: { lt: now }
      },
      include: {
        slot: true,
        user: {
          select: { id: true, email: true, name: true }
        }
      }
    })

    bookingLogger.info({ jobId, count: expiredBookings.length }, `üìä Found ${expiredBookings.length} expired bookings`)

    for (const booking of expiredBookings) {
      try {
        const startTime = Date.now()
        
        await prisma.$transaction(async (tx: any) => {
          await tx.booking.update({
            where: { id: booking.id },
            data: {
              status: BOOKING_STATUS.EXPIRED,
              paymentStatus: PAYMENT_STATUS.FAILED
            }
          })

          await tx.slot.update({
            where: { id: booking.slotId },
            data: {
              status: SLOT_STATUS.AVAILABLE,
              lockedByUserId: null,
              lockedUntil: null
            }
          })

          await tx.notification.create({
            data: {
              userId: booking.userId,
              type: 'BOOKING_EXPIRED',
              title: 'ÿßŸÜÿ™Ÿáÿ™ ÿµŸÑÿßÿ≠Ÿäÿ© ÿßŸÑÿ≠ÿ¨ÿ≤',
              message: `ÿßŸÜÿ™Ÿáÿ™ ÿµŸÑÿßÿ≠Ÿäÿ© ÿ≠ÿ¨ÿ≤ŸÉ ŸÅŸä ${booking.slot.startTime.toLocaleDateString('ar-EG')}`,
              relatedId: booking.id,
              data: {
                slotTime: booking.slot.startTime,
                fieldId: booking.slot.fieldId
              }
            }
          })
        })

        const duration = Date.now() - startTime
        
        bookingLogger.debug({
          jobId,
          bookingId: booking.id,
          userId: booking.userId,
          userEmail: booking.user?.email,
          slotId: booking.slotId,
          durationMs: duration
        }, 'Booking expired successfully')

        expiredCount++
        unlockedSlots++

      } catch (error: any) {
        errorsCount++
        bookingLogger.error({
          jobId,
          bookingId: booking.id,
          error: error.message,
          stack: error.stack
        }, `‚ùå Error processing booking ${booking.id}`)
      }
    }

    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
    
    const deleted = await prisma.booking.deleteMany({
      where: {
        status: BOOKING_STATUS.EXPIRED,
        updatedAt: { lt: sevenDaysAgo }
      }
    })

    bookingLogger.info({
      jobId,
      deletedCount: deleted.count,
      cutoffDate: sevenDaysAgo.toISOString()
    }, `üóëÔ∏è Deleted ${deleted.count} old expired bookings`)

    const jobDuration = Date.now() - now.getTime()
    
    bookingLogger.info({
      jobId,
      durationMs: jobDuration,
      stats: {
        totalFound: expiredBookings.length,
        successfullyExpired: expiredCount,
        unlockedSlots,
        deletedOldBookings: deleted.count,
        errors: errorsCount,
        successRate: expiredBookings.length > 0 ? 
          ((expiredCount / expiredBookings.length) * 100).toFixed(2) + '%' : 'N/A'
      }
    }, '‚úÖ Expire bookings job completed')

    return {
      success: true,
      stats: {
        expiredBookings: expiredCount,
        unlockedSlots,
        deletedOld: deleted.count,
        errors: errorsCount,
        timestamp: now.toISOString(),
        durationMs: jobDuration
      }
    }

  } catch (error: any) {
    bookingLogger.error({
      jobId,
      error: error.message,
      stack: error.stack
    }, '‚ùå Fatal error in expire bookings job')
    
    throw new DomainError('INTERNAL_ERROR', `Job failed: ${error.message}`)
  }
}

export async function runExpireBookingsJob() {
  const requestId = `run_expire_${Date.now()}`
  
  try {
    bookingLogger.info({ requestId }, 'Starting scheduled expire bookings job')
    
    const result = await expireBookingsJob()
    
    bookingLogger.info({ requestId, result }, '‚úÖ Scheduled expire bookings job completed')
    
    return result
  } catch (error: any) {
    bookingLogger.error({ requestId, error: error.message, stack: error.stack }, '‚ùå Scheduled expire bookings job failed')
    
    return { 
      success: false, 
      error: error.message,
      timestamp: new Date().toISOString()
    }
  }
}
// lib/application/idempotency/idempotency-guard.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { addMinutes } from 'date-fns'
import crypto from 'crypto'

export class IdempotencyGuard {
  /**
   * üîê ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑÿπŸÖŸÑŸäÿ© idempotent
   * @param key ÿßŸÑŸÖŸÅÿ™ÿßÿ≠ ÿßŸÑŸÅÿ±ŸäÿØ
   * @param userId ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
   * @param method ÿßÿ≥ŸÖ ÿßŸÑÿπŸÖŸÑŸäÿ©
   * @param requestData ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ∑ŸÑÿ® (ŸÑÿ™ÿ¨ŸÜÿ® ŸÜŸÅÿ≥ ÿßŸÑÿ∑ŸÑÿ® ÿ®ŸÖÿπÿ∑Ÿäÿßÿ™ ŸÖÿÆÿ™ŸÑŸÅÿ©)
   * @returns {idempotent: boolean, response?: any, shouldProceed: boolean}
   */
  static async check(
    key: string,
    userId: string,
    method: string,
    requestData?: any
  ): Promise<{
    idempotent: boolean
    response?: any
    shouldProceed: boolean
  }> {
    const now = new Date()
    
    // 1. ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÖŸÅÿßÿ™Ÿäÿ≠ ÿßŸÑŸÖŸÜÿ™ŸáŸäÿ©
    await prisma.idempotencyKey.deleteMany({
      where: { expiresAt: { lt: now } }
    }).catch(() => {
      // ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿ£ÿÆÿ∑ÿßÿ° ŸÅŸä ÿßŸÑÿ™ŸÜÿ∏ŸäŸÅ
    })

    try {
      // 2. ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑŸÖŸÅÿ™ÿßÿ≠ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ key Ÿà userId
      const existing = await prisma.idempotencyKey.findFirst({
        where: { 
          AND: [
            { key },
            { userId }
          ]
        }
      })

      if (!existing) {
        return { idempotent: false, shouldProceed: true }
      }

      // 3. ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ∑ÿ±ŸäŸÇÿ©
      if (existing.method !== method) {
        throw new Error('ŸÖŸÅÿ™ÿßÿ≠ idempotency ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ ŸÑŸáÿ∞ÿß ÿßŸÑÿπŸÖŸÑŸäÿ©')
      }

      // 4. ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ requestHash ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÖŸàÿ¨ŸàÿØÿßŸã
      if (requestData && existing.requestHash) {
        const currentHash = this.hashRequest(requestData)
        if (currentHash !== existing.requestHash) {
          throw new Error('ÿ∑ŸÑÿ® ŸÖŸÉÿ±ÿ± ÿ®ŸÖÿπÿ∑Ÿäÿßÿ™ ŸÖÿÆÿ™ŸÑŸÅÿ©')
        }
      }

      // 5. ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸáŸÜÿßŸÉ response ŸÖÿÆÿ≤ŸÜ
      if (existing.response) {
        return {
          idempotent: true,
          response: existing.response,
          shouldProceed: false
        }
      }

      // 6. ÿßŸÑŸÖŸÅÿ™ÿßÿ≠ ŸÖŸàÿ¨ŸàÿØ ŸàŸÑŸÉŸÜ ÿ®ÿØŸàŸÜ response (ŸÖÿßÿ≤ÿßŸÑ ŸäÿπŸÖŸÑ)
      return { idempotent: true, shouldProceed: false }

    } catch (error) {
      console.error('Idempotency check error:', error)
      return { idempotent: false, shouldProceed: true }
    }
  }

  /**
   * üíæ ÿ≠ŸÅÿ∏ ŸÜÿ™Ÿäÿ¨ÿ© idempotent
   */
  static async saveResponse(
    key: string,
    userId: string,
    method: string,
    response: any,
    requestData?: any,
    ttlMinutes: number = 60
  ) {
    // ‚úÖ ÿ•ÿµŸÑÿßÿ≠: ÿßÿ≥ÿ™ÿÆÿØŸÖ ŸÇŸäŸÖÿ© ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿäÿ© ŸÑŸÄ requestHash
    const requestHash = requestData ? this.hashRequest(requestData) : ''
    
    try {
      return await prisma.idempotencyKey.upsert({
        where: {
          key_userId: {
            key,
            userId
          }
        },
        update: {
          response,
          expiresAt: addMinutes(new Date(), ttlMinutes)
        },
        create: {
          key,
          userId,
          method,
          requestHash, // ‚úÖ ÿßŸÑÿ¢ŸÜ string ŸàŸÑŸäÿ≥ null
          response,
          expiresAt: addMinutes(new Date(), ttlMinutes)
        }
      })
    } catch (error) {
      console.error('Failed to save idempotency response:', error)
      // ‚úÖ ÿ•ÿµŸÑÿßÿ≠: ÿ•ÿ±ÿ¨ÿßÿπ ŸÇŸäŸÖÿ© ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿäÿ©
      return null
    }
  }

  /**
   * üî¢ ÿ™ŸàŸÑŸäÿØ ŸÖŸÅÿ™ÿßÿ≠ ÿ¢ŸÖŸÜ
   */
  static generateKey(prefix: string = 'req'): string {
    const timestamp = Date.now()
    const random = crypto.randomBytes(16).toString('hex')
    return `${prefix}_${timestamp}_${random}`
  }

  /**
   * üîê ÿ≠ÿ≥ÿßÿ® Ÿáÿßÿ¥ ŸÑŸÑÿ∑ŸÑÿ® ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ SHA-256
   */
  private static hashRequest(data: any): string {
    const str = JSON.stringify(data, Object.keys(data).sort())
    return crypto.createHash('sha256').update(str).digest('hex')
  }
}
// app/api/auth/[...nextauth]/route.ts
import NextAuth from 'next-auth'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'  // ‚úÖ ÿßŸÑŸÖÿ≥ÿßÿ± ÿßŸÑÿ¨ÿØŸäÿØ

const handler = NextAuth(authOptions)

export { handler as GET, handler as POST }

// app/api/auth/me/route.ts
import { NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { successResponse, errorResponse } from '@/lib/infrastructure/auth/responses'
import { logger } from '@/lib/shared/logger'

// ‚úÖ ÿ£ÿ∂ŸÅ Ÿáÿ∞ÿß ŸÑÿ™ÿ≠ÿØŸäÿØ ÿ£ŸÜ ÿßŸÑŸÖÿ≥ÿßÿ± ÿØŸäŸÜÿßŸÖŸäŸÉŸä
export const dynamic = 'force-dynamic'

export const GET = async () => {
  const requestId = `auth_me_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

  try {
    logger.info({ requestId }, 'Fetching user data')

    const session = await getServerSession(authOptions)

    if (!session?.user?.id) {
      logger.warn({ requestId }, 'Unauthorized access to /api/auth/me')
      return NextResponse.json(
        errorResponse('Ÿäÿ¨ÿ® ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ£ŸàŸÑÿßŸã', 'UNAUTHORIZED'),
        { status: 401 }
      )
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: {
        id: true,
        name: true,
        email: true,
        phoneNumber: true,
        age: true,
        description: true,
        skillLevel: true,
        role: true,
        isVerified: true,
        isActive: true,
        lastLogin: true,
        createdAt: true,
        updatedAt: true,
      }
    })

    if (!user) {
      logger.warn({ requestId, userId: session.user.id }, 'User not found')
      return NextResponse.json(
        errorResponse('ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ', 'USER_NOT_FOUND'),
        { status: 404 }
      )
    }

    if (!user.isActive) {
      logger.warn({ requestId, userId: user.id }, 'Inactive account accessed')
      return NextResponse.json(
        errorResponse('ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿ∫Ÿäÿ± ŸÜÿ¥ÿ∑', 'ACCOUNT_INACTIVE'),
        { status: 403 }
      )
    }

    logger.info({ requestId, userId: user.id }, 'User data fetched successfully')

    return NextResponse.json(
      successResponse('ÿ™ŸÖ ÿ¨ŸÑÿ® ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ®ŸÜÿ¨ÿßÿ≠', {
        user: {
          ...user,
          lastLogin: user.lastLogin?.toISOString(),
          createdAt: user.createdAt.toISOString(),
          updatedAt: user.updatedAt.toISOString()
        }
      }, '/api/auth/me')
    )

  } catch (error: any) {
    logger.error('Error in /api/auth/me', error, { requestId })
    return NextResponse.json(
      errorResponse('ÿÆÿ∑ÿ£ ŸÅŸä ÿ¨ŸÑÿ® ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ', 'INTERNAL_ERROR'),
      { status: 500 }
    )
  }
}
// app/api/auth/register/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { RateLimiterMemory } from 'rate-limiter-flexible'
import { prisma } from '@/lib/infrastructure/database/prisma'  
import { hashPassword } from '@/lib/infrastructure/security/password'  // ‚úÖ ÿßŸÑŸÖÿ≥ÿßÿ± ÿßŸÑÿ¨ÿØŸäÿØ
import { z } from 'zod'
import { logger } from '@/lib/shared/logger'  // ‚úÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÄ logger ÿßŸÑÿ¨ÿØŸäÿØ

// Rate Limiter ŸÑŸÑÿ™ÿ≥ÿ¨ŸäŸÑ
const registerRateLimiter = new RateLimiterMemory({
  points: 3,
  duration: 60 * 60,
  blockDuration: 60 * 60,
})

const registerSchema = z.object({
  name: z.string().min(2, 'ÿßŸÑÿßÿ≥ŸÖ Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ≠ÿ±ŸÅŸäŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ'),
  email: z.string().email('ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠'),
  password: z.string()
    .min(6, 'ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ŸÉŸàŸÜ 6 ÿ£ÿ≠ÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ')
    .max(72, 'ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿ∑ŸàŸäŸÑÿ© ÿ¨ÿØÿßŸã'),
  phoneNumber: z.string().min(10, 'ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠'),
  age: z.number().min(13, 'ÿßŸÑÿπŸÖÿ± Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ 13 ÿ≥ŸÜÿ© ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ'),
  skillLevel: z.enum(['WEAK', 'AVERAGE', 'GOOD', 'EXCELLENT', 'LEGENDARY'])
})

const normalizeEmail = (email: string): string => {
  return email.toLowerCase().trim()
}

const checkRegisterRateLimit = async (ip: string) => {
  try {
    await registerRateLimiter.consume(ip)
    return { allowed: true }
  } catch (rateLimiterRes: any) {
    const retryAfter = Math.ceil(rateLimiterRes.msBeforeNext / 1000) || 60
    throw new Error(`ŸÑŸÇÿØ ÿ™ÿ¨ÿßŸàÿ≤ÿ™ ÿßŸÑÿ≠ÿØ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ ÿ®Ÿá ŸÖŸÜ ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑÿßÿ™. ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ÿ®ÿπÿØ ${retryAfter} ÿ´ÿßŸÜŸäÿ©`)
  }
}

const getClientIp = (request: NextRequest): string => {
  const forwardedFor = request.headers.get('x-forwarded-for')
  const realIp = request.headers.get('x-real-ip')
  
  if (forwardedFor) {
    return forwardedFor.split(',')[0].trim()
  }
  
  return realIp || 'unknown'
}

export async function POST(request: NextRequest) {
  const requestId = `register_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    logger.info({ requestId }, 'Registration attempt')
    
    const clientIp = getClientIp(request)
    await checkRegisterRateLimit(clientIp)
    
    const body = await request.json()
    const validatedData = registerSchema.parse(body)

    const normalizedEmail = normalizeEmail(validatedData.email)

    const existingUser = await prisma.user.findUnique({
      where: { email: normalizedEmail }
    })

    if (existingUser) {
      logger.warn({ requestId, email: normalizedEmail }, 'Email already exists')
      return NextResponse.json(
        { 
          success: false,
          error: 'ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä ŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ®ÿßŸÑŸÅÿπŸÑ',
          code: 'EMAIL_ALREADY_EXISTS'
        },
        { status: 409 }
      )
    }

    const existingPhone = await prisma.user.findUnique({
      where: { phoneNumber: validatedData.phoneNumber }
    })

    if (existingPhone) {
      logger.warn({ requestId, phone: validatedData.phoneNumber }, 'Phone already exists')
      return NextResponse.json(
        { 
          success: false,
          error: 'ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ ŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ®ÿßŸÑŸÅÿπŸÑ',
          code: 'PHONE_ALREADY_EXISTS'
        },
        { status: 409 }
      )
    }

    const hashedPassword = await hashPassword(validatedData.password)

    const user = await prisma.user.create({
      data: {
        name: validatedData.name,
        email: normalizedEmail,
        passwordHash: hashedPassword,
        phoneNumber: validatedData.phoneNumber,
        age: validatedData.age,
        skillLevel: validatedData.skillLevel,
        role: 'PLAYER',
        roleUpdatedAt: new Date(),
        isActive: true,
        isVerified: false,
        emailVerifiedAt: null
      }
    })

    logger.info({ requestId, userId: user.id }, 'Registration successful')
    
    return NextResponse.json({
      success: true,
      message: 'ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿ®ŸÜÿ¨ÿßÿ≠',
      data: {
        id: user.id,
        name: user.name,
        email: user.email,
        requiresVerification: true
      }
    }, { status: 201 })

  } catch (error: any) {
    if (error.name === 'ZodError') {
      const firstError = error.errors[0]
      logger.warn({ requestId, error: firstError.message }, 'Validation error in registration')
      return NextResponse.json(
        { 
          success: false,
          error: firstError.message,
          code: 'VALIDATION_ERROR'
        },
        { status: 400 }
      )
    }

    if (error.message.includes('ŸÑŸÇÿØ ÿ™ÿ¨ÿßŸàÿ≤ÿ™ ÿßŸÑÿ≠ÿØ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠')) {
      logger.warn({ requestId, error: error.message }, 'Rate limit exceeded')
      return NextResponse.json(
        { 
          success: false,
          error: error.message,
          code: 'RATE_LIMIT_EXCEEDED'
        },
        { status: 429 }
      )
    }

    logger.error('Registration error', error, { requestId })
    return NextResponse.json(
      { 
        success: false,
        error: 'ŸÅÿ¥ŸÑ ŸÅŸä ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ≠ÿ≥ÿßÿ®',
        code: 'INTERNAL_SERVER_ERROR'
      },
      { status: 500 }
    )
  }
}
// app/api/bookings/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'
import { BookingOrchestrator } from '@/lib/application/services/booking-orchestrator'  // ‚úÖ ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ ÿßŸÑŸÉŸÑÿßÿ≥ ŸÖÿ®ÿßÿ¥ÿ±ÿ©
import { IdempotencyGuard } from '@/lib/application/idempotency/idempotency-guard'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { BOOKING_STATUS } from '@/lib/shared/constants'
import { logger } from '@/lib/shared/logger'

export async function GET(request: NextRequest) {
  const requestId = `get_bookings_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    logger.info({ requestId }, 'Fetching bookings')
    
    const session = await getServerSession(authOptions)
    const userId = session?.user?.id

    if (!userId) {
      logger.warn({ requestId }, 'Unauthorized access to bookings')
      throw new DomainError('UNAUTHORIZED')
    }

    const { searchParams } = new URL(request.url)
    const page = parseInt(searchParams.get('page') || '1')
    const limit = Math.min(parseInt(searchParams.get('limit') || '20'), 50)
    const status = searchParams.get('status')
    const skip = (page - 1) * limit

    const where: any = { userId }
    
    if (status) {
      where.status = status
    } else {
      where.status = {
        in: [BOOKING_STATUS.CONFIRMED, BOOKING_STATUS.PENDING_PAYMENT]
      }
    }

    const [bookings, total] = await Promise.all([
      prisma.booking.findMany({
        where,
        include: {
          field: {
            select: {
              id: true,
              name: true,
              pricePerHour: true
            }
          },
          slot: {
            select: {
              id: true,
              startTime: true,
              endTime: true,
              durationMinutes: true
            }
          },
          payments: {
            take: 1,
            orderBy: { createdAt: 'desc' }
          }
        },
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit
      }),
      prisma.booking.count({ where })
    ])

    logger.info({ 
      requestId, 
      userId, 
      count: bookings.length,
      total 
    }, 'Bookings fetched successfully')
    
    return NextResponse.json({
      success: true,
      data: bookings,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
        hasMore: page * limit < total
      }
    })

  } catch (error: any) {
    logger.error('Get bookings error', error, { requestId })
    return apiErrorHandler(error)
  }
}

export async function POST(request: NextRequest) {
  const requestId = `create_booking_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    logger.info({ requestId }, 'Creating booking')
    
    const session = await getServerSession(authOptions)
    const userId = session?.user?.id

    if (!userId) {
      logger.warn({ requestId }, 'Unauthorized booking creation attempt')
      throw new DomainError('UNAUTHORIZED')
    }

    const { slotId, fieldId, idempotencyKey } = await request.json()

    if (!slotId || !fieldId) {
      logger.warn({ requestId, slotId, fieldId }, 'Incomplete booking data')
      throw new DomainError('VALIDATION_ERROR', 'ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ≠ÿ¨ÿ≤ ÿ∫Ÿäÿ± ŸÖŸÉÿ™ŸÖŸÑÿ©')
    }

    const finalKey = idempotencyKey || IdempotencyGuard.generateKey('booking')

    // ‚úÖ ÿßÿ≥ÿ™ÿØÿπÿßÿ° ÿßŸÑŸÄ static method ŸÖŸÜ ÿßŸÑŸÉŸÑÿßÿ≥
    const result = await BookingOrchestrator.createBooking({
      userId,
      slotId,
      fieldId,
      idempotencyKey: finalKey
    })

    logger.info({ 
      requestId, 
      bookingId: result.bookingId,
      userId 
    }, 'Booking created successfully')
    
    return NextResponse.json({
      success: true,
      ...result,
      idempotencyKey: finalKey
    })

  } catch (error: any) {
    logger.error('Create booking error', error, { requestId })
    return apiErrorHandler(error)
  }
}
//app/api/cron/cleanup/rout.ts
import { NextResponse } from 'next/server'
import { BookingOrchestrator } from '@/lib/application/services/booking-orchestrator' // üîß ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ ÿßŸÑŸÉŸÑÿßÿ≥
import { ENV } from '@/lib/shared/env/env'
import { logger } from '@/lib/shared/logger'

export const dynamic = 'force-dynamic'

export async function GET(request: Request) {
  const jobId = `cron_cleanup_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    logger.info({ jobId }, 'Starting cron cleanup job')
    
    const authHeader = request.headers.get('authorization')
    
    if (authHeader !== `Bearer ${ENV.CRON_SECRET}`) {
      logger.warn({ jobId }, 'Unauthorized cron attempt')
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // üîß ÿßŸÑÿ™ÿπÿØŸäŸÑ ŸáŸÜÿß - ÿßÿ≥ÿ™ÿÆÿØŸÖ static methods
    const [expireResult, unlockResult] = await Promise.all([
      BookingOrchestrator.cleanupExpiredBookings(),    // ‚úÖ BookingOrchestrator.
      BookingOrchestrator.cleanupExpiredLocks()        // ‚úÖ BookingOrchestrator.
    ])

    logger.info({ 
      jobId,
      expiredBookings: expireResult.cleaned || 0,
      unlockedSlots: unlockResult.unlockedSlots || 0
    }, 'Cron cleanup completed')
    
    return NextResponse.json({
      success: true,
      timestamp: new Date().toISOString(),
      results: {
        expireBookings: expireResult,
        unlockSlots: unlockResult
      }
    })
  } catch (error: any) {
    logger.error('Cron cleanup error', error, { jobId })
    return NextResponse.json(
      { 
        success: false,
        error: 'Cleanup failed', 
        details: error.message 
      },
      { status: 500 }
    )
  }
}
// app/api/fields/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { FIELD_STATUS } from '@/lib/shared/constants'
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { logger } from '@/lib/shared/logger'

export async function GET(request: NextRequest) {
  const requestId = `get_fields_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    const userAgent = request.headers.get('user-agent') || 'unknown'
    const ip = request.headers.get('x-forwarded-for') || request.headers.get('x-real-ip') || 'unknown'
    const acceptLanguage = request.headers.get('accept-language') || 'ar'
    const acceptEncoding = request.headers.get('accept-encoding') || 'gzip'
    
    logger.info({ 
      msg: 'Fetching fields',
      requestId, 
      userAgent, 
      ip, 
      acceptLanguage, 
      acceptEncoding, 
      url: request.url, 
      method: request.method 
    })
    
    const searchParams = request.nextUrl.searchParams
    const type = searchParams.get('type')
    const location = searchParams.get('location')
    const page = parseInt(searchParams.get('page') || '1')
    const limit = parseInt(searchParams.get('limit') || '10')
    const minPrice = searchParams.get('minPrice')
    const maxPrice = searchParams.get('maxPrice')
    const sortBy = searchParams.get('sortBy') || 'createdAt'
    const sortOrder = searchParams.get('sortOrder') || 'desc'

    if (page < 1 || limit < 1 || limit > 100) {
      return NextResponse.json({ 
        success: false, 
        error: 'ŸÇŸäŸÖ ÿßŸÑÿ™ÿµŸÅÿ≠ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ©', 
        code: 'INVALID_PAGINATION' 
      }, { status: 400 })
    }

    const skip = (page - 1) * limit
    const where: any = { status: FIELD_STATUS.OPEN }

    if (type && type !== 'ÿßŸÑŸÉŸÑ') where.type = type.toUpperCase()
    if (location && location !== 'ÿßŸÑŸÉŸÑ') where.location = location
    if (minPrice) where.pricePerHour = { ...where.pricePerHour, gte: parseFloat(minPrice) }
    if (maxPrice) where.pricePerHour = { ...where.pricePerHour, lte: parseFloat(maxPrice) }

    const orderBy: any = {}
    if (sortBy === 'price') orderBy.pricePerHour = sortOrder
    else if (sortBy === 'name') orderBy.name = sortOrder
    else orderBy.createdAt = 'desc'

    // ‚úÖ ÿßÿ≥ÿ™ÿÆÿØŸÖ select ŸÅŸÇÿ∑ ŸÖÿπ _count
    const [fields, totalCount] = await Promise.all([
      prisma.field.findMany({
        where,
        orderBy,
        skip,
        take: limit,
        select: {
          id: true,
          name: true,
          description: true,
          location: true,
          address: true,
          type: true,
          imageUrl: true,
          pricePerHour: true,
          depositPrice: true,
          facilities: true,
          _count: {
            select: {
              bookings: true,
              reviews: true
            }
          }
        }
      }),
      prisma.field.count({ where })
    ])

    const enrichedFields = fields.map((field: any) => ({
      ...field,
      popularity: field._count.bookings,
      positiveReviews: field._count.reviews,
      isPopular: field._count.bookings > 10,
      hasDiscount: field.pricePerHour > 100,
      estimatedEarnings: field.pricePerHour * field._count.bookings
    }))

    const totalPages = Math.ceil(totalCount / limit)
    const hasNextPage = page < totalPages
    const hasPreviousPage = page > 1

    logger.info({ 
      msg: 'Fields fetched successfully',
      requestId, 
      count: fields.length, 
      totalCount, 
      page, 
      limit, 
      totalPages, 
      filters: { type, location, minPrice, maxPrice } 
    })
    
    return NextResponse.json({ 
      success: true,
      data: enrichedFields,
      pagination: {
        currentPage: page,
        totalPages,
        totalItems: totalCount,
        itemsPerPage: limit,
        hasNextPage,
        hasPreviousPage
      },
      filters: {
        applied: { type, location, minPrice, maxPrice, sortBy, sortOrder },
        available: {
          types: ['FOOTBALL', 'BASKETBALL', 'TENNIS', 'SWIMMING'],
          locations: ['ÿßŸÑŸÇÿßŸáÿ±ÿ©', 'ÿßŸÑÿ¨Ÿäÿ≤ÿ©', 'ÿßŸÑÿ•ÿ≥ŸÉŸÜÿØÿ±Ÿäÿ©', 'ÿßŸÑŸÖŸÜÿµŸàÿ±ÿ©'],
          priceRange: { min: 50, max: 500, step: 50 }
        }
      },
      metadata: {
        requestId,
        generatedAt: new Date().toISOString(),
        cacheInfo: { recommended: true, duration: 300 }
      }
    }, {
      headers: {
        'Cache-Control': 'public, max-age=300, stale-while-revalidate=60',
        'X-Total-Count': totalCount.toString(),
        'X-Page-Count': totalPages.toString(),
        'X-Request-ID': requestId
      }
    })
    
  } catch (error: any) {
    logger.error({ 
      msg: 'Error fetching fields',
      error: error.message,
      requestId, 
      url: request.url 
    })
    return apiErrorHandler(error)
  }
}
// app/api/fields/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { FIELD_STATUS } from '@/lib/shared/constants'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { logger } from '@/lib/shared/logger'

interface Params {
  params: {
    id: string
  }
}

export async function GET(
  request: NextRequest,
  { params }: Params
) {
  const requestId = `get_field_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    const fieldId = params.id
    
    const userAgent = request.headers.get('user-agent') || 'unknown'
    const ip = request.headers.get('x-forwarded-for') || request.headers.get('x-real-ip') || 'unknown'
    const acceptLanguage = request.headers.get('accept-language') || 'unknown'
    
    logger.info({ 
      requestId, 
      fieldId,
      userAgent,
      ip,
      acceptLanguage,
      url: request.url,
      method: request.method
    }, 'Fetching field details')

    if (!fieldId) {
      throw new DomainError('VALIDATION_ERROR', 'ŸÖÿπÿ±ŸëŸÅ ÿßŸÑŸÖŸÑÿπÿ® ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠')
    }

    const ifNoneMatch = request.headers.get('if-none-match')
    const cacheKey = `field_${fieldId}`
    
    if (ifNoneMatch === cacheKey) {
      return new NextResponse(null, { status: 304 })
    }

    // ‚úÖ ÿ¥ŸäŸÑ reviewCount ŸÖŸÜ select
    const field = await prisma.field.findUnique({
      where: { id: fieldId },
      select: {
        id: true,
        name: true,
        description: true,
        location: true,
        address: true,
        type: true,
        imageUrl: true,
        pricePerHour: true,
        depositPrice: true,
        openingTime: true,
        closingTime: true,
        slotDurationMin: true,
        status: true,
        facilities: true,
        gallery: true
      }
    })

    if (!field) {
      logger.warn({ requestId, fieldId, ip }, 'Field not found')
      throw new DomainError('FIELD_NOT_FOUND', 'ÿßŸÑŸÖŸÑÿπÿ® ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ')
    }

    if (field.status === FIELD_STATUS.CLOSED || field.status === FIELD_STATUS.MAINTENANCE) {
      logger.warn({ 
        requestId, 
        fieldId, 
        status: field.status,
        ip 
      }, 'Field not available')
      
      return NextResponse.json({
        success: false,
        error: 'ÿßŸÑŸÖŸÑÿπÿ® ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ ÿ≠ÿßŸÑŸäŸãÿß',
        code: 'FIELD_UNAVAILABLE',
        field: {
          id: field.id,
          name: field.name,
          status: field.status,
          estimatedReopen: field.status === FIELD_STATUS.MAINTENANCE ? 
            'ÿÆŸÑÿßŸÑ 24 ÿ≥ÿßÿπÿ©' : 'ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ'
        }
      }, { 
        status: 403,
        headers: {
          'Cache-Control': 'no-cache',
          'X-Field-Status': field.status
        }
      })
    }

    const bookingsCount = await prisma.booking.count({
      where: {
        fieldId: fieldId,
        status: 'CONFIRMED'
      }
    })

    logger.info({ 
      requestId, 
      fieldId,
      totalBookings: bookingsCount
    }, 'Field details fetched successfully')
    
    return NextResponse.json({
      success: true,
      data: {
        field: {
          ...field,
          gallery: field.gallery || [],
          popularity: bookingsCount
        }
      },
      metadata: {
        cached: false,
        expires: new Date(Date.now() + 5 * 60 * 1000).toISOString()
      }
    }, {
      headers: {
        'ETag': cacheKey,
        'Cache-Control': 'public, max-age=300',
        'X-Request-ID': requestId
      }
    })
    
  } catch (error: any) {
    logger.error('Error fetching field', error, { 
      requestId,
      url: request.url 
    })
    return apiErrorHandler(error)
  }
}
// app/api/fields/[id]/slots/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { generateSlotsForDay } from '@/lib/domain/slots/time-slots/core-logic'
import { getUISlots } from '@/lib/domain/slots/read-model'
import { FIELD_STATUS, SLOT_STATUS } from '@/lib/shared/constants'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { logger } from '@/lib/shared/logger'

export async function GET(
  request: NextRequest,
  { params }: { params: { fieldId: string } }
) {
  const requestId = `get_slots_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    const fieldId = params.fieldId
    const { searchParams } = new URL(request.url)
    const dateParam = searchParams.get('date')
    
    // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ request ŸÑŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ rate limiting
    const ip = request.headers.get('x-forwarded-for') || 'unknown'
    const userAgent = request.headers.get('user-agent') || 'unknown'
    
    logger.info({ 
      requestId, 
      fieldId, 
      dateParam,
      ip,
      userAgent 
    }, 'Fetching slots')

    if (!fieldId) {
      throw new DomainError('VALIDATION_ERROR', 'ŸÖÿπÿ±ŸÅ ÿßŸÑŸÖŸÑÿπÿ® ŸÖÿ∑ŸÑŸàÿ®')
    }

    if (!dateParam) {
      throw new DomainError('VALIDATION_ERROR', 'ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ŸÖÿ∑ŸÑŸàÿ®')
    }

    const date = new Date(dateParam)
    if (isNaN(date.getTime())) {
      throw new DomainError('VALIDATION_ERROR', 'ÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠')
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ŸÑŸäÿ≥ ŸÅŸä ÿßŸÑŸÖÿßÿ∂Ÿä
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    
    if (date < today) {
      throw new DomainError('INVALID_DATE', 'ŸÑÿß ŸäŸÖŸÉŸÜ ÿ≠ÿ¨ÿ≤ ŸÖŸàÿßÿπŸäÿØ ŸÅŸä ÿßŸÑŸÖÿßÿ∂Ÿä')
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ŸÑŸäÿ≥ ÿ£ÿ®ÿπÿØ ŸÖŸÜ 30 ŸäŸàŸÖ
    const maxDate = new Date()
    maxDate.setDate(maxDate.getDate() + 30)
    
    if (date > maxDate) {
      throw new DomainError('INVALID_DATE', 'ŸÑÿß ŸäŸÖŸÉŸÜ ÿ≠ÿ¨ÿ≤ ŸÖŸàÿßÿπŸäÿØ ÿ£ÿ®ÿπÿØ ŸÖŸÜ 30 ŸäŸàŸÖ')
    }

    const field = await prisma.field.findUnique({
      where: { id: fieldId }
    })

    if (!field) {
      throw new DomainError('FIELD_NOT_FOUND', 'ÿßŸÑŸÖŸÑÿπÿ® ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ')
    }

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≠ÿßŸÑÿ© ÿßŸÑŸÖŸÑÿπÿ®
    if (field.status === FIELD_STATUS.CLOSED) {
      logger.info({ requestId, fieldId }, 'Field is closed')
      return NextResponse.json({
        success: true,
        data: {
          slots: [],
          field: {
            id: field.id,
            name: field.name,
            status: field.status,
            message: 'ÿßŸÑŸÖŸÑÿπÿ® ŸÖÿ∫ŸÑŸÇ ÿ≠ÿßŸÑŸäÿßŸã'
          },
          metadata: {
            reason: 'FIELD_CLOSED',
            reopenDate: field.closingTime ? new Date(field.closingTime).toISOString() : null
          }
        }
      })
    }

    if (field.status === FIELD_STATUS.MAINTENANCE) {
      logger.info({ requestId, fieldId }, 'Field is under maintenance')
      return NextResponse.json({
        success: true,
        data: {
          slots: [],
          field: {
            id: field.id,
            name: field.name,
            status: field.status,
            message: 'ÿßŸÑŸÖŸÑÿπÿ® ÿ™ÿ≠ÿ™ ÿßŸÑÿµŸäÿßŸÜÿ©'
          },
          metadata: {
            reason: 'FIELD_MAINTENANCE',
            estimatedCompletion: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
          }
        }
      })
    }

    // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ≥ŸÑÿßÿ™ ÿßŸÑŸÖŸÇŸÅŸàŸÑÿ© ÿßŸÑŸÖŸÜÿ™ŸáŸäÿ©
    const cleanupResult = await prisma.slot.updateMany({
      where: {
        fieldId,
        status: SLOT_STATUS.TEMP_LOCKED,
        lockedUntil: { lt: new Date() }
      },
      data: {
        status: SLOT_STATUS.AVAILABLE,
        lockedByUserId: null,
        lockedUntil: null
      }
    })

    if (cleanupResult.count > 0) {
      logger.debug({ 
        requestId, 
        cleaned: cleanupResult.count 
      }, 'Cleaned expired locks')
    }

    // ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿ≥ŸÑÿßÿ™
    const slots = await generateSlotsForDay({
      fieldId,
      date,
      now: new Date()
    })

    const uiSlots = getUISlots(slots)

    // ‚úÖ ÿ•ÿµŸÑÿßÿ≠: ÿßÿ≥ÿ™ÿÆÿØŸÖ uiStatus ÿ®ÿØŸÑÿßŸã ŸÖŸÜ status
    const availableSlots = uiSlots.filter(s => s.uiStatus === 'AVAILABLE').length
    const lockedSlots = uiSlots.filter(s => s.uiStatus === 'LOCKED_ME' || s.uiStatus === 'LOCKED_OTHER').length
    const bookedSlots = uiSlots.filter(s => s.uiStatus === 'BOOKED').length

    logger.info({ 
      requestId, 
      fieldId, 
      slotCount: uiSlots.length,
      availableSlots,
      lockedSlots
    }, 'Slots fetched successfully')
    
    return NextResponse.json({
      success: true,
      data: {
        field: {
          id: field.id,
          name: field.name,
          description: field.description,
          status: field.status,
          pricePerHour: field.pricePerHour,
          depositPrice: field.depositPrice,
          openingTime: field.openingTime,
          closingTime: field.closingTime,
          slotDurationMin: field.slotDurationMin
        },
        slots: uiSlots,
        date: date.toISOString().split('T')[0],
        statistics: {
          total: uiSlots.length,
          available: availableSlots, // ‚úÖ ŸÖÿ≥ÿ™ÿÆÿØŸÖ uiStatus
          locked: lockedSlots,       // ‚úÖ ŸÖÿ≥ÿ™ÿÆÿØŸÖ uiStatus
          booked: bookedSlots        // ‚úÖ ŸÖÿ≥ÿ™ÿÆÿØŸÖ uiStatus
        }
      }
    }, {
      headers: {
        'Cache-Control': 'public, max-age=60', // 1 ÿØŸÇŸäŸÇÿ© ŸÑŸÑÿ≥ŸÑÿßÿ™
        'X-Request-ID': requestId
      }
    })

  } catch (error: any) {
    logger.error('Get slots error', error, { 
      requestId,
      url: request.url 
    })
    return apiErrorHandler(error)
  }
}
// app/api/fields/[id]/slots/date/[date]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { parseISO, isValid, startOfDay } from 'date-fns'
import { generateSlotsForDay } from '@/lib/domain/slots/time-slots/core-logic'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { SLOT_STATUS } from '@/lib/shared/constants'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { logger } from '@/lib/shared/logger'

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string; date: string } }
) {
  const requestId = `get_slots_by_date_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    const { id: fieldId, date } = params

    const userAgent = request.headers.get('user-agent') || 'unknown'
    const accept = request.headers.get('accept') || 'application/json'
    
    logger.info({ 
      requestId, 
      fieldId, 
      date,
      userAgent,
      accept
    }, 'Fetching slots by date')

    if (!fieldId || !date) {
      throw new DomainError('VALIDATION_ERROR', 'ŸÖÿπÿ±ŸÅ ÿßŸÑŸÖŸÑÿπÿ® ŸàÿßŸÑÿ™ÿßÿ±ŸäÿÆ ŸÖÿ∑ŸÑŸàÿ®ÿßŸÜ')
    }

    const parsedDate = parseISO(date)

    if (!isValid(parsedDate)) {
      throw new DomainError('VALIDATION_ERROR', 'ÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠. Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ YYYY-MM-DD')
    }

    const now = new Date()
    const startOfToday = startOfDay(now)
    
    if (parsedDate < startOfToday) {
      throw new DomainError('INVALID_DATE', 'ŸÑÿß ŸäŸÖŸÉŸÜ ÿπÿ±ÿ∂ ŸÖŸàÿßÿπŸäÿØ ŸÅŸä ÿßŸÑŸÖÿßÿ∂Ÿä')
    }

    const cleanupResult = await prisma.slot.updateMany({
      where: {
        fieldId,
        status: SLOT_STATUS.TEMP_LOCKED,
        lockedUntil: { lt: now }
      },
      data: {
        status: SLOT_STATUS.AVAILABLE,
        lockedUntil: null,
        lockedByUserId: null
      }
    })

    if (cleanupResult.count > 0) {
      logger.debug({
        requestId,
        cleaned: cleanupResult.count
      }, 'Cleaned expired locks')
    }

    const slots = await generateSlotsForDay({
      fieldId,
      date: startOfDay(parsedDate),
      now
    })

    const normalizedSlots = slots.map(slot => {
      const startTimeISO = slot.startTime.toISOString()
      const endTimeISO = slot.endTime.toISOString()

      return {
        ...slot,
        startTime: startTimeISO,
        endTime: endTimeISO,
        durationMinutes: Math.floor(
          (slot.endTime.getTime() - slot.startTime.getTime()) / (1000 * 60)
        ),
        price: slot.price,
        isPast: slot.startTime < now, // ŸáŸÜÿß ŸÑÿ≥Ÿá Date
        canBook: slot.status === 'AVAILABLE' && slot.startTime > now,
        timeUntilStart: slot.startTime.getTime() - now.getTime()
      }
    })

    const stats = {
      total: normalizedSlots.length,
      available: normalizedSlots.filter(s => s.status === 'AVAILABLE').length,
      locked: normalizedSlots.filter(s => s.status === 'TEMP_LOCKED').length,
      booked: normalizedSlots.filter(s => s.status === 'BOOKED').length,
      past: normalizedSlots.filter(s => new Date(s.startTime) < now).length
    }

    logger.info({ 
      requestId, 
      fieldId, 
      date,
      slotCount: normalizedSlots.length,
      stats
    }, 'Slots by date fetched successfully')
    
    return NextResponse.json({
      success: true,
      data: {
        fieldId,
        date: parsedDate.toISOString().split('T')[0],
        slots: normalizedSlots,
        statistics: stats,
        metadata: {
          generatedAt: now.toISOString(),
          cacheDuration: 60,
          timezone: 'Africa/Cairo'
        }
      }
    }, {
      headers: {
        'Cache-Control': 'public, max-age=60',
        'X-Request-ID': requestId,
        'X-Slots-Count': normalizedSlots.length.toString()
      }
    })
    
  } catch (error: any) {
    logger.error('Get slots by date error', error, { 
      requestId,
      url: request.url 
    })
    return apiErrorHandler(error)
  }
}
// app/api/fields/[fieldId]/slots/[slotId]/lock/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'
import { addMinutes } from 'date-fns'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { SLOT_STATUS } from '@/lib/shared/constants'
import { logger } from '@/lib/shared/logger'
import { assertSlotCanLock } from '@/lib/domain/guards/slot-guards' // ‚úÖ ÿßŸÑÿ¢ŸÜ ŸÖÿ≥ÿ™ÿÆÿØŸÖ

const LOCK_DURATION_MINUTES = 5

export async function POST(
  request: NextRequest,
  { params }: { params: { fieldId: string; slotId: string } }
) {
  const requestId = `lock_slot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ request ŸÑŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ headers
    const userAgent = request.headers.get('user-agent') || 'unknown'
    const ip = request.headers.get('x-forwarded-for') || 'unknown'
    
    logger.info({ 
      requestId, 
      fieldId: params.fieldId,
      slotId: params.slotId,
      userAgent,
      ip,
      endpoint: request.url
    }, 'Locking slot')

    const session = await getServerSession(authOptions)
    const userId = session?.user?.id

    if (!userId) {
      logger.warn({ 
        requestId,
        ip,
        userAgent,
        fieldId: params.fieldId,
        slotId: params.slotId
      }, 'Unauthorized lock attempt')
      throw new DomainError('UNAUTHORIZED', 'Ÿäÿ¨ÿ® ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÑŸÇŸÅŸÑ ÿßŸÑŸÖŸàÿßÿπŸäÿØ')
    }

    const { slotId, fieldId } = params
    const now = new Date()

    // ‚úÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ assertSlotCanLock ŸÑŸÑÿ™ÿ≠ŸÇŸÇ ŸÇÿ®ŸÑ ÿßŸÑŸÇŸÅŸÑ
    const validation = await assertSlotCanLock({
      slotId,
      userId,
      fieldId
    })

    // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸäŸÖŸÉŸÜ ÿ™ŸÖÿØŸäÿØ ÿßŸÑŸÇŸÅŸÑ
    if (validation.canExtend) {
      logger.info({
        requestId,
        slotId,
        userId,
        previousLockUntil: validation.slot.lockedUntil,
        newLockUntil: addMinutes(now, LOCK_DURATION_MINUTES)
      }, 'Extending existing lock')
      
      await prisma.slot.update({
        where: { id: slotId },
        data: {
          lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES)
        }
      })

      return NextResponse.json({
        success: true,
        data: {
          extended: true,
          lockDuration: LOCK_DURATION_MINUTES,
          lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES).toISOString(),
          message: 'ÿ™ŸÖ ÿ™ŸÖÿØŸäÿØ ŸÇŸÅŸÑ ÿßŸÑŸÖŸàÿπÿØ ÿ®ŸÜÿ¨ÿßÿ≠'
        },
        metadata: {
          requestId,
          userId,
          timestamp: now.toISOString()
        }
      })
    }

    // ŸÇŸÅŸÑ ÿ¨ÿØŸäÿØ
    const result = await prisma.$transaction(async (tx: any) => {
      const updateResult = await tx.slot.updateMany({
        where: {
          id: slotId,
          fieldId: fieldId,
          OR: [
            {
              status: SLOT_STATUS.AVAILABLE
            },
            {
              status: SLOT_STATUS.TEMP_LOCKED,
              OR: [
                { lockedUntil: null },
                { lockedUntil: { lt: now } }
              ]
            }
          ]
        },
        data: {
          status: SLOT_STATUS.TEMP_LOCKED,
          lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES),
          lockedByUserId: userId
        }
      })

      if (updateResult.count === 0) {
        const slot = await tx.slot.findUnique({
          where: { id: slotId },
          include: {
            field: {
              select: { id: true, name: true }
            },
            lockedByUser: {
              select: { id: true, email: true, name: true }
            }
          }
        })

        if (!slot) {
          throw new DomainError('SLOT_NOT_FOUND', 'ÿßŸÑŸÖŸàÿπÿØ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ')
        }

        if (slot.status === SLOT_STATUS.BOOKED) {
          throw new DomainError('SLOT_ALREADY_BOOKED', 'ÿßŸÑŸÖŸàÿπÿØ ŸÖÿ≠ÿ¨Ÿàÿ≤ ÿ®ÿßŸÑŸÅÿπŸÑ')
        }

        if (slot.status === SLOT_STATUS.TEMP_LOCKED && slot.lockedUntil && slot.lockedUntil > now) {
          if (slot.lockedByUserId === userId) {
            // ÿ™ÿ≠ÿØŸäÿ´ ŸàŸÇÿ™ ÿßŸÑŸÇŸÅŸÑ
            await tx.slot.update({
              where: { id: slotId },
              data: {
                lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES)
              }
            })
            
            logger.info({ 
              requestId, 
              slotId, 
              userId,
              fieldName: slot.field?.name 
            }, 'Slot lock extended (fallback)')
            return { success: true, extended: true }
          } else {
            throw new DomainError('SLOT_LOCKED_BY_OTHER', 
              `ÿßŸÑŸÖŸàÿπÿØ ŸÖŸÇŸÅŸàŸÑ ÿ≠ÿßŸÑŸäÿßŸã ÿ®Ÿàÿßÿ≥ÿ∑ÿ© ${slot.lockedByUser?.name || 'ŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ¢ÿÆÿ±'}`
            )
          }
        }

        throw new DomainError('SLOT_CANNOT_BE_LOCKED', 'ŸÑÿß ŸäŸÖŸÉŸÜ ŸÇŸÅŸÑ Ÿáÿ∞ÿß ÿßŸÑŸÖŸàÿπÿØ ÿ≠ÿßŸÑŸäÿßŸã')
      }

      logger.info({ 
        requestId, 
        slotId, 
        userId,
        lockDuration: LOCK_DURATION_MINUTES,
        lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES).toISOString()
      }, 'Slot locked successfully')
      
      return { success: true, locked: true }
    })

    // ÿ¨ŸÑÿ® ÿ®ŸäÿßŸÜÿßÿ™ Slot ÿ®ÿπÿØ ÿßŸÑŸÇŸÅŸÑ
    const updatedSlot = await prisma.slot.findUnique({
      where: { id: slotId },
      select: {
        id: true,
        startTime: true,
        endTime: true,
        status: true,
        lockedUntil: true,
        field: {
          select: {
            id: true,
            name: true,
            pricePerHour: true
          }
        }
      }
    })

    return NextResponse.json({
      success: true,
      data: {
        ...result,
        slot: updatedSlot,
        lockDuration: LOCK_DURATION_MINUTES,
        lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES).toISOString(),
        expiresIn: LOCK_DURATION_MINUTES * 60, // ÿ®ÿßŸÑÿ´ŸàÿßŸÜŸä
        countdownStart: now.getTime(),
        message: result.extended ? 'ÿ™ŸÖ ÿ™ŸÖÿØŸäÿØ ÿßŸÑŸÇŸÅŸÑ' : 'ÿ™ŸÖ ŸÇŸÅŸÑ ÿßŸÑŸÖŸàÿπÿØ ÿ®ŸÜÿ¨ÿßÿ≠'
      },
      metadata: {
        requestId,
        userId,
        timestamp: now.toISOString(),
        cacheControl: 'no-cache'
      }
    }, {
      headers: {
        'Cache-Control': 'no-store, no-cache, must-revalidate',
        'X-Lock-Duration': LOCK_DURATION_MINUTES.toString(),
        'X-Request-ID': requestId
      }
    })

  } catch (error: any) {
    logger.error('Lock error', error, { 
      requestId,
      url: request.url,
      params,
      ip: request.headers.get('x-forwarded-for') || 'unknown'
    })
    
    return apiErrorHandler(error)
  }
}
// app/api/payment/create/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'
import { BookingOrchestrator } from '@/lib/application/services/booking-orchestrator' // üîß ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ ÿßŸÑŸÉŸÑÿßÿ≥
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { logger } from '@/lib/shared/logger'

export async function POST(request: NextRequest) {
  const requestId = `create_payment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    logger.info({ requestId }, 'Creating payment')

    const session = await getServerSession(authOptions)
    const userId = session?.user?.id

    if (!userId) {
      logger.warn({ requestId }, 'Unauthorized payment attempt')
      return NextResponse.json(
        { error: 'Ÿäÿ¨ÿ® ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ£ŸàŸÑÿßŸã' },
        { status: 401 }
      )
    }

    const { bookingId, amount, currency = 'EGP', idempotencyKey } = await request.json()

    if (!bookingId || !amount) {
      logger.warn({ requestId, bookingId, amount }, 'Incomplete payment data')
      return NextResponse.json(
        { error: 'ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿØŸÅÿπ ÿ∫Ÿäÿ± ŸÖŸÉÿ™ŸÖŸÑÿ©' },
        { status: 400 }
      )
    }

    if (amount <= 0) {
      logger.warn({ requestId, amount }, 'Invalid payment amount')
      return NextResponse.json(
        { error: 'ŸÇŸäŸÖÿ© ÿßŸÑÿØŸÅÿπ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ©' },
        { status: 400 }
      )
    }

    // üîß ÿßŸÑÿ™ÿπÿØŸäŸÑ ŸáŸÜÿß
    const result = await BookingOrchestrator.initiatePayment({  // ‚úÖ BookingOrchestrator.
      bookingId,
      amount,
      currency,
      idempotencyKey,
      userId,
    })

    logger.info({
      requestId,
      bookingId,
      orderId: result.orderId,
      userId
    }, 'Payment initiated successfully')

    return NextResponse.json({
      success: true,
      data: result,
      message: 'ÿ™ŸÖ ÿ®ÿØÿ° ÿπŸÖŸÑŸäÿ© ÿßŸÑÿØŸÅÿπ ÿ®ŸÜÿ¨ÿßÿ≠'
    })

  } catch (error: any) {
    logger.error('Payment creation error', error, { requestId })
    return apiErrorHandler(error)
  }
}
// app/api/webhooks/paymob/route.ts
import { NextRequest } from 'next/server'
import { BookingOrchestrator } from '@/lib/application/services/booking-orchestrator'
import { paymobService } from '@/lib/infrastructure/payments/providers'
import { assertWebhookValid } from '@/lib/domain/guards/payment-guards'
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { logger } from '@/lib/shared/logger'
import { parseISO, differenceInMinutes } from 'date-fns'

export async function POST(request: NextRequest) {
  const webhookId = `webhook_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

  try {
    logger.info({
      webhookId,
      ip: request.headers.get('x-forwarded-for') || 'unknown',
      userAgent: request.headers.get('user-agent') || 'unknown'
    }, 'Processing Paymob webhook')

    const body = await request.json()
    const hmac = request.headers.get('hmac')

    if (!hmac) {
      logger.error({
        webhookId,
        headers: Object.fromEntries(request.headers.entries())
      }, 'HMAC header missing')
      return apiErrorHandler(new Error('HMAC header missing'))
    }

    // 1Ô∏è‚É£ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ HMAC
    if (!paymobService.verifyHMAC(body.obj, hmac)) {
      logger.error({
        webhookId,
        hmac,
        bodyHash: JSON.stringify(body.obj).length
      }, 'Invalid HMAC signature')
      return apiErrorHandler(new Error('Invalid HMAC signature'))
    }

    // 2Ô∏è‚É£ ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
    const {
      success,
      amount_cents,
      id: transactionId,
      order: { id: orderId, merchant_order_id: bookingId },
      created_at,
      currency = 'EGP'
    } = body.obj

    const createdAt = parseISO(created_at)
    const now = new Date()
    const minutesDiff = differenceInMinutes(now, createdAt)

    logger.info({
      webhookId,
      bookingId,
      orderId,
      transactionId,
      success,
      amount: amount_cents / 100,
      created_at: createdAt.toISOString(),
      minutesAgo: minutesDiff,
      currency
    }, 'Webhook data extracted')

    if (minutesDiff > 60) {
      logger.warn({
        webhookId,
        minutesDiff,
        created_at: createdAt.toISOString(),
        received_at: now.toISOString()
      }, 'Webhook is too old, ignoring')
      return new Response('OK', {
        status: 200,
        headers: {
          'Content-Type': 'text/plain',
          'X-Webhook-Status': 'IGNORED_OLD'
        }
      })
    }

    // 3Ô∏è‚É£ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµÿ≠ÿ© ÿßŸÑŸÄ webhook
    const payment = await assertWebhookValid({
      orderId: orderId.toString(),
      transactionId: transactionId.toString(),
      amount: amount_cents / 100
    })

    logger.info({
      webhookId,
      paymentId: payment.id,
      bookingId: payment.bookingId,
      previousStatus: payment.status,
      created_at: createdAt.toISOString(),
      processingDelay: minutesDiff
    }, 'Webhook validated')

    // 4Ô∏è‚É£ ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ≠ÿ¨ÿ≤
    const processingStart = Date.now()

    await BookingOrchestrator.completeBooking({
      bookingId: payment.bookingId,
      success: Boolean(success),
      paymentDetails: {
        transactionId: transactionId.toString(),
        orderId: orderId.toString(),
        amount: amount_cents / 100,
        currency
      }
    })

    const processingTime = Date.now() - processingStart

    logger.info({
      webhookId,
      bookingId: payment.bookingId,
      success,
      processingTime,
      totalTimeFromCreation: minutesDiff + processingTime / 60000
    }, 'Booking processing completed')

    return new Response('OK', {
      status: 200,
      headers: {
        'Content-Type': 'text/plain',
        'X-Webhook-ID': webhookId,
        'X-Processing-Time': processingTime.toString(),
        'X-Booking-ID': payment.bookingId
      }
    })
  } catch (error: any) {
    logger.error('Webhook processing error', error, {
      webhookId,
      url: request.url,
      body: JSON.stringify(await request.json()).substring(0, 500)
    })

    return new Response('ERROR', {
      status: 500,
      headers: {
        'Content-Type': 'text/plain',
        'X-Webhook-Status': 'ERROR',
        'X-Error-Message': error.message.substring(0, 100)
      }
    })
  }
}
//app/page.tsx
import { redirect } from 'next/navigation'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'
import Header from '@/components/layout/header'
import Footer from '@/components/layout/footer'
import HeroSection from '@/components/home/hero-section'
import FeaturedFields from '@/components/home/featured-fields'
import HowItWorks from '@/components/home/how-it-works'
import MainCardsGrid from '@/components/home/main-cards-grid'

export default async function HomePage() {
  const session = await getServerSession(authOptions)
  
  // ÿ™Ÿàÿ¨ŸäŸá ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÖÿ≥ÿ¨ŸÑ ÿ•ŸÑŸâ dashboard
  if (session) {
    redirect('/dashboard')
  }
  
  return (
    <div className="min-h-screen bg-gradient-to-b from-gray-50 to-white">
      <Header />
      <main className="container mx-auto px-4 py-8">
        <section className="mb-16">
          <HeroSection />
        </section>
        
        <section className="my-16">
          <h2 className="text-3xl md:text-4xl font-bold text-center text-gray-900 mb-12">
            ÿßÿ®ÿØÿ£ ÿ≠ÿ¨ÿ≤ŸÉ ÿßŸÑÿ¢ŸÜ
          </h2>
          <MainCardsGrid />
        </section>
        
        <section className="my-16">
          <HowItWorks />
        </section>
        
        <section className="my-16">
          <FeaturedFields />
        </section>
        
        <section className="text-center my-16 bg-blue-50 rounded-2xl p-8">
          <h2 className="text-3xl font-bold text-gray-900 mb-4">
            ÿßŸÜÿ∂ŸÖ ÿ•ŸÑŸâ ŸÖÿ¨ÿ™ŸÖÿπŸÜÿß
          </h2>
          <p className="text-gray-600 mb-6 max-w-2xl mx-auto">
            ÿ≥ÿ¨ŸÑ ÿßŸÑÿ¢ŸÜ Ÿàÿ™ŸÖÿ™ÿπ ÿ®ÿ™ÿ¨ÿ±ÿ®ÿ© ÿ≠ÿ¨ÿ≤ ŸÖŸÑÿßÿπÿ® ÿ≥ŸÑÿ≥ÿ© Ÿàÿ•ÿØÿßÿ±ÿ© ŸÅÿπÿßŸÑÿ©
          </p>
          <div className="flex justify-center gap-4">
            <a 
              href="/login" 
              className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition"
            >
              ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ
            </a>
            <a 
              href="/register" 
              className="px-6 py-3 bg-white text-blue-600 border border-blue-600 rounded-lg hover:bg-blue-50 transition"
            >
              ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ®
            </a>
          </div>
        </section>
      </main>
      <Footer />
    </div>
  )
}
//app/layout.tsx
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'
import AuthProvider from '@/components/providers/Authprovider'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'ÿßÿ≠ÿ¨ÿ≤ŸÑŸä - ŸÜÿ∏ÿßŸÖ ÿ≠ÿ¨ÿ≤ ÿßŸÑŸÖŸÑÿßÿπÿ®',
  description: 'ŸÜÿ∏ÿßŸÖ ÿ≠ÿ¨ÿ≤ ÿßŸÑŸÖŸÑÿßÿπÿ® ÿßŸÑÿ±Ÿäÿßÿ∂Ÿäÿ©',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="ar" dir="rtl">
      <body className={inter.className}>
        <AuthProvider>
          {children}
        </AuthProvider>
      </body>
    </html>
  )
}
//app/(auth)/layout.tsx
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'ŸÜÿ∏ÿßŸÖ ÿ≠ÿ¨ÿ≤ ÿßŸÑŸÖŸÑÿßÿπÿ® ÿßŸÑÿ±Ÿäÿßÿ∂Ÿäÿ©',
  description: 'ŸÜÿ∏ÿßŸÖ ŸÖÿ™ŸÉÿßŸÖŸÑ ŸÑÿ≠ÿ¨ÿ≤ ÿßŸÑŸÖŸÑÿßÿπÿ® ÿßŸÑÿ±Ÿäÿßÿ∂Ÿäÿ©',
}

export default function AuthLayout({ 
  children 
}: { 
  children: React.ReactNode 
}) {
  return (
    <div className="min-h-screen">
      {children}
    </div>
  )
}
// app/(auth)/register/page.tsx
'use client'

import { useState } from 'react'
import Link from 'next/link'
import { useRouter } from 'next/navigation'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { registerSchema, type RegisterInput } from '@/lib/infrastructure/auth/validators' // ‚úÖ ÿßŸÑŸÖÿ≥ÿßÿ± ÿßŸÑÿ¨ÿØŸäÿØ
import { 
  User, Mail, Lock, Phone, Calendar, Star, FileText, ShieldCheck, Check, X, 
  Sparkles, Target, Trophy 
} from 'lucide-react'
import Button from '@/components/ui/button'
import Input from '@/components/ui/input'
import Alert from '@/components/ui/alert'
import { cn } from '@/lib/shared/utils' // ŸäŸÖŸÉŸÜŸÉ ÿ•ŸÜÿ¥ÿßÿ° Ÿáÿ∞ÿß ÿßŸÑŸÖŸÑŸÅ

export default function RegisterPage() {
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState('')
  const [skillLevel, setSkillLevel] = useState<'WEAK' | 'AVERAGE' | 'GOOD' | 'EXCELLENT' | 'LEGENDARY'>('AVERAGE')
  const router = useRouter()
  
  const {
    register,
    handleSubmit,
    formState: { errors },
    watch,
    setValue
  } = useForm<RegisterInput>({
    resolver: zodResolver(registerSchema),
    defaultValues: {
      name: '',
      email: '',
      password: '',
      confirmPassword: '',
      phoneNumber: '',
      age: undefined,
      description: '',
      skillLevel: 'AVERAGE'
    }
  })

  // ‚úÖ ÿßŸÑÿ™ÿπÿØŸäŸÑ: ÿ•ÿ≤ÿßŸÑÿ© useAuth() Ÿàÿßÿ≥ÿ™ÿÆÿØÿßŸÖ fetch ŸÖÿ®ÿßÿ¥ÿ±ÿ©
  const registerUser = async (data: RegisterInput) => {
    const response = await fetch('/api/auth/register', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    
    const result = await response.json();
    if (!result.success) throw new Error(result.error);
    
    // Redirect to login
    router.push('/login?registered=true');
  };

  const password = watch('password')
  const confirmPassword = watch('confirmPassword')
  const description = watch('description')

  // ‚úÖ ÿßŸÑÿ™ÿπÿØŸäŸÑ: ÿ≥Ÿäÿßÿ≥ÿ© ÿ®ÿßÿ≥Ÿàÿ±ÿØ ŸÖÿ®ÿ≥ÿ∑ÿ© (6 ÿ£ÿ≠ÿ±ŸÅ ŸÅŸÇÿ∑)
  const passwordChecks = [
    { label: '6 ÿ£ÿ≠ÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ', check: password?.length >= 6 },
    { label: 'ÿ£ŸÇŸÑ ŸÖŸÜ 72 ÿ≠ÿ±ŸÅÿßŸã', check: password?.length <= 72 },
  ];

  const onSubmit = async (data: RegisterInput) => {
    setIsLoading(true)
    setError('')
    
    try {
      // ‚úÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿØÿßŸÑÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ©
      await registerUser(data)
    } catch (err: any) {
      setError(err.message || 'ŸÅÿ¥ŸÑ ŸÅŸä ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ')
    } finally {
      setIsLoading(false)
    }
  }

  const skillLevels = [
    { value: 'WEAK' as const, label: 'ÿ∂ÿπŸäŸÅ', desc: 'ŸÖÿ®ÿ™ÿØÿ¶', icon: 'üòÖ' },
    { value: 'AVERAGE' as const, label: 'ŸÖÿ™Ÿàÿ≥ÿ∑', desc: 'ŸÑÿØŸäŸá ÿÆÿ®ÿ±ÿ©', icon: 'üòä' },
    { value: 'GOOD' as const, label: 'ÿ¨ŸäÿØ', desc: 'ŸÖÿ™ŸÖŸÉŸÜ', icon: 'üòé' },
    { value: 'EXCELLENT' as const, label: 'ŸÖŸÖÿ™ÿßÿ≤', desc: 'ŸÖÿ≠ÿ™ÿ±ŸÅ', icon: 'üî•' },
    { value: 'LEGENDARY' as const, label: 'ÿ£ÿ≥ÿ∑Ÿàÿ±Ÿä', desc: 'ÿÆÿ®Ÿäÿ±', icon: 'üëë' }
  ]

  const passwordStrength = passwordChecks.filter(check => check.check).length
  const strengthPercentage = (passwordStrength / 2) * 100
  const strengthColor = passwordStrength <= 1 ? 'red' : 'green'
  const strengthText = passwordStrength <= 1 ? 'ÿ∂ÿπŸäŸÅÿ©' : 'ÿ¨ŸäÿØÿ©'

  const selectedSkill = skillLevels.find(level => level.value === skillLevel)

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-purple-900 to-violet-900">
      {/* Animated Background Elements */}
      <div className="fixed inset-0 overflow-hidden pointer-events-none">
        <div className="absolute -top-40 -right-40 w-80 h-80 bg-blue-500/10 rounded-full blur-3xl" />
        <div className="absolute top-1/3 -left-40 w-80 h-80 bg-purple-500/10 rounded-full blur-3xl" />
        <div className="absolute bottom-40 right-1/4 w-60 h-60 bg-pink-500/10 rounded-full blur-3xl" />
      </div>

      <div className="container mx-auto px-4 py-8 relative">
        <div className="flex flex-col lg:flex-row gap-8">
          {/* Left Side - Welcome & Features */}
          <div className="lg:w-2/5 flex flex-col justify-center text-white p-6 lg:p-12">
            <div className="mb-12">
              <div className="inline-flex items-center gap-3 mb-6">
                <div className="p-4 bg-gradient-to-br from-blue-500 to-purple-600 rounded-2xl shadow-2xl">
                  <Sparkles className="w-10 h-10 text-white" />
                </div>
                <div>
                  <h1 className="text-5xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 via-purple-400 to-pink-400">
                    ŸÖÿ±ÿ≠ÿ®ÿßŸã ÿ®ŸÉ
                  </h1>
                  <p className="text-2xl font-semibold text-gray-300 mt-2">ŸÅŸä ÿπÿßŸÑŸÖ ÿßŸÑÿ£ŸÑÿπÿßÿ®</p>
                </div>
              </div>
              <p className="text-xl text-gray-300 leading-relaxed">
                ÿßŸÜÿ∂ŸÖ ÿ•ŸÑŸâ ÿ¢ŸÑÿßŸÅ ÿßŸÑŸÑÿßÿπÿ®ŸäŸÜ ÿßŸÑŸÖÿ≠ÿ™ÿ±ŸÅŸäŸÜ Ÿàÿßÿ®ÿØÿ£ ÿ±ÿ≠ŸÑÿ™ŸÉ ŸÜÿ≠Ÿà ÿßŸÑÿ™ŸÖŸäÿ≤. 
                ÿ£ŸÜÿ¥ÿ¶ ŸÖŸÑŸÅŸÉ ÿßŸÑÿ¥ÿÆÿµŸä ŸàÿßŸÉÿ™ÿ¥ŸÅ ÿπÿßŸÑŸÖÿßŸã ŸÖŸÜ ÿßŸÑÿ™ÿ≠ÿØŸäÿßÿ™ ŸàÿßŸÑÿ•ŸÜÿ¨ÿßÿ≤ÿßÿ™.
              </p>
            </div>
            
            <div className="space-y-6">
              {/* Feature 1 */}
              <div className="bg-gradient-to-r from-white/5 to-white/0 p-6 rounded-2xl border border-white/10 backdrop-blur-sm hover:border-white/20 transition-all duration-300">
                <div className="flex items-center gap-4">
                  <div className="p-3 bg-gradient-to-br from-blue-500/30 to-blue-600/30 rounded-xl">
                    <ShieldCheck className="w-8 h-8 text-blue-400" />
                  </div>
                  <div>
                    <h3 className="text-xl font-semibold text-white">ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ≥ŸáŸÑ</h3>
                    <p className="text-gray-400 mt-1">ÿ™ÿ≥ÿ¨ŸäŸÑ ÿ®ÿ≥Ÿäÿ∑ ÿ®ÿØŸàŸÜ ÿ™ÿπŸÇŸäÿØÿßÿ™</p>
                  </div>
                </div>
              </div>
              
              {/* Feature 2 */}
              <div className="bg-gradient-to-r from-white/5 to-white/0 p-6 rounded-2xl border border-white/10 backdrop-blur-sm hover:border-white/20 transition-all duration-300">
                <div className="flex items-center gap-4">
                  <div className="p-3 bg-gradient-to-br from-purple-500/30 to-purple-600/30 rounded-xl">
                    <Target className="w-8 h-8 text-purple-400" />
                  </div>
                  <div>
                    <h3 className="text-xl font-semibold text-white">ÿ™ÿ≠ÿØŸäÿßÿ™ ŸÖŸÜÿßÿ≥ÿ®ÿ©</h3>
                    <p className="text-gray-400 mt-1">ÿ™ÿ≠ÿØŸäÿßÿ™ ÿ™ŸÑÿßÿ¶ŸÖ ŸÖÿ≥ÿ™ŸàÿßŸÉ Ÿàÿ™ÿ∑Ÿàÿ± ŸÖŸáÿßÿ±ÿßÿ™ŸÉ</p>
                  </div>
                </div>
              </div>
              
              {/* Feature 3 */}
              <div className="bg-gradient-to-r from-white/5 to-white/0 p-6 rounded-2xl border border-white/10 backdrop-blur-sm hover:border-white/20 transition-all duration-300">
                <div className="flex items-center gap-4">
                  <div className="p-3 bg-gradient-to-br from-green-500/30 to-green-600/30 rounded-xl">
                    <Trophy className="w-8 h-8 text-green-400" />
                  </div>
                  <div>
                    <h3 className="text-xl font-semibold text-white">ÿßŸÜÿ¨ÿßÿ≤ÿßÿ™ Ÿàÿ¨Ÿàÿßÿ¶ÿ≤</h3>
                    <p className="text-gray-400 mt-1">ÿßÿ≠ÿµŸÑ ÿπŸÑŸâ ŸÖŸÉÿßŸÅÿ¢ÿ™ Ÿàÿ™ŸÇÿØŸÖ ŸÅŸä ÿßŸÑŸÖÿ±ÿßÿ™ÿ®</p>
                  </div>
                </div>
              </div>
            </div>

            {/* Stats */}
            <div className="mt-12 grid grid-cols-3 gap-4">
              <div className="text-center p-4 bg-white/5 rounded-xl border border-white/10">
                <div className="text-2xl font-bold text-white">10K+</div>
                <div className="text-sm text-gray-400 mt-1">ŸÑÿßÿπÿ® ŸÜÿ¥ÿ∑</div>
              </div>
              <div className="text-center p-4 bg-white/5 rounded-xl border border-white/10">
                <div className="text-2xl font-bold text-white">500+</div>
                <div className="text-sm text-gray-400 mt-1">ÿ™ÿ≠ÿØŸä ŸäŸàŸÖŸä</div>
              </div>
              <div className="text-center p-4 bg-white/5 rounded-xl border border-white/10">
                <div className="text-2xl font-bold text-white">99%</div>
                <div className="text-sm text-gray-400 mt-1">ÿ±ÿ∂ÿß ÿπŸÖŸÑÿßÿ°</div>
              </div>
            </div>
          </div>

          {/* Right Side - Registration Form */}
          <div className="lg:w-3/5">
            <div className="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-xl border border-white/20 rounded-3xl shadow-2xl overflow-hidden">
              {/* Form Header */}
              <div className="p-8 border-b border-white/10">
                <div className="flex items-center justify-between">
                  <div>
                    <h2 className="text-3xl font-bold text-white">ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ® ÿ¨ÿØŸäÿØ</h2>
                    <p className="text-gray-300 mt-2">ÿßŸÖŸÑÿ£ ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ ŸÑÿ®ÿØÿ° ÿ±ÿ≠ŸÑÿ™ŸÉ</p>
                  </div>
                  <div className="flex items-center gap-2 px-4 py-2 bg-white/10 rounded-full">
                    <div className="w-2 h-2 bg-green-400 rounded-full animate-pulse" />
                    <span className="text-sm text-gray-300">ŸÜÿ∏ÿßŸÖ ÿ¢ŸÖŸÜ</span>
                  </div>
                </div>
              </div>

              {/* Form Content */}
              <div className="p-8">
                {error && (
                  <Alert 
                    type="error" 
                    title="ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ" 
                    message={error} 
                    className="mb-6 animate-in slide-in-from-top duration-300"
                  />
                )}

                <form onSubmit={handleSubmit(onSubmit)} className="space-y-8">
                  {/* Personal Information */}
                  <div>
                    <div className="flex items-center gap-3 mb-6">
                      <div className="p-2 bg-blue-500/20 rounded-lg">
                        <User className="w-5 h-5 text-blue-400" />
                      </div>
                      <h3 className="text-xl font-semibold text-white">ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ¥ÿÆÿµŸäÿ©</h3>
                    </div>
                    
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                      <Input
                        label="ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑŸÉÿßŸÖŸÑ"
                        type="text"
                        placeholder="ÿ£ÿ≠ŸÖÿØ ŸÖÿ≠ŸÖÿØ"
                        error={errors.name?.message}
                        icon={<User className="w-5 h-5" />}
                        {...register('name')}
                        disabled={isLoading}
                      />

                      <Input
                        label="ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä"
                        type="email"
                        placeholder="ahmed@example.com"
                        error={errors.email?.message}
                        icon={<Mail className="w-5 h-5" />}
                        {...register('email')}
                        disabled={isLoading}
                      />

                      <Input
                        label="ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ"
                        type="tel"
                        placeholder="+20 100 000 0000"
                        error={errors.phoneNumber?.message}
                        icon={<Phone className="w-5 h-5" />}
                        {...register('phoneNumber')}
                        disabled={isLoading}
                      />

                      <Input
                        label="ÿßŸÑÿπŸÖÿ±"
                        type="number"
                        placeholder="25"
                        min="13"
                        max="100"
                        error={errors.age?.message}
                        icon={<Calendar className="w-5 h-5" />}
                        {...register('age', { valueAsNumber: true })}
                        disabled={isLoading}
                      />
                    </div>
                  </div>

                  {/* Password Section */}
                  <div>
                    <div className="flex items-center gap-3 mb-6">
                      <div className="p-2 bg-purple-500/20 rounded-lg">
                        <Lock className="w-5 h-5 text-purple-400" />
                      </div>
                      <h3 className="text-xl font-semibold text-white">ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±</h3>
                      <span className="text-sm text-gray-400">(ÿ≥Ÿäÿßÿ≥ÿ© ÿ®ÿ≥Ÿäÿ∑ÿ© - 6 ÿ£ÿ≠ÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ)</span>
                    </div>
                    
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                      <Input
                        label="ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±"
                        type="password"
                        placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                        error={errors.password?.message}
                        icon={<Lock className="w-5 h-5" />}
                        {...register('password')}
                        disabled={isLoading}
                      />

                      <Input
                        label="ÿ™ÿ£ŸÉŸäÿØ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±"
                        type="password"
                        placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                        error={errors.confirmPassword?.message}
                        icon={<Lock className="w-5 h-5" />}
                        {...register('confirmPassword')}
                        disabled={isLoading}
                      />
                    </div>

                    {/* Password Strength */}
                    {password && (
                      <div className="mt-6 p-5 bg-gradient-to-r from-white/5 to-white/0 rounded-xl border border-white/10">
                        <div className="flex items-center justify-between mb-4">
                          <div className="flex items-center gap-2">
                            <ShieldCheck className="w-5 h-5 text-white" />
                            <span className="text-white font-medium">ŸÇŸàÿ© ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±</span>
                          </div>
                          <span className={cn(
                            "text-sm font-semibold",
                            strengthColor === 'red' ? 'text-red-400' : 'text-green-400'
                          )}>
                            {strengthText}
                          </span>
                        </div>
                        
                        <div className="space-y-3">
                          <div className="h-2 bg-white/10 rounded-full overflow-hidden">
                            <div 
                              className={cn(
                                "h-full transition-all duration-500",
                                strengthColor === 'red' ? 'bg-red-500' : 'bg-green-500'
                              )}
                              style={{ width: `${strengthPercentage}%` }}
                            />
                          </div>
                          
                          <div className="grid grid-cols-2 gap-2">
                            {passwordChecks.map((check, index) => (
                              <div 
                                key={index}
                                className={cn(
                                  "flex items-center gap-2 text-xs p-2 rounded-lg transition-all duration-300",
                                  check.check 
                                    ? 'bg-green-500/20 text-green-300 border border-green-500/30' 
                                    : 'bg-red-500/10 text-red-300 border border-red-500/20'
                                )}
                              >
                                {check.check ? (
                                  <Check className="w-3 h-3 text-green-400" />
                                ) : (
                                  <X className="w-3 h-3 text-red-400" />
                                )}
                                <span>{check.label}</span>
                              </div>
                            ))}
                          </div>
                        </div>

                        {/* Password Match Check */}
                        {password && confirmPassword && (
                          <div className="mt-4 p-3 rounded-lg bg-white/5">
                            <div className={cn(
                              "flex items-center gap-2 text-sm",
                              password === confirmPassword 
                                ? 'text-green-400' 
                                : 'text-red-400'
                            )}>
                              {password === confirmPassword ? (
                                <Check className="w-4 h-4" />
                              ) : (
                                <X className="w-4 h-4" />
                              )}
                              <span>
                                {password === confirmPassword 
                                  ? 'ŸÉŸÑŸÖÿßÿ™ ÿßŸÑŸÖÿ±Ÿàÿ± ŸÖÿ™ÿ∑ÿßÿ®ŸÇÿ©' 
                                  : 'ŸÉŸÑŸÖÿßÿ™ ÿßŸÑŸÖÿ±Ÿàÿ± ÿ∫Ÿäÿ± ŸÖÿ™ÿ∑ÿßÿ®ŸÇÿ©'}
                              </span>
                            </div>
                          </div>
                        )}
                      </div>
                    )}
                  </div>

                  {/* Skill Level */}
                  <div>
                    <div className="flex items-center gap-3 mb-6">
                      <div className="p-2 bg-orange-500/20 rounded-lg">
                        <Star className="w-5 h-5 text-orange-400" />
                      </div>
                      <h3 className="text-xl font-semibold text-white">ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑŸÖŸáÿßÿ±ÿ©</h3>
                    </div>
                    
                    <div className="mb-4">
                      <p className="text-gray-300 text-sm">
                        ÿßÿÆÿ™ÿ± ŸÖÿ≥ÿ™ŸàŸâ ŸÖŸáÿßÿ±ÿ™ŸÉ ÿßŸÑÿ≠ÿßŸÑŸä ŸÑÿ™ŸÑÿßÿ¶ŸÖŸÉ ÿßŸÑÿ™ÿ≠ÿØŸäÿßÿ™ ÿßŸÑŸÖŸÜÿßÿ≥ÿ®ÿ©
                      </p>
                    </div>
                    
                    <div className="grid grid-cols-2 md:grid-cols-5 gap-3">
                      {skillLevels.map((level: any) => (
                        <button
                          type="button"
                          key={level.value}
                          onClick={() => {
                            setSkillLevel(level.value)
                            setValue('skillLevel', level.value)
                          }}
                          className={cn(
                            "relative flex flex-col items-center p-4 rounded-xl border-2 transition-all duration-300",
                            "transform hover:scale-105 active:scale-95",
                            skillLevel === level.value 
                              ? 'border-white shadow-lg scale-105 bg-gradient-to-br from-orange-500/30 to-orange-600/30' 
                              : 'border-white/20 bg-white/5 hover:bg-white/10 hover:border-white/30'
                          )}
                        >
                          <div className="text-2xl mb-2">{level.icon}</div>
                          <div className="text-sm font-semibold text-white">{level.label}</div>
                          <div className="text-xs text-white/70 mt-1">{level.desc}</div>
                        </button>
                      ))}
                    </div>
                    
                    {selectedSkill && skillLevel === selectedSkill.value && (
                      <div className="mt-4 p-4 bg-gradient-to-r from-white/5 to-white/0 rounded-xl border border-white/10">
                        <div className="flex items-center gap-3">
                          <div className="p-2 bg-white/10 rounded-lg">
                            <span className="text-xl">{selectedSkill.icon}</span>
                          </div>
                          <div>
                            <h4 className="text-white font-medium">ŸÖÿ≥ÿ™ŸàŸâ {selectedSkill.label}</h4>
                            <p className="text-gray-300 text-sm mt-1">
                              {selectedSkill.desc} - ÿ≥ÿ™ÿ™ŸÑŸÇŸâ ÿ™ÿ≠ÿØŸäÿßÿ™ ŸÖŸÜÿßÿ≥ÿ®ÿ© ŸÑŸÖÿ≥ÿ™ŸàÿßŸÉ
                            </p>
                          </div>
                        </div>
                      </div>
                    )}
                    
                    {errors.skillLevel?.message && (
                      <p className="text-sm text-red-400 mt-3">{errors.skillLevel.message}</p>
                    )}
                  </div>

                  {/* Description */}
                  <div>
                    <div className="flex items-center gap-3 mb-4">
                      <div className="p-2 bg-pink-500/20 rounded-lg">
                        <FileText className="w-5 h-5 text-pink-400" />
                      </div>
                      <div>
                        <h3 className="text-xl font-semibold text-white">ÿßŸÑŸàÿµŸÅ ÿßŸÑÿ¥ÿÆÿµŸä</h3>
                        <p className="text-gray-300 text-sm">(ÿßÿÆÿ™Ÿäÿßÿ±Ÿä) ÿ¥ÿßÿ±ŸÉŸÜÿß ÿ¥Ÿäÿ¶ÿßŸã ÿπŸÜ ŸÜŸÅÿ≥ŸÉ</p>
                      </div>
                    </div>
                    
                    <textarea
                      placeholder="ÿ£ÿÆÿ®ÿ±ŸÜÿß ÿπŸÜ ŸÜŸÅÿ≥ŸÉÿå ŸáŸàÿßŸäÿßÿ™ŸÉÿå ÿßŸáÿ™ŸÖÿßŸÖÿßÿ™ŸÉÿå ŸàŸÖŸáÿßÿ±ÿßÿ™ŸÉ ŸÅŸä ÿßŸÑÿ£ŸÑÿπÿßÿ®..."
                      rows={3}
                      maxLength={500}
                      {...register('description')}
                      disabled={isLoading}
                      className="w-full px-4 py-3 bg-white/5 border border-white/20 rounded-xl
                               text-white placeholder-gray-400 focus:outline-none 
                               focus:ring-2 focus:ring-blue-500 focus:border-transparent
                               transition-all resize-none"
                    />
                    <div className="flex justify-between items-center mt-2">
                      <div className="text-xs text-gray-400">
                        {description?.length || 0} / 500 ÿ≠ÿ±ŸÅ
                      </div>
                      <div className={cn(
                        "text-xs font-medium",
                        (description?.length || 0) >= 450 
                          ? 'text-orange-400 animate-pulse' 
                          : 'text-gray-400'
                      )}>
                        {description && description.length >= 450 && 'ÿßŸÇÿ™ÿ±ÿ®ÿ™ ŸÖŸÜ ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ'}
                      </div>
                    </div>
                  </div>

                  {/* Terms & Conditions */}
                  <div className="p-5 bg-gradient-to-r from-white/5 to-white/0 rounded-xl border border-white/10">
                    <div className="flex items-start gap-4">
                      <input
                        type="checkbox"
                        id="terms"
                        className="mt-1 w-5 h-5 rounded border-white/30 bg-white/10 
                                 text-blue-500 focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-900"
                        required
                      />
                      <div>
                        <label htmlFor="terms" className="text-gray-300 text-sm leading-relaxed">
                          ÿ£ŸÜÿß ÿ£ŸàÿßŸÅŸÇ ÿπŸÑŸâ ÿ¨ŸÖŸäÿπ{' '}
                          <Link 
                            href="/terms" 
                            className="text-blue-400 hover:text-blue-300 underline hover:no-underline font-medium"
                          >
                            ÿßŸÑÿ¥ÿ±Ÿàÿ∑ ŸàÿßŸÑÿ£ÿ≠ŸÉÿßŸÖ
                          </Link>{' '}
                          Ÿà{' '}
                          <Link 
                            href="/privacy" 
                            className="text-blue-400 hover:text-blue-300 underline hover:no-underline font-medium"
                          >
                            ÿ≥Ÿäÿßÿ≥ÿ© ÿßŸÑÿÆÿµŸàÿµŸäÿ©
                          </Link>{' '}
                          ÿßŸÑÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÖŸÜÿµÿ©. ÿ£ŸÇÿ± ÿ®ÿ£ŸÜ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ™Ÿä ŸÇÿØŸÖÿ™Ÿáÿß ÿµÿ≠Ÿäÿ≠ÿ© Ÿàÿ£ÿ™ÿ≠ŸÖŸÑ ÿßŸÑŸÖÿ≥ÿ§ŸàŸÑŸäÿ© ÿßŸÑŸÉÿßŸÖŸÑÿ© ÿπŸÜŸáÿß.
                        </label>
                      </div>
                    </div>
                  </div>

                  {/* Submit Button */}
                  <Button
                    type="submit"
                    className="w-full py-4 bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500
                             hover:from-blue-600 hover:via-purple-600 hover:to-pink-600 
                             text-white font-bold text-lg rounded-xl shadow-2xl
                             transform hover:-translate-y-1 active:translate-y-0
                             transition-all duration-300"
                    loading={isLoading}
                    disabled={isLoading}
                  >
                    {isLoading ? (
                      <span className="flex items-center justify-center gap-2">
                        <div className="w-5 h-5 border-2 border-white/30 border-t-white rounded-full animate-spin" />
                        ÿ¨ÿßÿ±Ÿä ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ≠ÿ≥ÿßÿ®...
                      </span>
                    ) : (
                      <span className="flex items-center justify-center gap-2">
                        <Sparkles className="w-5 h-5" />
                        ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ®Ÿä ŸàÿßŸÑÿ®ÿØÿ°
                      </span>
                    )}
                  </Button>
                </form>

                {/* Login Link */}
                <div className="mt-8 pt-6 border-t border-white/10">
                  <p className="text-center text-gray-300 text-sm">
                    ŸÑÿØŸäŸÉ ÿ≠ÿ≥ÿßÿ® ÿ®ÿßŸÑŸÅÿπŸÑÿü{' '}
                    <Link
                      href="/login"
                      className="font-bold text-blue-400 hover:text-blue-300 
                               underline hover:no-underline transition-all duration-300
                               hover:tracking-wider"
                    >
                      ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ
                    </Link>
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
//app/(auth)/login/page.tsx
import { Suspense } from 'react'
import LoginContent from './LoginContent'

export default function LoginPage() {
  return (
    <Suspense fallback={<LoginSkeleton />}>
      <LoginContent />
    </Suspense>
  )
}

function LoginSkeleton() {
  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-blue-900 to-indigo-900 flex items-center justify-center p-4">
      <div className="w-full max-w-md">
        <div className="text-center mb-8">
          <div className="inline-block p-4 bg-gradient-to-r from-blue-500 to-purple-500 rounded-2xl mb-4 animate-pulse">
            <div className="w-12 h-12"></div>
          </div>
          <h1 className="text-4xl font-bold text-white mb-2">ŸÖÿ±ÿ≠ÿ®ÿßŸã ÿ®ÿπŸàÿØÿ™ŸÉ!</h1>
          <p className="text-gray-300">ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ...</p>
        </div>
      </div>
    </div>
  )
}
//app/(auth)/login/loginContent.tsx
'use client'

import { useState } from 'react'
import Link from 'next/link'
import { useRouter, useSearchParams } from 'next/navigation'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { signIn } from 'next-auth/react'
import { loginSchema, type LoginInput } from '@/lib/infrastructure/auth/validators'
import { LogIn, Mail, Lock, Gamepad2 } from 'lucide-react'
import { FcGoogle } from 'react-icons/fc'
import Button from '@/components/ui/button'
import Input from '@/components/ui/input'
import Card from '@/components/ui/card'
import Alert from '@/components/ui/alert'
import toast from 'react-hot-toast'

export default function LoginContent() {
  const [isLoading, setIsLoading] = useState(false)
  const [googleLoading, setGoogleLoading] = useState(false)
  const [error, setError] = useState('')
  const router = useRouter()
  const searchParams = useSearchParams()
  
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginInput>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      email: '',
      password: ''
    }
  })

  const onSubmit = async (data: LoginInput) => {
    setIsLoading(true)
    setError('')
    
    try {
      const result = await signIn('credentials', {
        email: data.email,
        password: data.password,
        redirect: false,
      })

      if (result?.error) {
        toast.error(result.error)
        setError(result.error)
      } else if (result?.ok) {
        toast.success('ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ®ŸÜÿ¨ÿßÿ≠')
        router.push('/dashboard')
        router.refresh()
      }
    } catch (err: any) {
      toast.error(err.message || 'ŸÅÿ¥ŸÑ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ')
      setError(err.message || 'ŸÅÿ¥ŸÑ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ')
    } finally {
      setIsLoading(false)
    }
  }

  const handleGoogleSignIn = async () => {
    setGoogleLoading(true)
    setError('')
    
    try {
      const result = await signIn('google', {
        redirect: false,
        callbackUrl: '/dashboard'
      })
      
      if (result?.error) {
        toast.error(result.error)
        setError(result.error)
      } else if (result?.ok) {
        toast.success('ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ®ŸÜÿ¨ÿßÿ≠')
        router.push('/dashboard')
        router.refresh()
      }
    } catch (err: any) {
      toast.error(err.message || 'ŸÅÿ¥ŸÑ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ®ÿ¨Ÿàÿ¨ŸÑ')
      setError(err.message || 'ŸÅÿ¥ŸÑ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ®ÿ¨Ÿàÿ¨ŸÑ')
    } finally {
      setGoogleLoading(false)
    }
  }

  const redirect = searchParams.get('redirect')
  const registered = searchParams.get('registered')
  const accountError = searchParams.get('error')

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-blue-900 to-indigo-900 flex items-center justify-center p-4">
      <div className="w-full max-w-md">
        <div className="text-center mb-8">
          <div className="inline-block p-4 bg-gradient-to-r from-blue-500 to-purple-500 rounded-2xl mb-4">
            <Gamepad2 className="w-12 h-12 text-white" />
          </div>
          <h1 className="text-4xl font-bold text-white mb-2">ŸÖÿ±ÿ≠ÿ®ÿßŸã ÿ®ÿπŸàÿØÿ™ŸÉ!</h1>
          <p className="text-gray-300">ÿ≥ÿ¨ŸÑ ÿØÿÆŸàŸÑŸÉ Ÿàÿßÿ®ÿØÿ£ ÿ±ÿ≠ŸÑÿ™ŸÉ</p>
        </div>

        <Card className="p-8 bg-white/10 backdrop-blur-lg border border-white/20">
          {registered && (
            <Alert 
              type="success" 
              title="ÿ™ŸÖ ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ®ŸÜÿ¨ÿßÿ≠" 
              message="ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ®ŸÉÿå ŸäŸÖŸÉŸÜŸÉ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿßŸÑÿ¢ŸÜ" 
              className="mb-6"
            />
          )}

          {redirect && (
            <Alert 
              type="info" 
              title="ŸÖÿ∑ŸÑŸàÿ® ÿ™ÿ≥ÿ¨ŸäŸÑ ÿØÿÆŸàŸÑ" 
              message="Ÿäÿ¨ÿ® ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÑŸÑŸàÿµŸàŸÑ ÿ•ŸÑŸâ Ÿáÿ∞Ÿá ÿßŸÑÿµŸÅÿ≠ÿ©" 
              className="mb-6"
            />
          )}

          {accountError === 'account_inactive' && (
            <Alert 
              type="error" 
              title="ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿ∫Ÿäÿ± ŸÜÿ¥ÿ∑" 
              message="ÿ≠ÿ≥ÿßÿ®ŸÉ ÿ∫Ÿäÿ± ŸÜÿ¥ÿ∑ ÿ≠ÿßŸÑŸäÿßŸãÿå Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿØÿπŸÖ" 
              className="mb-6"
            />
          )}

          {error && (
            <Alert 
              type="error" 
              title="ŸÅÿ¥ŸÑ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ" 
              message={error} 
              className="mb-6"
            />
          )}

          <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
            <div className="relative">
              <div className="absolute right-3 top-3 text-gray-400">
                <Mail className="w-5 h-5" />
              </div>
              <Input
                label="ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä"
                type="email"
                placeholder="you@example.com"
                error={errors.email?.message}
                {...register('email')}
                disabled={isLoading || googleLoading}
                className="bg-white/5 border-white/20 text-white pr-10"
              />
            </div>

            <div className="relative">
              <div className="absolute right-3 top-3 text-gray-400">
                <Lock className="w-5 h-5" />
              </div>
              <Input
                label="ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±"
                type="password"
                placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                error={errors.password?.message}
                {...register('password')}
                disabled={isLoading || googleLoading}
                className="bg-white/5 border-white/20 text-white pr-10"
              />
            </div>

            <Button
              type="submit"
              className="w-full py-4 bg-gradient-to-r from-blue-500 to-purple-500
                       hover:from-blue-600 hover:to-purple-600 text-white font-semibold
                       rounded-xl shadow-lg hover:shadow-xl transition-all duration-300
                       flex items-center justify-center gap-2"
              loading={isLoading}
              disabled={isLoading || googleLoading}
            >
              {isLoading ? 'ÿ¨ÿßÿ±Ÿä ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ...' : (
                <>
                  <LogIn className="w-5 h-5" />
                  ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ
                </>
              )}
            </Button>
          </form>

          <div className="mt-6">
            <div className="relative">
              <div className="absolute inset-0 flex items-center">
                <div className="w-full border-t border-white/20"></div>
              </div>
              <div className="relative flex justify-center text-sm">
                <span className="px-2 bg-transparent text-gray-300">ÿ£Ÿà</span>
              </div>
            </div>

            <Button
              type="button"
              onClick={handleGoogleSignIn}
              className="w-full mt-6 py-4 bg-white text-gray-900 hover:bg-gray-100
                       border border-gray-300 rounded-xl shadow-md
                       flex items-center justify-center gap-2 transition-all duration-300"
              loading={googleLoading}
              disabled={isLoading || googleLoading}
            >
              {googleLoading ? 'ÿ¨ÿßÿ±Ÿä ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ...' : (
                <>
                  <FcGoogle className="w-5 h-5" />
                  ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ®ÿ¨Ÿàÿ¨ŸÑ
                </>
              )}
            </Button>
          </div>

          <div className="mt-8 pt-6 border-t border-white/20">
            <p className="text-center text-gray-300 text-sm mb-4">
              ŸÑŸäÿ≥ ŸÑÿØŸäŸÉ ÿ≠ÿ≥ÿßÿ®ÿü{' '}
              <Link
                href="/register"
                className="font-medium text-blue-400 hover:text-blue-300 underline"
              >
                ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ® ÿ¨ÿØŸäÿØ
              </Link>
            </p>
            <p className="text-center text-gray-300 text-sm">
              <Link
                href="/"
                className="font-medium text-blue-400 hover:text-blue-300 underline"
              >
                ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑÿµŸÅÿ≠ÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©
              </Link>
            </p>
          </div>
        </Card>
      </div>
    </div>
  )
}
//app/(dashboard)/page.tsx
import { redirect } from 'next/navigation'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'

export default async function DashboardPage() {
  const session = await getServerSession(authOptions)
  
  // ÿ•ÿ∞ÿß ŸÑŸÖ ŸäŸÉŸÜ ŸáŸÜÿßŸÉ sessionÿå ÿßÿ±ÿ¨ÿπ ŸÑŸÑÿµŸÅÿ≠ÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©
  // ÿßŸÑŸÄ middleware ÿ≥Ÿäÿ™ŸàŸÑŸâ ÿßŸÑÿ™Ÿàÿ¨ŸäŸá ÿ•ŸÑŸâ /login ÿ•ÿ∞ÿß ÿ≠ÿßŸàŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÖÿ®ÿßÿ¥ÿ±ÿ©
  if (!session) {
    redirect('/')
  }
  
  const userRole = session.user.role as 'PLAYER' | 'ADMIN' | 'OWNER' | 'EMPLOYEE'
  
  // ÿ™Ÿàÿ¨ŸäŸá ÿ≠ÿ≥ÿ® ÿßŸÑÿØŸàÿ±
  switch (userRole) {
    case 'PLAYER':
      redirect('/dashboard/player')
    case 'ADMIN':
      redirect('/dashboard/admin')
    case 'OWNER':
      redirect('/dashboard/owner')
    case 'EMPLOYEE':
      redirect('/dashboard/employee')
    default:
      redirect('/')
  }
}
//app/(dashboard)/layout.tsx
export default function PlayerLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <div className="min-h-screen bg-gray-50">
      {children}
    </div>
  )
}
//app/(dashboard)/(player)/page.tsx
'use client'

import { useState, useEffect } from 'react'
import { useSession } from 'next-auth/react'
import DaySelector from '@/components/booking/day-selector'
import SlotGrid from '@/components/booking/slot-grid'
import { Day } from '@/lib/core/types'

export default function PlayerDashboard() {
  const { data: session } = useSession()
  const [selectedDate, setSelectedDate] = useState<Date>(new Date())
  const [slots, setSlots] = useState<any[]>([])
  const [field, setField] = useState<any>(null)
  const [loading, setLoading] = useState(true)
  
  // ÿ•ŸÜÿ¥ÿßÿ° ÿ£ŸäÿßŸÖ ÿ®ÿßŸÑÿ¥ŸÉŸÑ ÿßŸÑŸÖÿ∑ŸÑŸàÿ® ŸÑŸÄ DaySelector
  const generateNextDays = (count: number): Day[] => {
    const days: Day[] = []
    const today = new Date()
    
    for (let i = 0; i < count; i++) {
      const date = new Date(today)
      date.setDate(today.getDate() + i)
      
      const dayOfWeek = date.getDay()
      const isWeekend = dayOfWeek === 5 || dayOfWeek === 6
      const isToday = i === 0
      const isTomorrow = i === 1
      
      // ÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ÿ®ÿßŸÑÿπÿ±ÿ®Ÿä
      const weekday = date.toLocaleDateString('ar-SA', { weekday: 'long' })
      const dayNumber = date.getDate().toString()
      const monthName = date.toLocaleDateString('ar-SA', { month: 'long' })
      
      const day: Day = {
        date: date.toISOString().split('T')[0],
        isWeekend,
        slotsAvailable: Math.floor(Math.random() * 10),
        slots: [],
        isToday,
        isTomorrow,
        weekday,
        dayNumber,
        monthName
      }
      
      days.push(day)
    }
    
    return days
  }
  
  const days = generateNextDays(10)

  useEffect(() => {
    fetchSlots()
  }, [selectedDate])

  const fetchSlots = async () => {
    try {
      setLoading(true)
      const fieldId = '1'
      
      const dateStr = selectedDate.toISOString().split('T')[0]
      const res = await fetch(`/api/fields/${fieldId}/slots?date=${dateStr}`)
      
      if (!res.ok) {
        throw new Error('Failed to fetch slots')
      }
      
      const data = await res.json()
      setSlots(data.slots || [])
      setField(data.field || null)
    } catch (error) {
      console.error('Error fetching slots:', error)
      setSlots([])
      setField(null)
    } finally {
      setLoading(false)
    }
  }

  const handleSelectDate = (date: Date) => {
    setSelectedDate(date)
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <header className="mb-8">
        <h1 className="text-3xl font-bold text-gray-900">ÿ≠ÿ¨ÿ≤ ÿßŸÑŸÖŸÑÿßÿπÿ®</h1>
        <p className="text-gray-600 mt-2">ÿßÿÆÿ™ÿ± ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖŸÜÿßÿ≥ÿ® Ÿàÿ≠ÿ¨ÿ≤ ŸÖŸÑÿßÿπÿ®ŸÉ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©</p>
      </header>

      <div className="bg-white rounded-2xl shadow-lg p-6">
        {field && (
          <div className="mb-6">
            <h2 className="text-2xl font-bold mb-2">{field.name}</h2>
            <p className="text-gray-600">{field.description}</p>
            <div className="flex items-center gap-4 mt-3">
              <span className="bg-green-100 text-green-800 px-3 py-1 rounded-full text-sm">
                {field.pricePerHour} ÿ¨.ŸÖ/ÿ≥ÿßÿπÿ©
              </span>
              <span className="text-gray-600">
                ŸÖŸàÿßÿπŸäÿØ ÿßŸÑÿπŸÖŸÑ: {field.openingTime} - {field.closingTime}
              </span>
            </div>
          </div>
        )}

        <DaySelector
          days={days}
          selectedDate={selectedDate}
          onSelectDate={handleSelectDate}
        />

        {loading ? (
          <div className="text-center py-12">
            <div className="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
            <p className="mt-4 text-gray-600">ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖŸàÿßÿπŸäÿØ...</p>
          </div>
        ) : (
          <SlotGrid
            slots={slots}
            fieldId={field?.id || ''}
            fieldName={field?.name || ''}
            userId={session?.user?.id}
          />
        )}
      </div>

      <div className="mt-8 grid grid-cols-1 md:grid-cols-3 gap-4">
        <div className="bg-white p-4 rounded-xl border">
          <h4 className="font-bold mb-2">üöÄ ÿ≠ÿ¨ÿ≤ ŸÅŸàÿ±Ÿä</h4>
          <p className="text-sm text-gray-600">ÿßÿ≠ÿ¨ÿ≤ ŸàÿßÿØŸÅÿπ ŸÖÿ®ÿßÿ¥ÿ±ÿ© ŸÑŸÑŸÖŸàÿßÿπŸäÿØ ÿ®ÿπÿØ 24 ÿ≥ÿßÿπÿ©</p>
        </div>
        
        <div className="bg-white p-4 rounded-xl border">
          <h4 className="font-bold mb-2">‚è∞ ÿ™ÿ£ŸÉŸäÿØ ŸäÿØŸàŸä</h4>
          <p className="text-sm text-gray-600">ÿßŸÑŸÖŸàÿßÿπŸäÿØ ÿßŸÑŸÇÿ±Ÿäÿ®ÿ© ÿ™ÿ≠ÿ™ÿßÿ¨ ÿ™ÿ£ŸÉŸäÿØ ŸÖŸÜ ÿßŸÑÿ•ÿØÿßÿ±ÿ©</p>
        </div>
        
        <div className="bg-white p-4 rounded-xl border">
          <h4 className="font-bold mb-2">üîí ŸÇŸÅŸÑ ÿ¢ŸÖŸÜ</h4>
          <p className="text-sm text-gray-600">ÿßŸÑŸÖŸàÿπÿØ Ÿäÿ®ŸÇŸâ ŸÖŸÇŸÅŸàŸÑ ŸÑŸÉ 5 ÿØŸÇÿßÿ¶ŸÇ ŸÑÿ•ÿ™ŸÖÿßŸÖ ÿßŸÑÿ≠ÿ¨ÿ≤</p>
        </div>
      </div>
    </div>
  )
}
// app/(dashboard)/(player)/layout.tsx
import { redirect } from 'next/navigation'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'

export default async function PlayerLayout({
  children,
}: {
  children: React.ReactNode
}) {
  const session = await getServerSession(authOptions)
  
  // ÿ•ÿ∞ÿß ŸÑŸÖ ŸäŸÉŸÜ ŸÖÿ≥ÿ¨ŸÑ
  if (!session?.user) {
    redirect('/login?redirect=/dashboard/player')
  }
  
  // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÖÿ≥ÿ¨ŸÑ ŸàŸÑŸÉŸÜ ŸÑŸäÿ≥ ŸÑÿßÿπÿ®
  if (session.user.role !== 'PLAYER') {
    redirect('/dashboard')
  }
  
  return <div className="min-h-screen bg-gray-50">{children}</div>
}
