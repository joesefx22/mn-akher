generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//////////////////// ENUMS ////////////////////

enum Role {
  PLAYER
  OWNER
  EMPLOYEE
  ADMIN
}

enum SkillLevel {
  WEAK
  AVERAGE
  GOOD
  EXCELLENT
  LEGENDARY
}

enum FieldType {
  FOOTBALL
  PADEL
}

enum FieldStatus {
  OPEN
  CLOSED
  MAINTENANCE
}

enum SlotStatus {
  AVAILABLE
  AVAILABLE_NEEDS_CONFIRM
  TEMP_LOCKED
  PENDING_CONFIRMATION
  BOOKED
  UNAVAILABLE // Ø£Ø¶ÙØªÙ‡ Ù„Ø­Ù„ Ù…Ø´ÙƒÙ„Ø© Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø©
}

enum BookingStatus {
  DRAFT
  PENDING_CONFIRMATION
  CONFIRMED
  CANCELLED
  FAILED
  EXPIRED
  PENDING_PAYMENT
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
  PARTIALLY_REFUNDED
  PROCESSING
}

enum NotificationType {
  SYSTEM
  BOOKING_UPDATE
  PAYMENT_UPDATE
  PAYMENT_SUCCESS // Ø£Ø¶ÙØªÙ‡ Ù„Ø­Ù„ Ù…Ø´ÙƒÙ„Ø© Ø§Ù„Ø£Ù†ÙˆØ§Ø¹
  PAYMENT_FAILED  // Ø£Ø¶ÙØªÙ‡ Ù„Ø­Ù„ Ù…Ø´ÙƒÙ„Ø© Ø§Ù„Ø£Ù†ÙˆØ§Ø¹
  GENERAL
  BOOKING_EXPIRED
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  REGISTER
}

//////////////////// USER ////////////////////

model User {
  id            String   @id @default(cuid())
  name          String
  email         String   @unique
  passwordHash  String?

  phone         String?  @unique
  phoneNumber   String?  @unique
  age           Int?
  avatar        String?
  description   String?
  skillLevel    SkillLevel @default(AVERAGE)

  role          Role @default(PLAYER)
  roleUpdatedAt DateTime?

  // ğŸ” Auth & Security
  isVerified    Boolean   @default(true)
  emailVerifiedAt DateTime?
  isActive      Boolean   @default(true)
  loginAttempts Int       @default(0)
  lockedUntil   DateTime?
  lastLogin     DateTime?

  // ğŸ”— Relations
  bookings        Booking[]
  slotsLocked     Slot[] @relation("SlotLockedByUser")
  notifications   Notification[]
  reviews         Review[]
  flags           FlaggedUser[]
  auditLogs       AuditLog[]
  idempotencyKeys IdempotencyKey[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
  @@index([role])
  @@index([isActive, isVerified])
}

//////////////////// FIELD ////////////////////

model Field {
  id          String @id @default(cuid())
  name        String
  description String?
  location    String
  address     String?

  type        FieldType
  imageUrl    String?
  gallery     String[]

  pricePerHour    Float
  depositPrice    Float
  openingTime     DateTime
  closingTime     DateTime
  slotDurationMin Int @default(60)

  status     FieldStatus @default(OPEN)
  facilities String[]

  slots    Slot[]
  bookings Booking[]
  reviews  Review[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

//////////////////// REVIEW ////////////////////

model Review {
  id        String   @id @default(cuid())
  fieldId   String
  field     Field    @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  rating    Int      @default(5)
  comment   String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([fieldId, userId])
  @@index([fieldId])
  @@index([userId])
}

//////////////////// SLOT ////////////////////

model Slot {
  id      String @id @default(cuid())
  fieldId String
  field   Field  @relation(fields: [fieldId], references: [id], onDelete: Cascade)

  startTime DateTime
  endTime   DateTime

  durationMinutes Int @default(60)
  price           Float
  deposit         Float

  status      SlotStatus @default(AVAILABLE)
  lockedUntil DateTime?

  lockedByUserId String?
  lockedByUser   User? @relation("SlotLockedByUser", fields: [lockedByUserId], references: [id], onDelete: SetNull)

  bookings Booking[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([fieldId, startTime])
  @@index([status, lockedUntil])
}

//////////////////// BOOKING ////////////////////

model Booking {
  id String @id @default(cuid())

  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  fieldId String
  field   Field @relation(fields: [fieldId], references: [id], onDelete: Cascade)

  slotId String
  slot   Slot @relation(fields: [slotId], references: [id], onDelete: Cascade)

  status        BookingStatus @default(DRAFT)
  paymentStatus PaymentStatus @default(PENDING)

  totalAmount Float
  depositPaid Float @default(0)

  refundableUntil DateTime?
  expiresAt       DateTime?

  paymentId String?
  orderId   String?

  idempotencyKey String? @unique

  payments      Payment[]
  notifications Notification[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, status])
  @@index([slotId])
  @@index([orderId])
}

//////////////////// PAYMENT ////////////////////

model Payment {
  id String @id @default(cuid())

  bookingId String
  booking   Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  amount   Float
  currency String @default("EGP")

  paymentId String? @unique
  orderId   String? @unique

  status   PaymentStatus @default(PENDING)
  metadata Json?

  refundedAmount Float @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([bookingId])
  @@index([orderId])
}

//////////////////// NOTIFICATION ////////////////////

model Notification {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  bookingId String?
  booking   Booking? @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  relatedId String?  // Ø£Ø¶ÙØªÙ‡ Ù„Ø­Ù„ Ù…Ø´ÙƒÙ„Ø© relatedId

  type    NotificationType
  title   String
  message String
  data    Json?

  isRead Boolean @default(false)

  createdAt DateTime @default(now())

  @@index([userId, isRead])
  @@index([relatedId])
}

//////////////////// IDEMPOTENCY ////////////////////

model IdempotencyKey {
  id          String   @id @default(cuid())
  key         String
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  requestHash String
  method      String
  response    Json?
  expiresAt   DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([key, userId])
}

//////////////////// FLAGGED USERS ////////////////////

model FlaggedUser {
  id     String @id @default(cuid())
  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  reason    String
  severity  String @default("MEDIUM")
  expiresAt DateTime?

  createdAt DateTime @default(now())
}

//////////////////// AUDIT LOG ////////////////////

model AuditLog {
  id String @id @default(cuid())

  userId String?
  user   User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  action     AuditAction
  entityType String?
  entityId   String?
  oldValue   Json?
  newValue   Json?
  ipAddress  String?
  userAgent  String?

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([action])
}
// lib/shared/utils/index.ts

export const ROLES = {
  PLAYER: 'PLAYER',
  OWNER: 'OWNER',
  EMPLOYEE: 'EMPLOYEE',
  ADMIN: 'ADMIN'
} as const

export const TOKEN_TYPES = {
  EMAIL_VERIFICATION: 'EMAIL_VERIFICATION',
  PASSWORD_RESET: 'PASSWORD_RESET',
  REFRESH_TOKEN: 'REFRESH_TOKEN'
} as const

export const AUDIT_ACTIONS = {
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT',
  REGISTER: 'REGISTER',
  UPDATE_PROFILE: 'UPDATE_PROFILE',
  CHANGE_PASSWORD: 'CHANGE_PASSWORD',
  VERIFY_EMAIL: 'VERIFY_EMAIL',
  RESET_PASSWORD: 'RESET_PASSWORD',
  DELETE_ACCOUNT: 'DELETE_ACCOUNT'
} as const

export const ERROR_CODES = {
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  AUTHENTICATION_ERROR: 'AUTHENTICATION_ERROR',
  AUTHORIZATION_ERROR: 'AUTHORIZATION_ERROR',
  NOT_FOUND: 'NOT_FOUND',
  CONFLICT: 'CONFLICT',
  RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',
  TOKEN_EXPIRED: 'TOKEN_EXPIRED',
  INVALID_TOKEN: 'INVALID_TOKEN',
  SERVER_ERROR: 'SERVER_ERROR'
} as const

export const PASSWORD_POLICY = {
  MIN_LENGTH: 8,
  REQUIRE_UPPERCASE: true,
  REQUIRE_LOWERCASE: true,
  REQUIRE_NUMBER: true,
  REQUIRE_SPECIAL_CHAR: true
} as const

export const RATE_LIMITS = {
  LOGIN: {
    WINDOW_MS: 15 * 60 * 1000, // 15 minutes
    MAX_ATTEMPTS: 5
  },
  REGISTER: {
    WINDOW_MS: 60 * 60 * 1000, // 1 hour
    MAX_ATTEMPTS: 3
  },
  FORGOT_PASSWORD: {
    WINDOW_MS: 60 * 60 * 1000, // 1 hour
    MAX_ATTEMPTS: 3
  }
} as const

// âœ… Ø£Ø¶Ù Ø§Ù„Ù€ cn Ù‡Ù†Ø§
export function cn(...classes: (string | undefined | null | false)[]) {
  return classes.filter(Boolean).join(" ");
}

// lib/shared/rate-limit/index.ts
export class RateLimitService {
  private requests = new Map<string, { count: number; resetTime: number }>();

  check(key: string, limit: number, windowMs: number): boolean {
    const now = Date.now();
    const record = this.requests.get(key);

    if (!record || now > record.resetTime) {
      // New window
      this.requests.set(key, {
        count: 1,
        resetTime: now + windowMs
      });
      return true;
    }

    if (record.count >= limit) {
      return false;
    }

    record.count++;
    return true;
  }
}

export const rateLimitService = new RateLimitService();

// lib/shared/logger/index.ts
import winston from 'winston'

export const logger = winston.createLogger({
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ 
      filename: 'logs/error.log', 
      level: 'error' 
    }),
    new winston.transports.File({ 
      filename: 'logs/combined.log' 
    }),
  ],
})

// Loggers Ù…ØªØ®ØµØµØ©
export const authLogger = logger.child({ module: 'auth' })
export const bookingLogger = logger.child({ module: 'booking' })
export const paymentLogger = logger.child({ module: 'payment' })
export const apiLogger = logger.child({ module: 'api' })
export const cronLogger = logger.child({ module: 'cron' })

// lib/shared/helpers/index.ts
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function formatDate(date: Date | string): string {
  const d = new Date(date)
  return d.toLocaleDateString('ar-EG', { // ØºÙŠØ±ØªÙ‡Ø§ Ù„Ù€ ar-EG
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  })
}

export function formatRole(role: string): string {
  const roleMap: Record<string, string> = {
    PLAYER: 'ğŸ® Ù„Ø§Ø¹Ø¨',
    OWNER: 'ğŸŸï¸ Ù…Ø§Ù„Ùƒ Ù…Ù„Ø¹Ø¨',
    EMPLOYEE: 'ğŸ‘¨â€ğŸ’¼ Ù…ÙˆØ¸Ù',
    ADMIN: 'ğŸ›¡ï¸ Ù…Ø¯ÙŠØ±'
  }
  return roleMap[role] || role
}

export function formatSkillLevel(skillLevel: string): string {
  const skillMap: Record<string, string> = {
    WEAK: 'Ø¶Ø¹ÙŠÙ ğŸ˜…',
    AVERAGE: 'Ù…ØªÙˆØ³Ø· ğŸ˜Š',
    GOOD: 'Ø¬ÙŠØ¯ ğŸ˜',
    EXCELLENT: 'Ù…Ù…ØªØ§Ø² ğŸ”¥',
    LEGENDARY: 'Ø£Ø³Ø·ÙˆØ±ÙŠ ğŸ‘‘'
  }
  return skillMap[skillLevel] || skillLevel
}

export function truncateText(text: string, maxLength: number = 50): string {
  if (text.length <= maxLength) return text
  return text.substring(0, maxLength) + '...'
}

export function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  return emailRegex.test(email)
}

export function isValidPhone(phone: string): boolean {
  // Ø¯Ø¹Ù… Ù„Ù„Ø±Ù‚Ù… Ø§Ù„Ù…ØµØ±ÙŠ ÙˆØ§Ù„Ø¹Ø±Ø¨ÙŠ
  const phoneRegex = /^(\+?\d{1,3}[-.\s]?)?\(?\d{1,4}\)?[-.\s]?\d{1,4}[-.\s]?\d{1,9}$/
  return phoneRegex.test(phone.replace(/\s/g, ''))
}

export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout
  
  return (...args: Parameters<T>) => {
    clearTimeout(timeout)
    timeout = setTimeout(() => func(...args), wait)
  }
}

export function generateRandomId(length: number = 8): string {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'
  let result = ''
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length))
  }
  return result
}

export function getGradientColor(level: string): string {
  const gradientMap: Record<string, string> = {
    WEAK: 'from-gray-400 to-gray-500',
    AVERAGE: 'from-blue-400 to-blue-500',
    GOOD: 'from-green-400 to-green-500',
    EXCELLENT: 'from-purple-400 to-purple-500',
    LEGENDARY: 'from-orange-400 to-orange-500'
  }
  return gradientMap[level] || 'from-gray-400 to-gray-500'
}

export function calculateAge(birthYear: number): number {
  const currentYear = new Date().getFullYear()
  return currentYear - birthYear
}

export function getInitials(name: string): string {
  return name
    .split(' ')
    .map(word => word.charAt(0))
    .join('')
    .toUpperCase()
    .slice(0, 2)
}

export function formatNumber(num: number): string {
  if (num >= 1000000) {
    return (num / 1000000).toFixed(1) + ' Ù…Ù„ÙŠÙˆÙ†'
  }
  if (num >= 1000) {
    return (num / 1000).toFixed(1) + ' Ø£Ù„Ù'
  }
  return num.toString()
}

export function formatCurrency(amount: number): string {
  return amount.toLocaleString('ar-EG') + ' Ø¬.Ù…'
}

export function getTimeAgo(date: Date | string): string {
  const now = new Date()
  const past = new Date(date)
  const diffMs = now.getTime() - past.getTime()
  const diffMins = Math.floor(diffMs / 60000)
  const diffHours = Math.floor(diffMs / 3600000)
  const diffDays = Math.floor(diffMs / 86400000)

  if (diffMins < 1) return 'Ø§Ù„Ø¢Ù†'
  if (diffMins < 60) return `Ù‚Ø¨Ù„ ${diffMins} Ø¯Ù‚ÙŠÙ‚Ø©`
  if (diffHours < 24) return `Ù‚Ø¨Ù„ ${diffHours} Ø³Ø§Ø¹Ø©`
  if (diffDays < 30) return `Ù‚Ø¨Ù„ ${diffDays} ÙŠÙˆÙ…`
  if (diffDays < 365) return `Ù‚Ø¨Ù„ ${Math.floor(diffDays / 30)} Ø´Ù‡Ø±`
  return `Ù‚Ø¨Ù„ ${Math.floor(diffDays / 365)} Ø³Ù†Ø©`
}

// Ø­Ø°Ù import cn Ù…Ù† Ø§Ù„Ø¢Ø®Ø± Ù„Ø£Ù†Ù‡Ø§ Ù…ÙƒØ±Ø±Ø©

// lib/shared/helpers/api-auth.ts
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'

/**
 * =========================
 * Custom Auth Errors
 * =========================
 */

export class AuthError extends Error {
  status: number
  code: string

  constructor(
    message: string = 'ØºÙŠØ± Ù…ØµØ±Ø­',
    status: number = 401,
    code: string = 'UNAUTHORIZED'
  ) {
    super(message)
    this.name = 'AuthError'
    this.status = status
    this.code = code
  }
}

export class PermissionError extends Error {
  status = 403
  code = 'FORBIDDEN'

  constructor(message: string = 'ØµÙ„Ø§Ø­ÙŠØ© ØºÙŠØ± ÙƒØ§ÙÙŠØ©') {
    super(message)
    this.name = 'PermissionError'
  }
}

export class AccountError extends Error {
  status = 403
  code = 'ACCOUNT_INACTIVE'

  constructor(message: string = 'Ø§Ù„Ø­Ø³Ø§Ø¨ ØºÙŠØ± Ù†Ø´Ø·') {
    super(message)
    this.name = 'AccountError'
  }
}

/**
 * =========================
 * Core Guards
 * =========================
 */

// Ù„Ø§Ø²Ù… ÙŠÙƒÙˆÙ† Ø¹Ø§Ù…Ù„ Login
export async function requireAuth() {
  const session = await getServerSession(authOptions)

  if (!session) {
    throw new AuthError()
  }

  return session
}

// Ù„Ø§Ø²Ù… ÙŠÙƒÙˆÙ† Role Ù…Ø¹ÙŠÙ†
export function requireRole(
  session: Awaited<ReturnType<typeof requireAuth>>,
  allowedRoles: string[]
) {
  if (!allowedRoles.includes(session.user.role)) {
    throw new PermissionError()
  }
}

// Ø§Ù„Ø­Ø³Ø§Ø¨ Ù„Ø§Ø²Ù… ÙŠÙƒÙˆÙ† Active
export function requireActiveAccount(
  session: Awaited<ReturnType<typeof requireAuth>>
) {
  if (session.user.isActive === false) {
    throw new AccountError()
  }
}

/**
 * =========================
 * Optional helper (API only)
 * =========================
 */

export async function getSessionForAPI() {
  return getServerSession(authOptions)
}


// lib/shared/env/startup-check.ts
import { ENV } from './env'
import { logger } from '@/lib/shared/logger'  // âœ… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯
import { prisma } from '@/lib/infrastructure/database/prisma'  // âœ… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯

export async function startupCheck(): Promise<void> {
  logger.info('Starting application...')
  
  const checks = [
    { name: 'Environment', check: checkEnvironment },
    { name: 'Database', check: checkDatabase },
    { name: 'Paymob Config', check: checkPaymob },
  ]
  
  const results = await Promise.allSettled(
    checks.map(async ({ name, check }) => {
      try {
        await check()
        return { name, status: 'âœ…' }
      } catch (error: any) {
        return { name, status: 'âŒ', error: error.message }
      }
    })
  )
  
  console.log('\nğŸ“Š Startup Check Results:')
  console.log('========================')
  
  results.forEach(result => {
    if (result.status === 'fulfilled') {
      const value = result.value
      if (value.error) {
        console.log(`${value.status} ${value.name}: ${value.error}`)
      } else {
        console.log(`${value.status} ${value.name}`)
      }
    } else {
      console.log(`âŒ Check failed`)
    }
  })
  
  console.log('========================\n')
  
  // Warn if not production ready
  if (ENV.NODE_ENV === 'production') {
    const missingForProduction = []
    
    if (!ENV.PAYMOB_API_KEY) missingForProduction.push('PAYMOB_API_KEY')
    if (!ENV.PAYMOB_HMAC_SECRET) missingForProduction.push('PAYMOB_HMAC_SECRET')
    if (!ENV.PAYMOB_INTEGRATION_ID) missingForProduction.push('PAYMOB_INTEGRATION_ID')
    
    if (missingForProduction.length > 0) {
      logger.warn('âš ï¸  Missing production configuration:', { missing: missingForProduction })
    }
  }
  
  logger.info('Startup check completed')
}

async function checkEnvironment(): Promise<void> {
  const required = ['NODE_ENV', 'DATABASE_URL', 'NEXTAUTH_URL']
  const missing = required.filter(key => !process.env[key])
  
  if (missing.length > 0) {
    throw new Error(`Missing environment variables: ${missing.join(', ')}`)
  }
}

async function checkDatabase(): Promise<void> {
  try {
    await prisma.$queryRaw`SELECT 1`
    logger.info('Database connection successful')
  } catch (error: any) {
    throw new Error(`Database connection failed: ${error.message}`)
  }
}

async function checkPaymob(): Promise<void> {
  if (ENV.NODE_ENV === 'production') {
    const required = ['PAYMOB_API_KEY', 'PAYMOB_HMAC_SECRET', 'PAYMOB_INTEGRATION_ID']
    const missing = required.filter(key => !ENV[key as keyof typeof ENV])
    
    if (missing.length > 0) {
      throw new Error(`Missing Paymob configuration: ${missing.join(', ')}`)
    }
    logger.info('Paymob configuration is ready for production')
  } else {
    logger.info('Paymob configuration check skipped (development)')
  }
}

import { z } from 'zod'

const envSchema = z.object({
  // === Database ===
  DATABASE_URL: z.string()
    .url()
    .refine(url => url.startsWith('postgresql://'), {
      message: 'DATABASE_URL must start with postgresql://'
    }),
  
  // === NextAuth ===
  NEXTAUTH_URL: z.string().url(),
  NEXTAUTH_SECRET: z.string()
    .min(32, 'NEXTAUTH_SECRET must be at least 32 characters'),
  
  // === Paymob ===
  PAYMOB_API_KEY: z.string().min(1),
  PAYMOB_HMAC_SECRET: z.string().min(1),
  PAYMOB_INTEGRATION_ID: z.string().min(1),
  PAYMOB_IFRAME_ID: z.string().default('default'),
  
  // === Cron ===
  CRON_SECRET: z.string()
    .min(32, 'CRON_SECRET must be at least 32 characters')
    .default('dev-cron-secret-change-in-production'),
  
  // === App ===
  APP_URL: z.string().url().default('http://localhost:3000'),
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  
  // === Logging ===
  LOG_LEVEL: z.enum(['debug', 'info', 'warn', 'error'])
    .default('info'),
  
  // === Email (Optional) ===
  RESEND_API_KEY: z.string().optional(),
  EMAIL_FROM: z.string().email().optional(),
  
  // === Google OAuth (Optional) ===
  GOOGLE_CLIENT_ID: z.string().optional(),
  GOOGLE_CLIENT_SECRET: z.string().optional(),
})

// Validate env
const env = envSchema.safeParse(process.env)

if (!env.success) {
  console.error('âŒ Invalid environment variables:', env.error.flatten().fieldErrors)
  
  // ÙÙŠ development Ù†Ø¹Ø·ÙŠ defaults Ù„Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
  if (process.env.NODE_ENV === 'production') {
    throw new Error('Invalid environment variables')
  }
  
  console.warn('âš ï¸  Running with default environment variables for development')
}

export const ENV = env.success ? env.data : {
  // Defaults for development
  NODE_ENV: 'development' as const,
  DATABASE_URL: process.env.DATABASE_URL || 'postgresql://localhost:5432/ihgezly',
  NEXTAUTH_URL: process.env.NEXTAUTH_URL || 'http://localhost:3000',
  NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET || 'dev-secret-change-in-production-32-chars-min',
  APP_URL: process.env.APP_URL || 'http://localhost:3000',
  CRON_SECRET: process.env.CRON_SECRET || 'dev-cron-secret-change-in-production',
  LOG_LEVEL: 'debug' as const,
  PAYMOB_API_KEY: process.env.PAYMOB_API_KEY || 'mock_api_key',
  PAYMOB_HMAC_SECRET: process.env.PAYMOB_HMAC_SECRET || 'mock_hmac_secret',
  PAYMOB_INTEGRATION_ID: process.env.PAYMOB_INTEGRATION_ID || 'mock_integration_id',
  PAYMOB_IFRAME_ID: process.env.PAYMOB_IFRAME_ID || 'default'
}
// lib/shared/context/request-context.ts
import { NextRequest, NextResponse } from 'next/server'
import { v4 as uuidv4 } from 'uuid'
import { getServerSession } from 'next-auth'
import { AsyncLocalStorage } from 'async_hooks'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'
import { logger } from '@/lib/shared/logger'

export class RequestContext {
  private static storage = new AsyncLocalStorage<Map<string, any>>()

  static get<T>(key: string): T | undefined {
    return this.storage.getStore()?.get(key)
  }

  static set(key: string, value: any): void {
    const store = this.storage.getStore()
    if (store) {
      store.set(key, value)
    }
  }

  // âœ… Ø®Ù„ÙŠÙ‡Ø§ generic Ø¹Ù„Ø´Ø§Ù† ØªØ±Ø¬Ø¹ Ù†ÙØ³ Ù†ÙˆØ¹ callback
  static run<T>(context: Map<string, any>, callback: () => T): T {
    return this.storage.run(context, callback)
  }

  static getRequestId(): string {
    return this.get('requestId') || 'unknown'
  }

  static getUserId(): string | undefined {
    return this.get('userId')
  }

  static getSessionId(): string | undefined {
    return this.get('sessionId')
  }
}

// Middleware Ù„Ø¥Ø¶Ø§ÙØ© Context
export function withRequestContext(
  handler: (req: NextRequest) => Promise<NextResponse>
) {
  return async (req: NextRequest): Promise<NextResponse> => {
    const context = new Map<string, any>()
    
    const requestId = uuidv4()
    context.set('requestId', requestId)
    
    try {
      const session = await getServerSession(authOptions)
      if (session?.user) {
        const user = session.user as any
        if (user.id) {
          context.set('userId', user.id)
        }
        // âŒ session.id Ù…Ø´ Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ
        // Ù„Ùˆ Ù…Ø­ØªØ§Ø¬ sessionIdØŒ Ø¶ÙŠÙÙ‡ Ø¨Ù†ÙØ³Ùƒ ÙÙŠ JWT/session callback
      }
    } catch (error) {
      logger.warn('Failed to get session in request context', { error })
    }
    
    context.set('userAgent', req.headers.get('user-agent'))
    context.set('ip', req.headers.get('x-forwarded-for') || req.headers.get('x-real-ip') || 'unknown')
    context.set('path', req.nextUrl.pathname)
    context.set('method', req.method)
    
    return RequestContext.run(context, async () => {
      logger.info('Request started', {
        requestId,
        method: req.method,
        path: req.nextUrl.pathname,
        userId: RequestContext.getUserId()
      })
      
      const startTime = Date.now()
      
      try {
        const response = await handler(req)
        
        const duration = Date.now() - startTime
        logger.info('Request completed', {
          requestId,
          durationMs: duration,
          status: response.status,
          path: req.nextUrl.pathname,
          userId: RequestContext.getUserId()
        })
        
        response.headers.set('X-Request-ID', requestId)
        return response
      } catch (error) {
        const duration = Date.now() - startTime
        logger.error('Request failed', {
          requestId,
          durationMs: duration,
          path: req.nextUrl.pathname,
          userId: RequestContext.getUserId(),
          error: error instanceof Error ? error.message : String(error)
        })
        
        throw error
      }
    })
  }
}

// lib/shared/constants/index.ts

// === Ø­Ø§Ù„Ø© Ø§Ù„Ø³Ù„Ø§Øª (Slots) ===
export const SLOT_STATUS = {
  AVAILABLE: 'AVAILABLE',
  TEMP_LOCKED: 'TEMP_LOCKED',
  BOOKED: 'BOOKED',
  UNAVAILABLE: 'UNAVAILABLE',
  AVAILABLE_NEEDS_CONFIRM: 'AVAILABLE_NEEDS_CONFIRM'
} as const

// === Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª (Bookings) ===
export const BOOKING_STATUS = {
  DRAFT: 'DRAFT',
  PENDING_PAYMENT: 'PENDING_PAYMENT',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED',
  FAILED: 'FAILED',
  EXPIRED: 'EXPIRED'
} as const

// === Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª (Payments) ===
export const PAYMENT_STATUS = {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  PAID: 'PAID',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED',
  PARTIALLY_REFUNDED: 'PARTIALLY_REFUNDED'
} as const

// === Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ù„Ø§Ø¹Ø¨ (Fields) ===
export const FIELD_STATUS = {
  OPEN: 'OPEN',
  CLOSED: 'CLOSED',
  MAINTENANCE: 'MAINTENANCE'
} as const

// === Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ù…Ù„Ø§Ø¹Ø¨ ===
export const FIELD_TYPES = {
  FOOTBALL: 'FOOTBALL',
  PADEL: 'PADEL',
  TENNIS: 'TENNIS',
  BASKETBALL: 'BASKETBALL'
} as const

// === Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª ===
export const NOTIFICATION_TYPE = {
  PAYMENT_SUCCESS: 'PAYMENT_SUCCESS',
  PAYMENT_FAILED: 'PAYMENT_FAILED',
  BOOKING_CONFIRMED: 'BOOKING_CONFIRMED',
  SLOT_REMINDER: 'SLOT_REMINDER'
} as const

// === Ø£Ø¯ÙˆØ§Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† (User Roles) ===
export const USER_ROLES = {
  ADMIN: 'ADMIN',
  PLAYER: 'PLAYER',
  OWNER: 'OWNER',
  EMPLOYEE: 'EMPLOYEE'
} as const

// === Ù…Ù‡Ø§Ø±Ø§Øª Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† ===
export const SKILL_LEVELS = {
  WEAK: 'WEAK',
  AVERAGE: 'AVERAGE',
  GOOD: 'GOOD',
  EXCELLENT: 'EXCELLENT',
  LEGENDARY: 'LEGENDARY'
} as const

// === Ø£Ù†ÙˆØ§Ø¹ Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ÙÙŠ TypeScript ===
export type SlotStatus = typeof SLOT_STATUS[keyof typeof SLOT_STATUS]
export type BookingStatus = typeof BOOKING_STATUS[keyof typeof BOOKING_STATUS]
export type PaymentStatus = typeof PAYMENT_STATUS[keyof typeof PAYMENT_STATUS]
export type FieldStatus = typeof FIELD_STATUS[keyof typeof FIELD_STATUS]
export type FieldType = typeof FIELD_TYPES[keyof typeof FIELD_TYPES]
export type NotificationType = typeof NOTIFICATION_TYPE[keyof typeof NOTIFICATION_TYPE]
export type UserRole = typeof USER_ROLES[keyof typeof USER_ROLES]
export type SkillLevel = typeof SKILL_LEVELS[keyof typeof SKILL_LEVELS]

// lib/shared/api/api-error-handler.ts
import { NextResponse } from 'next/server'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { ERROR_CODES } from '@/lib/core/errors/error-codes'

export function apiErrorHandler(error: unknown): NextResponse {
  console.error('API Error:', error)

  // Handle DomainError
  if (error instanceof DomainError) {
    const status = getHttpStatus(error.code)
    return NextResponse.json(
      {
        error: true,
        code: ERROR_CODES[error.code],
        message: error.message,
        details: error.details
      },
      { status }
    )
  }

  // Handle Zod validation errors
  if (error instanceof Error && error.name === 'ZodError') {
    return NextResponse.json(
      {
        error: true,
        code: 'VALIDATION_ERROR',
        message: 'Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ§Ù„Ø­Ø©',
        details: error.message
      },
      { status: 400 }
    )
  }

  // Handle Prisma errors
  if (error instanceof Error && error.name.includes('Prisma')) {
    return NextResponse.json(
      {
        error: true,
        code: 'DATABASE_ERROR',
        message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª'
      },
      { status: 500 }
    )
  }

  // Default error
  return NextResponse.json(
    {
      error: true,
      code: 'INTERNAL_SERVER_ERROR',
      message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹'
    },
    { status: 500 }
  )
}

function getHttpStatus(errorCode: keyof typeof ERROR_CODES): number {
  const code = ERROR_CODES[errorCode]
  
  if (code.startsWith('AUTH')) return 401
  if (code.startsWith('VAL')) return 400
  if (code.startsWith('SLOT') || code.startsWith('BOOK') || code.startsWith('PAY')) return 400
  if (code.startsWith('FIELD')) return 404
  return 500
}

// lib/infrastructure/security/password.ts
import bcrypt from 'bcryptjs'

export async function hashPassword(password: string): Promise<string> {
  const salt = await bcrypt.genSalt(12)
  return bcrypt.hash(password, salt)
}

export async function comparePassword(
  rawPassword: string, 
  hashedPassword: string
): Promise<boolean> {
  if (!hashedPassword) return false
  return bcrypt.compare(rawPassword, hashedPassword)
}

// lib/infrastructure/payments/providers/index.ts
export { paymobService } from './paymob'
export { paymobHmacVerifier } from './hmac-verifier'

// Re-export types
export type {
  PaymobOrder,
  PaymobPaymentKey,
  PaymobBillingData
} from './paymob'

// lib/infrastructure/payments/providers/hmac-verifier.ts
import crypto from 'crypto'
import { ENV } from '@/lib/shared/env/env'
import { paymentLogger } from '@/lib/shared/logger'

export class PaymobHmacVerifier {
  private readonly hmacSecret: string

  constructor() {
    this.hmacSecret = ENV.PAYMOB_HMAC_SECRET || ''
  }

  verify(data: any, receivedHmac: string): boolean {
    try {
      const orderedData = this.orderData(data)
      const dataString = JSON.stringify(orderedData)
      
      const calculatedHmac = crypto
        .createHmac('sha512', this.hmacSecret)
        .update(dataString)
        .digest('hex')
      
      const isValid = crypto.timingSafeEqual(
        Buffer.from(calculatedHmac, 'hex'),
        Buffer.from(receivedHmac, 'hex')
      )

      paymentLogger.info('HMAC verification completed', { 
        isValid,
        orderId: data.order?.id 
      })
      
      return isValid
    } catch (error: any) {
      paymentLogger.error('HMAC verification error', error)
      return false
    }
  }

  isFresh(timestamp: number, maxAgeSeconds: number = 300): boolean {
    const now = Math.floor(Date.now() / 1000)
    const age = now - timestamp
    return age <= maxAgeSeconds && age >= 0
  }

  private orderData(data: any): any {
    const ordered: any = {}
    
    const fields = [
      'amount_cents',
      'created_at',
      'currency',
      'error_occured',
      'has_parent_transaction',
      'id',
      'integration_id',
      'is_3d_secure',
      'is_auth',
      'is_capture',
      'is_refunded',
      'is_standalone_payment',
      'is_voided',
      'order',
      'owner',
      'pending',
      'source_data',
      'success',
    ]

    fields.forEach(field => {
      if (data[field] !== undefined) {
        ordered[field] = data[field]
      }
    })
    
    return ordered
  }
}

export const paymobHmacVerifier = new PaymobHmacVerifier()

// lib/infrastructure/payments/providers/paymob.ts
import axios from 'axios'
import { ENV } from '@/lib/shared/env/env'
import { paymentLogger } from '@/lib/shared/logger'

const PAYMOB_BASE_URL = 'https://accept.paymob.com/api'

export interface PaymobOrder {
  id: number
  amount_cents: number
  currency: string
  merchant_order_id: string
}

export interface PaymobPaymentKey {
  token: string
  orderId: number
}

export interface PaymobBillingData {
  apartment?: string
  email: string
  floor?: string
  first_name: string
  street?: string
  building?: string
  phone_number: string
  shipping_method?: string
  postal_code?: string
  city?: string
  country?: string
  last_name?: string
  state?: string
}

export class PaymobService {
  private apiKey: string
  private integrationId: string
  private hmacSecret: string

  constructor() {
    this.apiKey = ENV.PAYMOB_API_KEY || ''
    this.integrationId = ENV.PAYMOB_INTEGRATION_ID || ''
    this.hmacSecret = ENV.PAYMOB_HMAC_SECRET || ''
  }

  // 1. Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Authentication Token
  async getAuthToken(): Promise<string> {
    try {
      paymentLogger.info('Requesting Paymob auth token')
      
      const response = await axios.post(`${PAYMOB_BASE_URL}/auth/tokens`, {
        api_key: this.apiKey
      })
      
      paymentLogger.info('Paymob auth token received')
      return response.data.token
    } catch (error: any) {
      paymentLogger.error('Error getting Paymob auth token', error)
      throw new Error('ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø®Ø¯Ù…Ø© Ø§Ù„Ø¯ÙØ¹')
    }
  }

  // 2. Ø¥Ù†Ø´Ø§Ø¡ Order ÙÙŠ Paymob
  async createOrder({
    amount,
    currency = 'EGP',
    bookingId,
    userId
  }: {
    amount: number
    currency?: string
    bookingId: string
    userId: string
  }): Promise<PaymobOrder> {
    try {
      const authToken = await this.getAuthToken()
      
      paymentLogger.info('Creating Paymob order', { bookingId, userId, amount })
      
      const response = await axios.post(
        `${PAYMOB_BASE_URL}/ecommerce/orders`,
        {
          auth_token: authToken,
          delivery_needed: 'false',
          amount_cents: amount * 100,
          currency,
          items: [],
          merchant_order_id: bookingId
        },
        { timeout: 10000 } // 10 seconds timeout
      )

      paymentLogger.info('Paymob order created', { 
        orderId: response.data.id,
        bookingId 
      })

      return response.data
    } catch (error: any) {
      paymentLogger.error('Error creating Paymob order', {
        error: error.message,
        bookingId,
        amount
      })
      throw error
    }
  }

  // 3. Ø¥Ù†Ø´Ø§Ø¡ Payment Key Ù„ÙØªØ­ Iframe
  async getPaymentKey({
    orderId,
    amount,
    billingData,
    bookingId
  }: {
    orderId: string | number
    amount: number
    billingData: PaymobBillingData
    bookingId: string
  }): Promise<string> {
    try {
      const authToken = await this.getAuthToken()
      
      paymentLogger.info('Getting Paymob payment key', { orderId, bookingId })
      
      const response = await axios.post(
        `${PAYMOB_BASE_URL}/acceptance/payment_keys`,
        {
          auth_token: authToken,
          amount_cents: amount * 100,
          expiration: 3600, // Ø³Ø§Ø¹Ø© ÙˆØ§Ø­Ø¯Ø©
          order_id: orderId,
          billing_data: billingData,
          currency: 'EGP',
          integration_id: this.integrationId,
          lock_order_when_paid: 'false',
          extra: {
            booking_id: bookingId
          }
        },
        { timeout: 10000 }
      )

      paymentLogger.info('Paymob payment key received', { orderId })
      return response.data.token
    } catch (error: any) {
      paymentLogger.error('Error getting Paymob payment key', {
        error: error.message,
        orderId
      })
      throw error
    }
  }

  // 4. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù€ HMAC (Ù„Ù€ Webhook)
  verifyHMAC(data: any, receivedHMAC: string): boolean {
    try {
      const { 
        amount_cents, created_at, currency, error_occured, has_parent_transaction, 
        id, integration_id, is_3d_secure, is_auth, is_capture, is_refunded, 
        is_standalone_payment, is_voided, order, owner, pending, source_data, success 
      } = data

      const orderId = order?.id || ''
      const pan = source_data?.pan || ''
      const sub_type = source_data?.sub_type || ''
      const type = source_data?.type || ''

      const stringToHash = 
        amount_cents + 
        created_at + 
        currency + 
        error_occured + 
        has_parent_transaction + 
        id + 
        integration_id + 
        is_3d_secure + 
        is_auth + 
        is_capture + 
        is_refunded + 
        is_standalone_payment + 
        is_voided + 
        orderId + 
        owner + 
        pending + 
        pan + 
        sub_type + 
        type + 
        success

      const crypto = require('crypto')
      const calculatedHMAC = crypto
        .createHmac('sha512', this.hmacSecret)
        .update(stringToHash)
        .digest('hex')

      const isValid = calculatedHMAC === receivedHMAC
      
      paymentLogger.info('HMAC verification', { 
        isValid,
        orderId: data.order?.id 
      })
      
      return isValid
    } catch (error: any) {
      paymentLogger.error('HMAC verification error', error)
      return false
    }
  }

  // 5. Mock mode Ù„Ù„ØªÙ†Ù…ÙŠØ©
  isMockMode(): boolean {
    return ENV.NODE_ENV !== 'production' || !this.apiKey
  }

  // 6. Ø¥Ù†Ø´Ø§Ø¡ order ÙˆÙ‡Ù…ÙŠ Ù„Ù„ØªÙ†Ù…ÙŠØ©
  async createMockOrder(params: {
    amount: number
    currency: string
    bookingId: string
  }): Promise<PaymobOrder> {
    paymentLogger.info('Creating mock Paymob order', params)
    
    return {
      id: Date.now(),
      amount_cents: params.amount * 100,
      currency: params.currency,
      merchant_order_id: params.bookingId
    }
  }

  // 7. Ù…ÙØªØ§Ø­ Ø¯ÙØ¹ ÙˆÙ‡Ù…ÙŠ Ù„Ù„ØªÙ†Ù…ÙŠØ©
  async getMockPaymentKey(params: {
    orderId: number
  }): Promise<string> {
    paymentLogger.info('Creating mock payment key', params)
    return `mock_token_${Date.now()}_${params.orderId}`
  }
}

export const paymobService = new PaymobService()

// lib/infrastructure/notifications/notification-service.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { logger } from '@/lib/shared/logger'

// Ø§Ø³ØªØ®Ø¯Ù… Ø£Ù†ÙˆØ§Ø¹ Prisma Ù…Ø¨Ø§Ø´Ø±Ø© Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† ØªØ¹Ø±ÙŠÙÙ‡Ø§ Ø¨Ù†ÙØ³Ùƒ
import type { NotificationType as PrismaNotificationType } from '@prisma/client'

export interface NotificationParams {
  userId: string
  type: PrismaNotificationType  // âœ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†ÙˆØ¹ Prisma Ù…Ø¨Ø§Ø´Ø±Ø©
  title: string
  message: string
  relatedId?: string
  data?: any
  channel?: 'APP' | 'EMAIL' | 'SMS'
}

export class NotificationService {
  async send(params: NotificationParams): Promise<void> {
    try {
      // 1. Save to DB - Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØµØ­ÙŠØ­Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Prisma schema
      await prisma.notification.create({
        data: {
          userId: params.userId,
          type: params.type,
          title: params.title,
          message: params.message,
          // âŒ Ø£Ø²Ù„ 'read' Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹ ÙÙŠ Prisma schema
          // read: false,
          relatedId: params.relatedId, // ØªØ£ÙƒØ¯ Ø£Ù† relatedId Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Prisma schema
          data: params.data || {}
          // Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ø¥Ø¶Ø§ÙØ© createdAt Ø£Ùˆ updatedAt Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…Ø·Ù„ÙˆØ¨Ø©
        }
      })

      // 2. Send to external channels (async)
      this.sendToChannels(params).catch(error => {
        logger.error('Failed to send notification to channels', error)
      })

      logger.info('Notification sent', {
        userId: params.userId,
        type: params.type,
        relatedId: params.relatedId
      })
    } catch (error: any) {
      logger.error('Failed to save notification', error)
      // Notification failure shouldn't break business logic
    }
  }

  private async sendToChannels(params: NotificationParams): Promise<void> {
    const channels = params.channel ? [params.channel] : ['APP']
    
    for (const channel of channels) {
      try {
        switch (channel) {
          case 'EMAIL':
            await this.sendEmail(params)
            break
          case 'SMS':
            await this.sendSMS(params)
            break
          // APP notifications already saved to DB
        }
      } catch (error: any) {
        logger.warn(`Failed to send ${channel} notification`, error)
      }
    }
  }

  private async sendEmail(params: NotificationParams): Promise<void> {
    // TODO: Integrate with email service
    const { RESEND_API_KEY, EMAIL_FROM } = process.env
    
    if (!RESEND_API_KEY || !EMAIL_FROM) {
      logger.warn('Email service not configured', { userId: params.userId })
      return
    }

    logger.info('Email notification queued', {
      userId: params.userId,
      type: params.type
    })
    
    // Implement email sending here
  }

  private async sendSMS(params: NotificationParams): Promise<void> {
    // TODO: Integrate with SMS service
    logger.info('SMS notification queued', {
      userId: params.userId,
      type: params.type
    })
  }

  async getUserNotifications(userId: string, limit: number = 50) {
    return prisma.notification.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
      take: limit
    })
  }

  async markAsRead(notificationId: string, userId: string) {
    // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø­Ù‚Ù„ readØŒ ÙØ±Ø¨Ù…Ø§ ÙŠÙƒÙˆÙ† Ù‡Ù†Ø§Ùƒ Ø­Ù‚Ù„ status
    return prisma.notification.update({
      where: { 
        id: notificationId,
        userId // Ensure user owns the notification
      },
      data: { 
        // âŒ Ø£Ø²Ù„ 'read: true' Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ø§Ù„Ø­Ù‚Ù„ Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
        // read: true 
        // Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø°Ù„ÙƒØŒ Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ù‡Ù†Ø§Ùƒ:
        // status: 'READ'
        // Ø£Ùˆ isRead: true
      }
    })
  }

  async markAllAsRead(userId: string) {
    // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø­Ù‚Ù„ readØŒ ÙÙ„Ø§ ÙŠÙ…ÙƒÙ† ØªÙ†ÙÙŠØ° Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø©
    // Ø£Ùˆ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø­Ù‚Ù„ Ø¢Ø®Ø± Ù…Ø«Ù„ status
    return prisma.notification.updateMany({
      where: { 
        userId,
        // read: false // âŒ Ø£Ø²Ù„ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
      },
      data: { 
        // read: true // âŒ Ø£Ø²Ù„ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
      }
    })
  }
}

export const notificationService = new NotificationService()
// lib/infrastructure/database/prisma.ts
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma = globalForPrisma.prisma ?? new PrismaClient({
  log: process.env.NODE_ENV === 'development' 
    ? ['query', 'error', 'warn'] 
    : ['error'],
  errorFormat: 'pretty'
})

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma
}

export default prisma

// lib/infrastructure/auth/auth-options.ts
import { NextAuthOptions } from 'next-auth'
import CredentialsProvider from 'next-auth/providers/credentials'
import GoogleProvider from 'next-auth/providers/google'
import { RateLimiterMemory } from 'rate-limiter-flexible'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { comparePassword } from '@/lib/infrastructure/security/password'
import { z } from 'zod'
import { authLogger } from '@/lib/shared/logger'
import { USER_ROLES, UserRole } from '@/lib/shared/constants' // âœ… Ø¥Ø²Ø§Ù„Ø© SKILL_LEVELS ÙˆSkillLevel
import { ENV } from '@/lib/shared/env/env'

// Rate Limiter
const loginRateLimiter = new RateLimiterMemory({
  points: 5,
  duration: 15 * 60,
})

// Validation schema for login
const loginSchema = z.object({
  email: z.string().email('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ØºÙŠØ± ØµØ§Ù„Ø­'),
  password: z.string().min(1, 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù…Ø·Ù„ÙˆØ¨Ø©')
})

const normalizeEmail = (email: string): string => {
  return email.toLowerCase().trim()
}

export const authOptions: NextAuthOptions = {
  providers: [
    CredentialsProvider({
      name: 'credentials',
      credentials: {
        email: { label: 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ', type: 'email' },
        password: { label: 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±', type: 'password' }
      },
      async authorize(credentials) {
        try {
          await loginRateLimiter.consume(credentials?.email || 'unknown')
          
          const validated = loginSchema.parse(credentials)
          const normalizedEmail = normalizeEmail(validated.email)

          const user = await prisma.user.findUnique({
            where: { email: normalizedEmail }
          })

          if (!user) {
            authLogger.warn('User not found', { email: normalizedEmail })
            throw new Error('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£Ùˆ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©')
          }

          if (!user.isActive) {
            authLogger.warn('Inactive account attempt', { userId: user.id })
            throw new Error('Ø§Ù„Ø­Ø³Ø§Ø¨ ØºÙŠØ± Ù†Ø´Ø·')
          }

          if (user.lockedUntil && user.lockedUntil > new Date()) {
            authLogger.warn('Locked account attempt', { userId: user.id })
            throw new Error('Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…Ø¤Ù‚Øª Ù…ØºÙ„Ù‚ØŒ Ø­Ø§ÙˆÙ„ Ù„Ø§Ø­Ù‚Ø§Ù‹')
          }

          if (!user.passwordHash) {
            authLogger.warn('No password hash for credentials login', { userId: user.id })
            throw new Error('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£Ùˆ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©')
          }

          const isValid = await comparePassword(validated.password, user.passwordHash)
          
          if (!isValid) {
            await prisma.user.update({
              where: { id: user.id },
              data: {
                loginAttempts: { increment: 1 },
                ...(user.loginAttempts + 1 >= 5 ? {
                  lockedUntil: new Date(Date.now() + 15 * 60 * 1000)
                } : {})
              }
            })
            authLogger.warn('Invalid password attempt', { userId: user.id })
            throw new Error('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£Ùˆ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©')
          }

          await prisma.user.update({
            where: { id: user.id },
            data: {
              loginAttempts: 0,
              lockedUntil: null,
              lastLogin: new Date()
            }
          })

          authLogger.info('User authenticated successfully', { userId: user.id })
          
          return {
            id: user.id,
            name: user.name,
            email: user.email,
            role: user.role as UserRole,
            isActive: user.isActive,
            isVerified: user.isVerified
          }

        } catch (error: any) {
          if (error instanceof Error && error.message.includes('RateLimiter')) {
            authLogger.warn('Rate limit exceeded', { email: credentials?.email })
            throw new Error('Ù„Ù‚Ø¯ ØªØ¬Ø§ÙˆØ²Øª Ø§Ù„Ø­Ø¯ Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡ Ù…Ù† Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª')
          }
          authLogger.error('Authentication error', error)
          throw new Error(error.message || 'ÙØ´Ù„ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„')
        }
      }
    }),

    GoogleProvider({
      clientId: ENV.GOOGLE_CLIENT_ID || '',
      clientSecret: ENV.GOOGLE_CLIENT_SECRET || '',
      authorization: {
        params: {
          prompt: "consent",
          access_type: "offline",
          response_type: "code",
          scope: "openid email profile"
        }
      },
      async profile(profile) {
        const normalizedEmail = normalizeEmail(profile.email)
        
        try {
          // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ
          let user = await prisma.user.findUnique({
            where: { email: normalizedEmail }
          })

          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ù…Ø³ØªØ®Ø¯Ù…ØŒ Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙŠØ¯
          if (!user) {
            user = await prisma.user.create({
              data: {
                email: normalizedEmail,
                name: profile.name || profile.email.split('@')[0],
                passwordHash: null,
                role: USER_ROLES.PLAYER,
                isActive: true,
                isVerified: true,
                lastLogin: new Date(),
                phone: null,
                phoneNumber: null,
                age: null,
                description: null,
                skillLevel: 'AVERAGE' // âœ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø³ØªØ±ÙŠÙ†Ø¬ Ù…Ø¨Ø§Ø´Ø±Ø©
              }
            })
            authLogger.info('New OAuth user created', { userId: user.id })
          } else {
            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ
            await prisma.user.update({
              where: { id: user.id },
              data: { 
                lastLogin: new Date(),
                name: profile.name || user.name
              }
            })
          }

          if (!user.isActive) {
            authLogger.warn('Inactive OAuth account', { userId: user.id })
            throw new Error('Ø§Ù„Ø­Ø³Ø§Ø¨ ØºÙŠØ± Ù†Ø´Ø·')
          }

          authLogger.info('OAuth user authenticated', { userId: user.id })
          
          return {
            id: user.id,
            name: user.name,
            email: user.email,
            role: user.role as UserRole,
            isActive: user.isActive,
            isVerified: user.isVerified
          }
        } catch (error: any) {
          authLogger.error('OAuth profile error', error)
          throw error
        }
      }
    })
  ],

  session: {
    strategy: 'jwt',
    maxAge: 30 * 24 * 60 * 60,
  },

  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id
        token.role = (user as any).role
        token.isActive = (user as any).isActive
        token.isVerified = (user as any).isVerified
      }
      return token
    },

    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.id as string
        session.user.role = token.role as UserRole
        session.user.isActive = token.isActive as boolean
        session.user.isVerified = token.isVerified as boolean
      }
      return session
    },

    async signIn() {
      try {
        return true
      } catch (error) {
        authLogger.error('Sign in callback error', error)
        return false
      }
    },

    async redirect({ url, baseUrl }) {
      if (url.startsWith('/')) {
        return `${baseUrl}${url}`
      } else if (new URL(url).origin === baseUrl) {
        return url
      }
      return baseUrl
    }
  },

  pages: {
    signIn: '/login',
    signOut: '/login',
    error: '/login'
  },

  debug: ENV.NODE_ENV === 'development',
  secret: ENV.NEXTAUTH_SECRET || 'your-fallback-secret-for-development'
}

// lib/infrastructure/auth/errors.ts
import { z } from 'zod'
import { authLogger } from '@/lib/shared/logger'  // âœ… Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù€ logger Ø§Ù„Ø¬Ø¯ÙŠØ¯

export class AppError extends Error {
  constructor(
    public message: string,
    public statusCode: number = 500,
    public errorCode?: string,
    public details?: unknown
  ) {
    super(message)
    this.name = this.constructor.name
    Error.captureStackTrace(this, this.constructor)
    authLogger.error(`AppError: ${message}`, { statusCode, errorCode, details })
  }
}

export class ValidationError extends AppError {
  constructor(message: string, details?: unknown) {
    super(message, 400, 'VALIDATION_ERROR', details)
  }
}

export class AuthenticationError extends AppError {
  constructor(message = 'Authentication required') {
    super(message, 401, 'AUTHENTICATION_ERROR')
  }
}

export class AuthorizationError extends AppError {
  constructor(message = 'Insufficient permissions') {
    super(message, 403, 'AUTHORIZATION_ERROR')
  }
}

export class NotFoundError extends AppError {
  constructor(resource = 'Resource') {
    super(`${resource} not found`, 404, 'NOT_FOUND')
  }
}

export class ConflictError extends AppError {
  constructor(message = 'Resource already exists') {
    super(message, 409, 'CONFLICT')
  }
}

export class RateLimitError extends AppError {
  constructor(message = 'Too many requests') {
    super(message, 429, 'RATE_LIMIT_EXCEEDED')
  }
}

export class TokenExpiredError extends AppError {
  constructor(message = 'Token has expired') {
    super(message, 401, 'TOKEN_EXPIRED')
  }
}

export class InvalidTokenError extends AppError {
  constructor(message = 'Invalid token') {
    super(message, 401, 'INVALID_TOKEN')
  }
}

// Error handler
export const handleError = (error: unknown): AppError => {
  if (error instanceof AppError) {
    return error
  }
  
  if (error instanceof z.ZodError) {
    return new ValidationError(
      'Validation failed',
      error.issues.map((e: z.ZodIssue) => ({
        path: e.path.join('.'),
        message: e.message
      }))
    )
  }
  
  authLogger.error('Unexpected error', error)
  
  return new AppError(
    'An unexpected error occurred',
    500,
    'INTERNAL_SERVER_ERROR'
  )
}

// lib/infrastructure/auth/responses.ts
export interface ApiResponse<T = any> {
  success: boolean
  message: string
  data?: T
  errorCode?: string
  details?: any
  timestamp: string
  path?: string
}

export const successResponse = <T>(
  message: string, 
  data?: T,
  path?: string
): ApiResponse<T> => ({
  success: true,
  message,
  data,
  timestamp: new Date().toISOString(),
  path
})

export const errorResponse = (
  message: string,
  errorCode?: string,
  details?: any,
  path?: string
): ApiResponse => ({
  success: false,
  message,
  errorCode,
  details,
  timestamp: new Date().toISOString(),
  path
})

export const validationErrorResponse = (
  errors: any[],
  path?: string
): ApiResponse => ({
  success: false,
  message: 'Validation failed',
  errorCode: 'VALIDATION_ERROR',
  details: { errors },
  timestamp: new Date().toISOString(),
  path
})
// lib/infrastructure/auth/validators.ts
import { z } from 'zod'

export const emailSchema = z.string()
  .email('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ØºÙŠØ± ØµØ§Ù„Ø­')
  .min(1, 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù…Ø·Ù„ÙˆØ¨')
  .max(100, 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø·ÙˆÙŠÙ„ Ø¬Ø¯Ø§Ù‹')

export const passwordSchema = z.string()
  .min(6, 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† 6 Ø£Ø­Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„')
  .max(72, 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø·ÙˆÙŠÙ„Ø© Ø¬Ø¯Ø§Ù‹')

export const nameSchema = z.string()
  .min(2, 'Ø§Ù„Ø§Ø³Ù… ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø­Ø±ÙÙŠÙ† Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„')
  .max(100, 'Ø§Ù„Ø§Ø³Ù… Ø·ÙˆÙŠÙ„ Ø¬Ø¯Ø§Ù‹')
  .regex(/^[a-zA-Z\u0600-\u06FF\s]*$/, 'Ø§Ù„Ø§Ø³Ù… ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠØ­ØªÙˆÙŠ ÙÙ‚Ø· Ø¹Ù„Ù‰ Ø£Ø­Ø±Ù ÙˆÙ…Ø³Ø§ÙØ§Øª')

export const phoneSchema = z.string()
  .min(10, 'Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† 10 Ø£Ø±Ù‚Ø§Ù… Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„')
  .max(15, 'Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ Ø·ÙˆÙŠÙ„ Ø¬Ø¯Ø§Ù‹')
  .regex(/^[0-9+\-\s()]*$/, 'Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ ØºÙŠØ± ØµØ§Ù„Ø­')

export const ageSchema = z.number()
  .min(13, 'Ø§Ù„Ø¹Ù…Ø± ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† 13 Ø³Ù†Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„')
  .max(100, 'Ø§Ù„Ø¹Ù…Ø± ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† 100 Ø³Ù†Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£ÙƒØ«Ø±')

export const skillLevelSchema = z.enum(['WEAK', 'AVERAGE', 'GOOD', 'EXCELLENT', 'LEGENDARY'])

export const registerSchema = z.object({
  name: nameSchema,
  email: emailSchema,
  password: passwordSchema,
  confirmPassword: z.string(),
  phoneNumber: phoneSchema,
  age: ageSchema,
  description: z.string().max(500, 'Ø§Ù„ÙˆØµÙ Ø·ÙˆÙŠÙ„ Ø¬Ø¯Ø§Ù‹ (500 Ø­Ø±Ù ÙƒØ­Ø¯ Ø£Ù‚ØµÙ‰)').optional(),
  skillLevel: skillLevelSchema
}).refine(data => data.password === data.confirmPassword, {
  message: "ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± Ù…ØªØ·Ø§Ø¨Ù‚Ø©",
  path: ["confirmPassword"]
})

export const loginSchema = z.object({
  email: emailSchema,
  password: z.string().min(1, 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù…Ø·Ù„ÙˆØ¨Ø©')
})

export const updateProfileSchema = z.object({
  name: nameSchema.optional(),
  email: emailSchema.optional(),
  phoneNumber: phoneSchema.optional(),
  age: ageSchema.optional(),
  description: z.string().max(500).optional(),
  skillLevel: skillLevelSchema.optional()
}).refine(data => Object.keys(data).length > 0, {
  message: "ÙŠØ¬Ø¨ ØªÙ‚Ø¯ÙŠÙ… Ø­Ù‚Ù„ ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„"
})

export const changePasswordSchema = z.object({
  currentPassword: z.string().min(1, 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù…Ø·Ù„ÙˆØ¨Ø©'),
  newPassword: passwordSchema,
  confirmPassword: z.string()
}).refine(data => data.newPassword === data.confirmPassword, {
  message: "ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± Ù…ØªØ·Ø§Ø¨Ù‚Ø©",
  path: ["confirmPassword"]
})

export type RegisterInput = z.infer<typeof registerSchema>
export type LoginInput = z.infer<typeof loginSchema>
export type UpdateProfileInput = z.infer<typeof updateProfileSchema>
export type ChangePasswordInput = z.infer<typeof changePasswordSchema>
export type RegisterFormInput = RegisterInput & {
  skillLevel: 'WEAK' | 'AVERAGE' | 'GOOD' | 'EXCELLENT' | 'LEGENDARY'
}
// lib/domain/slots/read-model.ts
import { SLOT_STATUS } from '@/lib/shared/constants'  // âœ… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯
import { DomainError } from '@/lib/core/errors/domain-errors'  // âœ… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯

export type UISlotView = {
  id: string
  startTime: Date
  endTime: Date
  uiStatus: 'AVAILABLE' | 'LOCKED_ME' | 'LOCKED_OTHER' | 'BOOKED'
  originalStatus: string
  price: number
  deposit: number
  metadata?: {
    needsConfirmation?: boolean
    lockedUntil?: Date
    lockedByUserId?: string
  }
}

export class SlotReadModel {
  static toUISlot(dbSlot: any, currentUserId?: string | null): UISlotView {
    const now = new Date()
    const startTime = new Date(dbSlot.startTime)
    
    const dbStatus = this.normalizeDbStatus(dbSlot.status)
    
    let uiStatus: UISlotView['uiStatus']
    let needsConfirmation = false

    switch (dbStatus) {
      case SLOT_STATUS.BOOKED:
        uiStatus = 'BOOKED'
        break

      case SLOT_STATUS.TEMP_LOCKED:
        if (dbSlot.lockedByUserId === currentUserId) {
          uiStatus = 'LOCKED_ME'
        } else {
          uiStatus = 'LOCKED_OTHER'
        }
        break

      case SLOT_STATUS.AVAILABLE:
        uiStatus = 'AVAILABLE'
        const diffHours = (startTime.getTime() - now.getTime()) / (1000 * 60 * 60)
        if (diffHours < 24) {
          needsConfirmation = true
        }
        break

      default:
        throw new DomainError(
          'SLOT_NOT_FOUND', 
          `Ø­Ø§Ù„Ø© ØºÙŠØ± Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„Ø¹Ø±Ø¶: ${dbSlot.status}`
        )
    }

    return {
      id: dbSlot.id,
      startTime,
      endTime: new Date(dbSlot.endTime),
      uiStatus,
      originalStatus: dbSlot.status,
      price: dbSlot.price,
      deposit: dbSlot.deposit,
      metadata: {
        needsConfirmation,
        lockedUntil: dbSlot.lockedUntil ? new Date(dbSlot.lockedUntil) : undefined,
        lockedByUserId: dbSlot.lockedByUserId
      }
    }
  }
  
  private static normalizeDbStatus(dbStatus: string): string {
    switch (dbStatus) {
      case SLOT_STATUS.AVAILABLE:
      case 'AVAILABLE_NEEDS_CONFIRM':
      case 'PENDING_CONFIRMATION':
        return SLOT_STATUS.AVAILABLE
      case SLOT_STATUS.TEMP_LOCKED:
        return SLOT_STATUS.TEMP_LOCKED
      case SLOT_STATUS.BOOKED:
        return SLOT_STATUS.BOOKED
      case SLOT_STATUS.UNAVAILABLE:
        return SLOT_STATUS.UNAVAILABLE
      default:
        return SLOT_STATUS.UNAVAILABLE
    }
  }

  static filterVisibleSlots(dbSlots: any[], currentUserId?: string | null): UISlotView[] {
    return dbSlots
      .map(slot => this.toUISlot(slot, currentUserId))
      .filter(slot => ['AVAILABLE', 'LOCKED_ME', 'LOCKED_OTHER', 'BOOKED'].includes(slot.uiStatus))
  }

  static async getAvailableSlots(fieldId: string, date: Date, userId?: string): Promise<UISlotView[]> {
    const { prisma } = await import('@/lib/infrastructure/database/prisma')  // âœ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ
    
    const dayStart = new Date(date.getFullYear(), date.getMonth(), date.getDate())
    const dayEnd = new Date(dayStart.getTime() + 24 * 60 * 60 * 1000)

    const dbSlots = await prisma.slot.findMany({
      where: {
        fieldId,
        startTime: {
          gte: dayStart,
          lt: dayEnd
        }
      },
      include: {
        bookings: {
          where: {
            status: { in: ['CONFIRMED', 'PENDING_PAYMENT'] }
          }
        }
      }
    })

    const availableSlots = dbSlots.filter(slot => {
      // Ø§Ø³ØªØ¨Ø¹Ø§Ø¯ Ø§Ù„Ø³Ù„Ø§Øª Ø§Ù„Ù…Ø­Ø¬ÙˆØ²Ø©
      const hasActiveBooking = slot.bookings.length > 0
      if (hasActiveBooking) return false
      
      // Ø§Ø³ØªØ¨Ø¹Ø§Ø¯ Ø§Ù„Ø³Ù„Ø§Øª ØºÙŠØ± Ø§Ù„Ù…ØªØ§Ø­Ø©
      if (slot.status === SLOT_STATUS.UNAVAILABLE) return false
      
      // Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ø³Ù„Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© Ø£Ùˆ Ø§Ù„Ù…Ù‚ÙÙˆÙ„Ø© Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
      if (slot.status === SLOT_STATUS.TEMP_LOCKED && slot.lockedByUserId !== userId) {
        return false
      }
      
      return true
    })

    return this.filterVisibleSlots(availableSlots, userId)
  }
}

export function getUISlots(slots: any[], userId?: string): UISlotView[] {
  return SlotReadModel.filterVisibleSlots(slots, userId)
}

// lib/domain/slots/time-slots/booking-limits.ts
import { prisma } from '@/lib/infrastructure/database/prisma'  // âœ… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯
import { startOfDay, addDays } from 'date-fns'
import { DomainError } from '@/lib/core/errors/domain-errors'  // âœ… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯
import { BOOKING_STATUS } from '@/lib/shared/constants'  // âœ… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯

export async function checkBookingLimits({
  userId,
  slotDate,
  slotDurationMin
}: {
  userId: string
  slotDate: Date
  slotDurationMin: number
}) {
  const dayStart = startOfDay(slotDate)
  const dayEnd = addDays(dayStart, 1)
  
  const dayOfWeek = dayStart.getDay()
  const weekStart = addDays(dayStart, -dayOfWeek)
  const weekEnd = addDays(weekStart, 7)

  const dailyBookings = await prisma.booking.findMany({
    where: {
      userId,
      status: { 
        in: [BOOKING_STATUS.CONFIRMED, BOOKING_STATUS.PENDING_PAYMENT] 
      },
      slot: {
        startTime: { gte: dayStart, lt: dayEnd }
      }
    },
    include: {
      slot: {
        select: {
          startTime: true,
          endTime: true,
          durationMinutes: true
        }
      }
    }
  })

  const dailyMinutes = dailyBookings.reduce((sum, booking) => {
    if (booking.slot.durationMinutes) {
      return sum + booking.slot.durationMinutes
    }
    
    const start = new Date(booking.slot.startTime)
    const end = new Date(booking.slot.endTime)
    const diffMinutes = Math.round((end.getTime() - start.getTime()) / (1000 * 60))
    return sum + diffMinutes
  }, 0)

  if (dailyMinutes + slotDurationMin > 120) {
    throw new DomainError('BOOKING_LIMIT_EXCEEDED', 'ÙˆØµÙ„Øª Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ø§Ù„ÙŠÙˆÙ…ÙŠ (Ø³Ø§Ø¹ØªÙŠÙ†)')
  }

  const weeklyBookings = await prisma.booking.findMany({
    where: {
      userId,
      status: { 
        in: [BOOKING_STATUS.CONFIRMED, BOOKING_STATUS.PENDING_PAYMENT] 
      },
      slot: {
        startTime: { gte: weekStart, lt: weekEnd }
      }
    },
    include: {
      slot: {
        select: {
          startTime: true,
          endTime: true,
          durationMinutes: true
        }
      }
    }
  })

  const weeklyMinutes = weeklyBookings.reduce((sum, booking) => {
    if (booking.slot.durationMinutes) {
      return sum + booking.slot.durationMinutes
    }
    
    const start = new Date(booking.slot.startTime)
    const end = new Date(booking.slot.endTime)
    const diffMinutes = Math.round((end.getTime() - start.getTime()) / (1000 * 60))
    return sum + diffMinutes
  }, 0)

  if (weeklyMinutes + slotDurationMin > 240) {
    throw new DomainError('BOOKING_LIMIT_EXCEEDED', 'ÙˆØµÙ„Øª Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ÙŠ (4 Ø³Ø§Ø¹Ø§Øª)')
  }

  return true
}

// lib/domain/slots/time-slots/core-logic.ts
import { addMinutes, startOfDay, addDays, getHours, getMinutes } from 'date-fns'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { SLOT_STATUS, FIELD_STATUS } from '@/lib/shared/constants'
import { DomainError } from '@/lib/core/errors/domain-errors'

// âœ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ù…ÙˆØ­Ø¯Ø©
import { Day, Slot, SlotStatus } from '@/lib/core/types'

const CONFIRMATION_WINDOW_HOURS = 24
const LOCK_DURATION_MINUTES = 5

function normalizeToMinute(date: Date): number {
  return Math.floor(date.getTime() / 60000) * 60000
}

export function canBookDirectly(start: Date): boolean {
  const diffMs = start.getTime() - Date.now()
  const diffHours = diffMs / (1000 * 60 * 60)
  return diffHours >= CONFIRMATION_WINDOW_HOURS
}

function normalizeDbStatus(status: string | null | undefined): SlotStatus {
  if (!status) return SLOT_STATUS.AVAILABLE
  switch (status) {
    case SLOT_STATUS.AVAILABLE:
    case SLOT_STATUS.TEMP_LOCKED:
    case SLOT_STATUS.BOOKED:
    case SLOT_STATUS.UNAVAILABLE:
      return status
    case 'AVAILABLE_NEEDS_CONFIRM':
    case 'PENDING_CONFIRMATION':
      return SLOT_STATUS.AVAILABLE
    default:
      return SLOT_STATUS.UNAVAILABLE
  }
}

function resolveSlotStatus({
  field,
  slotStart,
  dbSlot,
  now
}: {
  field: any
  slotStart: Date
  dbSlot?: any
  now: Date
}): SlotStatus | null {
  const diffMs = slotStart.getTime() - now.getTime()
  const diffHours = diffMs / (1000 * 60 * 60)

  if (diffHours < 0) return null

  if (field.status !== FIELD_STATUS.OPEN && !dbSlot) {
    return SLOT_STATUS.UNAVAILABLE
  }

  if (dbSlot) {
    const dbStatus = normalizeDbStatus(dbSlot.status)

    if (
      dbStatus === SLOT_STATUS.TEMP_LOCKED &&
      dbSlot.lockedUntil &&
      new Date(dbSlot.lockedUntil) > now
    ) {
      return SLOT_STATUS.TEMP_LOCKED
    }

    if (dbStatus === SLOT_STATUS.BOOKED) {
      return SLOT_STATUS.BOOKED
    }

    if (dbStatus === SLOT_STATUS.UNAVAILABLE) {
      return SLOT_STATUS.UNAVAILABLE
    }
  }

  return SLOT_STATUS.AVAILABLE
}

export async function generateSlotsForDay({
  fieldId,
  date,
  now
}: {
  fieldId: string
  date: Date
  now: Date
}) {
  const field = await prisma.field.findUnique({
    where: { id: fieldId }
  })

  if (!field) {
    throw new DomainError('FIELD_NOT_FOUND')
  }

  const dayStart = startOfDay(date)
  const dayEnd = addDays(dayStart, 1)

  const existingSlots = await prisma.slot.findMany({
    where: {
      fieldId,
      startTime: {
        gte: dayStart,
        lt: dayEnd
      }
    }
  })

  const slotsMap = new Map<number, any>(
    existingSlots.map(slot => [
      normalizeToMinute(new Date(slot.startTime)),
      slot
    ])
  )

  const openH = getHours(field.openingTime)
  const openM = getMinutes(field.openingTime)
  const closeH = getHours(field.closingTime)
  const closeM = getMinutes(field.closingTime)

  let current = startOfDay(date)
  current.setHours(openH, openM, 0, 0)

  const end = startOfDay(date)
  end.setHours(closeH, closeM, 0, 0)

  const slots: Slot[] = []

  while (addMinutes(current, field.slotDurationMin) <= end) {
    const slotStart = new Date(current)
    const slotEnd = addMinutes(slotStart, field.slotDurationMin)

    const key = normalizeToMinute(slotStart)
    const dbSlot = slotsMap.get(key)

    const status = resolveSlotStatus({
      field,
      slotStart,
      dbSlot,
      now
    })

    if (status) {
      slots.push({
        id: dbSlot?.id ?? `${fieldId}-${slotStart.toISOString()}`,
        fieldId,
        startTime: slotStart,
        endTime: slotEnd,
        status,
        price: field.pricePerHour,
        deposit: field.depositPrice
      })
    }

    current = slotEnd
  }

  return slots
}

export async function generateSlotsForRange({
  fieldId,
  startDate,
  endDate,
  now
}: {
  fieldId: string
  startDate: Date
  endDate: Date
  now: Date
}) {
  const allSlots: Slot[] = []
  let currentDate = startOfDay(startDate)

  while (currentDate <= endDate) {
    const daySlots = await generateSlotsForDay({
      fieldId,
      date: currentDate,
      now
    })

    allSlots.push(...daySlots)
    currentDate = addDays(currentDate, 1)
  }

  return allSlots
}

export async function lockSlot({
  slotId,
  userId
}: {
  slotId: string
  userId: string
}) {
  const now = new Date()

  return prisma.$transaction(async tx => {
    const slot = await tx.slot.findUnique({
      where: { id: slotId }
    })

    if (!slot) {
      throw new DomainError('SLOT_NOT_FOUND')
    }

    const status = normalizeDbStatus(slot.status)
    const canLock = status === SLOT_STATUS.AVAILABLE

    if (!canLock) {
      throw new DomainError('SLOT_UNAVAILABLE')
    }

    await tx.slot.update({
      where: { id: slotId },
      data: {
        status: SLOT_STATUS.TEMP_LOCKED,
        lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES),
        lockedByUserId: userId
      }
    })

    return { success: true }
  })
}

// âœ… ØªØ¹Ø¯ÙŠÙ„ generateNextDays Ù„ÙŠÙˆÙ„Ù‘Ø¯ ÙƒÙ„ Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
export function generateNextDays(count: number = 10): Day[] {
  const days: Day[] = []
  const today = startOfDay(new Date())

  for (let i = 0; i < count; i++) {
    const date = addDays(today, i)

    const weekday = date.toLocaleDateString('ar-EG', { weekday: 'long' })
    const dayNumber = date.toLocaleDateString('ar-EG', { day: 'numeric' })
    const monthName = date.toLocaleDateString('ar-EG', { month: 'long' })

    days.push({
      date: date.toISOString(),
      isWeekend: [5, 6].includes(date.getDay()), // Ø§Ù„Ø¬Ù…Ø¹Ø©/Ø§Ù„Ø³Ø¨Øª
      slotsAvailable: 0,
      slots: [],
      isToday: i === 0,
      isTomorrow: i === 1,
      weekday,
      dayNumber,
      monthName
    })
  }

  return days
}

export function generateNextTenDays(): Day[] {
  return generateNextDays(10)
}

// lib/domain/guards/index.ts
export { 
  BookingGuard,
  assertBooking,
  assertSlotLocked,
  assertSlotCanLock 
} from './booking-guards'

export { 
  SlotStateGuard,
  assertSlotTransition 
} from './slot-guards'

export { 
  PaymentStateGuard,
  assertPaymentCanProcess,
  assertPaymentUpdate,
  assertWebhookValid 
} from './payment-guards'

// lib/domain/guards/payment-guards.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { 
  PAYMENT_STATUS, 
  PaymentStatus,   // âœ… Ø§Ù„Ù†ÙˆØ¹ Ø¬Ø§Ù‡Ø² Ù…Ù† constants
  BOOKING_STATUS
} from '@/lib/shared/constants'
import { StateTransitionValidator } from '@/lib/application/services/booking-transitions'

export class PaymentStateGuard {
  static async assertCanProcessPayment(params: {
    bookingId: string
    userId: string
  }) {
    const booking = await prisma.booking.findUnique({
      where: { id: params.bookingId },
      include: {
        slot: true,
        payments: {
          orderBy: { createdAt: 'desc' },
          take: 1
        }
      }
    })

    if (!booking) throw new DomainError('BOOKING_NOT_FOUND')
    if (booking.userId !== params.userId) throw new DomainError('BOOKING_NOT_OWNED')

    if (booking.status !== BOOKING_STATUS.DRAFT) {
      throw new DomainError(
        'BOOKING_INVALID_STATE',
        `Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„Ø¯ÙØ¹ Ù„Ø­Ø¬Ø² Ø¨Ø­Ø§Ù„Ø© ${booking.status}`
      )
    }

    if (booking.expiresAt && booking.expiresAt < new Date()) {
      throw new DomainError('BOOKING_EXPIRED')
    }

    if (booking.slot.status !== 'TEMP_LOCKED') {
      throw new DomainError('SLOT_LOCK_EXPIRED')
    }

    const lastPayment = booking.payments[0]
    if (lastPayment?.status === PAYMENT_STATUS.PAID) {
      throw new DomainError('PAYMENT_ALREADY_PROCESSED')
    }

    return { booking, lastPayment }
  }

  static async assertCanUpdatePayment(params: {
    paymentId: string
    targetStatus: PaymentStatus   // âœ… Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„ØµØ­ÙŠØ­
    orderId?: string
  }) {
    const payment = await prisma.payment.findUnique({
      where: { id: params.paymentId },
      include: { booking: true }
    })

    if (!payment) throw new DomainError('PAYMENT_NOT_FOUND')

    if (params.orderId) {
      const existingWithOrderId = await prisma.payment.findUnique({
        where: { orderId: params.orderId }
      })
      
      if (existingWithOrderId && existingWithOrderId.id !== payment.id) {
        throw new DomainError('DUPLICATE_PAYMENT', 'ØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… orderId Ù…Ø³Ø¨Ù‚Ø§Ù‹')
      }
    }

    const validation = StateTransitionValidator.validatePaymentTransition(
      payment.status,
      params.targetStatus,
      payment
    )

    if (!validation.allowed) {
      throw new DomainError('PAYMENT_FAILED', validation.reason)
    }

    return payment
  }

  static async assertWebhookValid(params: {
    orderId: string
    transactionId: string
    amount: number
  }) {
    const existingPayment = await prisma.payment.findUnique({
      where: { orderId: params.orderId }
    })

    if (existingPayment) {
      if (existingPayment.status === PAYMENT_STATUS.PAID) {
        throw new DomainError('PAYMENT_ALREADY_PROCESSED')
      }
      
      if (existingPayment.paymentId === params.transactionId) {
        throw new DomainError('DUPLICATE_PAYMENT', 'ØªÙ… Ù…Ø¹Ø§Ù„Ø¬Ø© Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ù…Ø³Ø¨Ù‚Ø§Ù‹')
      }
    }

    const payment = await prisma.payment.findFirst({
      where: { 
        orderId: params.orderId,
        status: PAYMENT_STATUS.PROCESSING
      },
      include: { 
        booking: {
          include: {
            slot: true,
            user: true
          }
        }
      }
    })

    if (!payment) {
      throw new DomainError('PAYMENT_NOT_FOUND', `Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¯ÙØ¹Ø© Ø¨ orderId: ${params.orderId}`)
    }

    if (payment.amount !== params.amount) {
      throw new DomainError(
        'PAYMENT_FAILED',
        `Ø§Ù„Ù…Ø¨Ù„Øº ØºÙŠØ± Ù…ØªØ·Ø§Ø¨Ù‚: Ø§Ù„Ù…ØªÙˆÙ‚Ø¹ ${payment.amount}ØŒ Ø§Ù„Ù…Ø³ØªÙ„Ù… ${params.amount}`
      )
    }

    if (payment.booking.status !== BOOKING_STATUS.PENDING_PAYMENT) {
      throw new DomainError(
        'BOOKING_INVALID_STATE',
        `Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø¬Ø² ØºÙŠØ± Ù…Ù†Ø§Ø³Ø¨Ø©: ${payment.booking.status}`
      )
    }

    return payment
  }

  static async validatePaymentDetails(params: {
    paymentId: string
    userId: string
  }) {
    const payment = await prisma.payment.findUnique({
      where: { id: params.paymentId },
      include: { booking: true }
    })

    if (!payment) throw new DomainError('PAYMENT_NOT_FOUND')
    if (payment.booking.userId !== params.userId) throw new DomainError('BOOKING_NOT_OWNED')

    return payment
  }
}

// âœ… Bind Ø§Ù„Ø¯ÙˆØ§Ù„ Ø¹Ù„Ø´Ø§Ù† ØªØ³ØªØ®Ø¯Ù… Ø¨Ø³Ù‡ÙˆÙ„Ø©
export const assertPaymentCanProcess = PaymentStateGuard.assertCanProcessPayment.bind(PaymentStateGuard)
export const assertPaymentUpdate = PaymentStateGuard.assertCanUpdatePayment.bind(PaymentStateGuard)
export const assertWebhookValid = PaymentStateGuard.assertWebhookValid.bind(PaymentStateGuard)
export const validatePaymentDetails = PaymentStateGuard.validatePaymentDetails.bind(PaymentStateGuard)

// lib/domain/guards/slot-guards.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { SLOT_STATUS } from '@/lib/shared/constants'
import { StateTransitionValidator } from '@/lib/application/services/booking-transitions'

export class SlotStateGuard {
  static async assertCanBeLocked(params: {
    slotId: string
    userId: string
    fieldId: string
  }) {
    const slot = await prisma.slot.findUnique({
      where: { id: params.slotId },
      include: { field: true }
    })

    if (!slot) {
      throw new DomainError('SLOT_NOT_FOUND')
    }

    if (slot.fieldId !== params.fieldId) {
      throw new DomainError('SLOT_NOT_FOUND', 'Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù„Ø§ ÙŠÙ†ØªÙ…ÙŠ Ù„Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ø¹Ø¨')
    }

    const now = new Date()

    if (slot.status === SLOT_STATUS.BOOKED) {
      throw new DomainError('SLOT_ALREADY_BOOKED')
    }

    // Ø¥ØµÙ„Ø§Ø­: Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©
    if (slot.status === SLOT_STATUS.UNAVAILABLE) {
      throw new DomainError('SLOT_UNAVAILABLE')
    }

    if (new Date(slot.startTime) <= now) {
      throw new DomainError('TIME_IN_PAST')
    }

    if (slot.status === SLOT_STATUS.TEMP_LOCKED && slot.lockedUntil && slot.lockedUntil > now) {
      if (slot.lockedByUserId === params.userId) {
        return { slot, canExtend: true }
      } else {
        throw new DomainError('SLOT_LOCKED_BY_OTHER')
      }
    }

    return { slot, canExtend: false }
  }

  static async assertIsLockedToUser(params: {
    slotId: string
    userId: string
  }) {
    const slot = await prisma.slot.findUnique({
      where: { id: params.slotId }
    })

    if (!slot) {
      throw new DomainError('SLOT_NOT_FOUND')
    }

    const now = new Date()

    // Ø¥ØµÙ„Ø§Ø­: Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© Ù…Ø¹ Ø§Ù„Ø«Ø§Ø¨Øª
    if (slot.status !== SLOT_STATUS.TEMP_LOCKED) {
      throw new DomainError('SLOT_CANNOT_BE_LOCKED', 'Ø§Ù„Ù…ÙˆØ¹Ø¯ ØºÙŠØ± Ù…Ù‚ÙÙˆÙ„')
    }

    if (!slot.lockedUntil || slot.lockedUntil <= now) {
      throw new DomainError('SLOT_LOCK_EXPIRED')
    }

    if (slot.lockedByUserId !== params.userId) {
      throw new DomainError('SLOT_LOCKED_BY_OTHER')
    }

    return slot
  }

  static async assertCanTransition(params: {
    slotId: string
    targetStatus: string
    userId?: string
  }) {
    const slot = await prisma.slot.findUnique({
      where: { id: params.slotId }
    })

    if (!slot) {
      throw new DomainError('SLOT_NOT_FOUND')
    }

    // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù€ validator Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ø§Ù„Ø°ÙŠ ÙŠØ±Ù…ÙŠ DomainError
    StateTransitionValidator.validateSlotTransition(
      slot.status,
      params.targetStatus,
      params.userId,
      slot
    )

    return slot
  }

  static async cleanupExpiredLocks() {
    const now = new Date()
    
    const result = await prisma.slot.updateMany({
      where: {
        status: SLOT_STATUS.TEMP_LOCKED,
        lockedUntil: { lt: now }
      },
      data: {
        status: SLOT_STATUS.AVAILABLE,
        lockedByUserId: null,
        lockedUntil: null
      }
    })

    return result.count
  }
}

export const assertSlotCanLock = SlotStateGuard.assertCanBeLocked.bind(SlotStateGuard)
export const assertSlotLocked = SlotStateGuard.assertIsLockedToUser.bind(SlotStateGuard)
export const assertSlotTransition = SlotStateGuard.assertCanTransition.bind(SlotStateGuard)

// lib/domain/guards/booking-guards.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { 
  SLOT_STATUS, 
  BOOKING_STATUS 
} from '@/lib/shared/constants'
import { StateTransitionValidator } from '@/lib/application/services/booking-transitions'

export class BookingGuard {
  static async assertBookingState(params: {
    bookingId: string
    expectedStatuses: string[] // âœ… Ø¥ØµÙ„Ø§Ø­: Ø§Ø³ØªØ®Ø¯Ù… string[] Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† BOOKING_STATUS[]
    userId?: string
    customCheck?: (booking: any) => Promise<void>
  }) {
    const booking = await prisma.booking.findUnique({
      where: { id: params.bookingId },
      include: { 
        slot: true, 
        field: true,
        payments: {
          orderBy: { createdAt: 'desc' },
          take: 1
        }
      }
    })

    if (!booking) {
      throw new DomainError('BOOKING_NOT_FOUND')
    }

    if (params.userId && booking.userId !== params.userId) {
      throw new DomainError('BOOKING_NOT_OWNED')
    }

    if (!params.expectedStatuses.includes(booking.status)) {
      throw new DomainError(
        'BOOKING_INVALID_STATE',
        `Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© (${booking.status}) Ù„Ø§ ØªØ³Ù…Ø­ Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©. ` +
        `Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ù…Ø³Ù…ÙˆØ­Ø©: ${params.expectedStatuses.join(', ')}`
      )
    }

    // âœ… Ø¥ØµÙ„Ø§Ø­: Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† ØªØ¬Ø§Ù‡Ù„Ù‡Ø§
    try {
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ù€ slot
      const slotValidation = StateTransitionValidator.validateCompleteBookingFlow(
        booking.slot.status,
        booking.status,
        booking.paymentStatus
      )
      
      // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ Ù†Ø¬Ø­
      console.log('Slot validation passed:', slotValidation);
    } catch (error: any) {
      throw new DomainError('BOOKING_INVALID_STATE', error.message)
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¢Ø®Ø± Ø¯ÙØ¹
    const lastPayment = booking.payments[0]
    if (lastPayment) {
      try {
        const paymentValidation = StateTransitionValidator.validatePaymentTransition(
          lastPayment.status,
          booking.paymentStatus,
          lastPayment
        )
        
        // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ Ù†Ø¬Ø­
        console.log('Payment validation passed:', paymentValidation);
      } catch (error: any) {
        throw new DomainError('PAYMENT_FAILED', error.message)
      }
    }

    if (params.customCheck) {
      await params.customCheck(booking)
    }

    return booking
  }

  static async assertSlotLockedToUser(params: {
    slotId: string
    userId: string
  }) {
    const slot = await prisma.slot.findUnique({
      where: { id: params.slotId },
      include: {
        field: {
          select: { id: true, name: true }
        }
      }
    })

    if (!slot) {
      throw new DomainError('SLOT_NOT_FOUND')
    }

    const now = new Date()

    // âœ… Ø¥ØµÙ„Ø§Ø­: Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©
    if (slot.status !== SLOT_STATUS.TEMP_LOCKED) {
      throw new DomainError('SLOT_CANNOT_BE_LOCKED')
    }

    if (!slot.lockedUntil || slot.lockedUntil <= now) {
      throw new DomainError('SLOT_LOCK_EXPIRED')
    }

    if (slot.lockedByUserId !== params.userId) {
      throw new DomainError('SLOT_LOCKED_BY_OTHER', 
        `Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù…Ù‚ÙÙˆÙ„ Ø¨ÙˆØ§Ø³Ø·Ø© Ù…Ø³ØªØ®Ø¯Ù… Ø¢Ø®Ø±. Ø§Ù„Ù…Ù„Ø¹Ø¨: ${slot.field?.name || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}`
      )
    }

    return slot
  }

  static async assertSlotCanBeLocked(params: {
    slotId: string
    userId: string
  }) {
    const slot = await prisma.slot.findUnique({
      where: { id: params.slotId },
      include: {
        field: {
          select: { id: true, name: true, status: true }
        }
      }
    })

    if (!slot) {
      throw new DomainError('SLOT_NOT_FOUND')
    }

    const now = new Date()

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ù„Ø¹Ø¨
    if (slot.field?.status !== 'OPEN') {
      throw new DomainError(
        'FIELD_NOT_FOUND',
        `Ø§Ù„Ù…Ù„Ø¹Ø¨ ${slot.field?.name || ''} ØºÙŠØ± Ù…ØªØ§Ø­ Ø­Ø§Ù„ÙŠØ§Ù‹`
      )
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ù€ slot
    if (slot.status === SLOT_STATUS.BOOKED) {
      throw new DomainError('SLOT_ALREADY_BOOKED')
    }

    // âœ… Ø¥ØµÙ„Ø§Ø­: Ø£Ø²Ù„ Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø© Ù…Ø¹ UNAVAILABLE Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… string Ù…Ø¨Ø§Ø´Ø±Ø©
    if (slot.status === 'UNAVAILABLE') {
      throw new DomainError('SLOT_UNAVAILABLE')
    }

    if (new Date(slot.startTime) <= now) {
      throw new DomainError('TIME_IN_PAST')
    }

    if (
      slot.status === SLOT_STATUS.TEMP_LOCKED &&
      slot.lockedUntil &&
      slot.lockedUntil > now
    ) {
      if (slot.lockedByUserId === params.userId) {
        return { slot, canExtend: true }
      } else {
        throw new DomainError('SLOT_LOCKED_BY_OTHER')
      }
    }

    return { slot, canExtend: false }
  }

  // Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø­Ø¬Ø²
  static async assertBookingLimits(params: {
    userId: string
    date: Date
    maxDailyBookings?: number
    maxWeeklyBookings?: number
  }) {
    const startOfDay = new Date(params.date)
    startOfDay.setHours(0, 0, 0, 0)
    
    const endOfDay = new Date(params.date)
    endOfDay.setHours(23, 59, 59, 999)

    const startOfWeek = new Date(params.date)
    startOfWeek.setDate(startOfWeek.getDate() - startOfWeek.getDay())
    startOfWeek.setHours(0, 0, 0, 0)
    
    const endOfWeek = new Date(startOfWeek)
    endOfWeek.setDate(endOfWeek.getDate() + 6)
    endOfWeek.setHours(23, 59, 59, 999)

    // Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
    const dailyBookings = await prisma.booking.count({
      where: {
        userId: params.userId,
        createdAt: {
          gte: startOfDay,
          lte: endOfDay
        },
        status: {
          in: [BOOKING_STATUS.CONFIRMED, 'PENDING_PAYMENT'] // âœ… Ø§Ø³ØªØ®Ø¯Ù… string Ù…Ø¨Ø§Ø´Ø±Ø©
        }
      }
    })

    // Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ÙŠØ©
    const weeklyBookings = await prisma.booking.count({
      where: {
        userId: params.userId,
        createdAt: {
          gte: startOfWeek,
          lte: endOfWeek
        },
        status: {
          in: [BOOKING_STATUS.CONFIRMED, 'PENDING_PAYMENT'] // âœ… Ø§Ø³ØªØ®Ø¯Ù… string Ù…Ø¨Ø§Ø´Ø±Ø©
        }
      }
    })

    const maxDaily = params.maxDailyBookings || 2
    const maxWeekly = params.maxWeeklyBookings || 5

    if (dailyBookings >= maxDaily) {
      throw new DomainError(
        'BOOKING_LIMIT_EXCEEDED',
        `ÙˆØµÙ„Øª Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø­Ø¬ÙˆØ²Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ© (${maxDaily})`
      )
    }

    if (weeklyBookings >= maxWeekly) {
      throw new DomainError(
        'BOOKING_LIMIT_EXCEEDED',
        `ÙˆØµÙ„Øª Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø­Ø¬ÙˆØ²Ø§Øª Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ÙŠØ© (${maxWeekly})`
      )
    }

    return { dailyBookings, weeklyBookings }
  }
}

export const assertBooking = BookingGuard.assertBookingState.bind(BookingGuard)
export const assertSlotLocked = BookingGuard.assertSlotLockedToUser.bind(BookingGuard)
export const assertSlotCanLock = BookingGuard.assertSlotCanBeLocked.bind(BookingGuard)
export const assertBookingLimits = BookingGuard.assertBookingLimits.bind(BookingGuard)

// lib/domain/booking/types.ts
import { 
  BookingStatus, 
  PaymentStatus 
} from '@/lib/shared/constants'  // âœ… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯

export interface BookingCreateInput {
  slotId: string
  fieldId: string
  userId: string
  idempotencyKey?: string
}

export interface BookingCreateResult {
  bookingId: string
  needsConfirmation: boolean
  idempotencyKey?: string
}

export interface BookingUpdateInput {
  bookingId: string
  status?: BookingStatus
  paymentStatus?: PaymentStatus
  paymentId?: string
  orderId?: string
}

export interface PaymentInitInput {
  bookingId: string
  amount: number
  currency?: string
  idempotencyKey?: string
}

export interface PaymentInitResult {
  paymentUrl: string
  orderId: string
  idempotencyKey?: string
}

export interface SlotLockInput {
  slotId: string
  userId: string
  fieldId: string
}

export interface SlotLockResult {
  success: boolean
  locked?: boolean
  extended?: boolean
  lockedUntil?: Date
}

// Response types for APIs
export interface ApiResponse<T = any> {
  success: boolean
  data?: T
  error?: {
    code: string
    message: string
    details?: any
  }
  pagination?: {
    page: number
    limit: number
    total: number
    totalPages: number
    hasMore: boolean
  }
}

// Webhook types
export interface PaymobWebhookPayload {
  obj: {
    id: number
    amount_cents: number
    success: boolean
    order: {
      id: number
      merchant_order_id: string
    }
    created_at: number
    currency: string
    source_data?: any
  }
}

export type BookingWithRelations = any // Ø³ÙŠØ­Ø¯Ø¯ Ù…Ù† Prisma
export type SlotWithRelations = any

// lib/core/types/index.ts
import { 
  SLOT_STATUS, 
  BOOKING_STATUS, 
  FIELD_STATUS, 
  FIELD_TYPES,
  PAYMENT_STATUS 
} from '@/lib/shared/constants'

export type SlotStatus = typeof SLOT_STATUS[keyof typeof SLOT_STATUS]
export type BookingStatus = typeof BOOKING_STATUS[keyof typeof BOOKING_STATUS]
export type FieldStatus = typeof FIELD_STATUS[keyof typeof FIELD_STATUS]
export type FieldType = typeof FIELD_TYPES[keyof typeof FIELD_TYPES]
export type PaymentStatus = typeof PAYMENT_STATUS[keyof typeof PAYMENT_STATUS]

export interface User {
  id: string
  email: string
  name: string
  phone?: string
  avatar?: string
  createdAt: Date
}

export interface Field {
  id: string
  name: string
  description?: string | null
  location: string
  address?: string | null
  pricePerHour: number
  depositPrice: number
  imageUrl?: string | null
  gallery: string[]
  type: FieldType
  status: FieldStatus
  openingTime: string
  closingTime: string
  slotDurationMin: number
  facilities: string[]
  rules: string[]
  rating: number
  reviewCount: number
  createdAt: Date
  updatedAt: Date
}

export interface Slot {
  id: string
  fieldId: string
  startTime: Date
  endTime: Date
  status: SlotStatus
  price: number
  deposit: number
  lockedUntil?: Date
  lockedByUserId?: string
}

export interface Booking {
  id: string
  userId: string
  fieldId: string
  slotId: string
  status: BookingStatus
  paymentStatus: PaymentStatus
  totalAmount: number
  depositPaid: number
  refundableUntil?: Date
  cancellationReason?: string
  createdAt: Date
  updatedAt: Date
  field?: Field
  slot?: Slot
  user?: User
}

export interface Payment {
  id: string
  bookingId: string
  amount: number
  currency: string
  paymentId: string
  orderId: string
  status: PaymentStatus
  metadata?: Record<string, any>
  createdAt: Date
}

// âœ… Day type Ø§Ù„Ù…ÙˆØ³Ø¹ Ø¹Ø´Ø§Ù† ÙŠØªÙˆØ§ÙÙ‚ Ù…Ø¹ DaySelector
export interface Day {
  date: string
  isWeekend: boolean
  slotsAvailable: number
  slots?: Slot[]
  isToday?: boolean
  isTomorrow?: boolean
  weekday?: string
  dayNumber?: string
  monthName?: string
}

// âœ… SlotGridProps Ù…Ø¹ userId Ø§Ø®ØªÙŠØ§Ø±ÙŠ
export interface SlotGridProps {
  slots: Slot[]
  fieldId: string
  fieldName: string
  userId?: string
  onSlotSelect?: (slot: Slot) => void
}

// âœ… ØªØ¹Ø±ÙŠÙØ§Øª Ù„Ù„Ù€ UI
export interface UISlot {
  id: string
  startTime: Date
  endTime: Date
  price: number
  deposit: number
  uiStatus: 'AVAILABLE' | 'LOCKED_ME' | 'LOCKED_OTHER' | 'BOOKED'
  needsConfirmation: boolean
}

export interface SlotBookingModalProps {
  slot: UISlot
  fieldId: string
  fieldName: string
  onClose: () => void
}

// lib/core/errors/domain-errors.ts
import { ERROR_CODES } from './error-codes'

const ERROR_MESSAGES: Record<keyof typeof ERROR_CODES, string> = {
  // Auth
  UNAUTHORIZED: 'ØºÙŠØ± Ù…ØµØ±Ø­',
  INVALID_CREDENTIALS: 'Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„ ØºÙŠØ± ØµØ­ÙŠØ­Ø©',
  SESSION_EXPIRED: 'Ø§Ù†ØªÙ‡Øª Ø§Ù„Ø¬Ù„Ø³Ø©ØŒ ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰',
  
  // Validation
  INVALID_INPUT: 'Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ§Ù„Ø­Ø©',
  MISSING_FIELD: 'Ø­Ù‚Ù„ Ù…Ø·Ù„ÙˆØ¨',
  INVALID_DATE: 'ØªØ§Ø±ÙŠØ® ØºÙŠØ± ØµØ§Ù„Ø­',
  VALIDATION_ERROR: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª',
  
  // Slot
  SLOT_NOT_FOUND: 'Ø§Ù„Ù…ÙˆØ¹Ø¯ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯',
  SLOT_UNAVAILABLE: 'Ø§Ù„Ù…ÙˆØ¹Ø¯ ØºÙŠØ± Ù…ØªØ§Ø­ Ù„Ù„Ø­Ø¬Ø²',
  SLOT_LOCKED_BY_OTHER: 'Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù…Ù‚ÙÙˆÙ„ Ù…Ø¤Ù‚ØªØ§Ù‹',
  SLOT_LOCK_EXPIRED: 'Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù‚ÙÙ„',
  SLOT_ALREADY_BOOKED: 'Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù…Ø­Ø¬ÙˆØ² Ø¨Ø§Ù„ÙØ¹Ù„',
  SLOT_CANNOT_BE_LOCKED: 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ù‚ÙÙ„ Ù‡Ø°Ø§ Ø§Ù„Ù…ÙˆØ¹Ø¯',
  
  // Booking
  BOOKING_NOT_FOUND: 'Ø§Ù„Ø­Ø¬Ø² ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯',
  BOOKING_NOT_OWNED: 'ØºÙŠØ± Ù…ØµØ±Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù‡Ø°Ø§ Ø§Ù„Ø­Ø¬Ø²',
  BOOKING_INVALID_STATE: 'Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„Ø§ ØªØ³Ù…Ø­ Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©',
  BOOKING_LIMIT_EXCEEDED: 'ÙˆØµÙ„Øª Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø­Ø¬Ø²',
  BOOKING_EXPIRED: 'Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø­Ø¬Ø²',
  BOOKING_IN_PROGRESS: 'Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø·Ù„Ø¨',
  
  // Payment
  PAYMENT_ALREADY_PROCESSED: 'ØªÙ… Ø¯ÙØ¹ Ù‡Ø°Ø§ Ø§Ù„Ø­Ø¬Ø² Ù…Ø³Ø¨Ù‚Ø§Ù‹',
  PAYMENT_FAILED: 'ÙØ´Ù„ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¯ÙØ¹',
  DUPLICATE_PAYMENT: 'ØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… orderId Ù…Ø³Ø¨Ù‚Ø§Ù‹',
  PAYMENT_NOT_FOUND: 'Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¯ÙØ¹ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©',
  
  // Time
  TIME_IN_PAST: 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø¬Ø² ÙˆÙ‚Øª Ù…Ø¶Ù‰',
  TIME_TOO_CLOSE: 'Ø§Ù„ÙˆÙ‚Øª Ù‚Ø±ÙŠØ¨ Ø¬Ø¯Ø§Ù‹',
  
  // Field
  FIELD_NOT_FOUND: 'Ø§Ù„Ù…Ù„Ø¹Ø¨ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯',
  FIELD_CLOSED: 'Ø§Ù„Ù…Ù„Ø¹Ø¨ Ù…ØºÙ„Ù‚ Ø­Ø§Ù„ÙŠØ§Ù‹',
  FIELD_MAINTENANCE: 'Ø§Ù„Ù…Ù„Ø¹Ø¨ ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©',
  
  // System
  INTERNAL_ERROR: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹',
  RATE_LIMITED: 'ØªÙ… ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ Ø§Ù„Ù…Ø³Ù…ÙˆØ­',
  SERVICE_UNAVAILABLE: 'Ø§Ù„Ø®Ø¯Ù…Ø© ØºÙŠØ± Ù…ØªØ§Ø­Ø© Ø­Ø§Ù„ÙŠØ§Ù‹'
} as const

export class DomainError extends Error {
  constructor(
    public code: keyof typeof ERROR_CODES,
    message?: string,
    public details?: any
  ) {
    // Ø­Ù„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø©: ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† message Ø¯Ø§Ø¦Ù…Ù‹Ø§ string
    super(message || ERROR_MESSAGES[code] || code);
    this.name = 'DomainError';
    
    // Ù„Ø­ÙØ¸ stack trace Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, DomainError);
    }
  }
  
  toResponse() {
    return {
      error: true,
      code: ERROR_CODES[this.code],
      message: this.message,
      details: this.details
    }
  }
  
  toJSON() {
    return this.toResponse()
  }
}

// Helper function for API responses
export function errorResponse(error: unknown) {
  if (error instanceof DomainError) {
    return {
      status: getStatusCode(error.code),
      body: error.toResponse()
    }
  }
  
  console.error('Unhandled error:', error)
  
  return {
    status: 500,
    body: {
      error: true,
      code: ERROR_CODES.INTERNAL_ERROR,
      message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹'
    }
  }
}

function getStatusCode(code: keyof typeof ERROR_CODES): number {
  const codeStr = ERROR_CODES[code]
  const codePrefix = codeStr ? codeStr.split('_')[0] : ''
  
  switch (codePrefix) {
    case 'AUTH':
      return 401
    case 'VAL':
      return 400
    case 'SLOT':
    case 'BOOK':
    case 'PAY':
    case 'TIME':
    case 'FIELD':
      return 400
    case 'SYS':
      return 500
    default:
      return 400
  }
}

// lib/core/errors/error-codes.ts
export const ERROR_CODES = {
  // Auth (1xx)
  UNAUTHORIZED: 'AUTH_001',
  INVALID_CREDENTIALS: 'AUTH_002',
  SESSION_EXPIRED: 'AUTH_003',
  
  // Validation (2xx)
  VALIDATION_ERROR: 'VAL_004', // âœ… Ø£Ø¶Ù Ù‡Ø°Ø§
  INVALID_INPUT: 'VAL_001',
  MISSING_FIELD: 'VAL_002',
  INVALID_DATE: 'VAL_003',
  
  // Slot (3xx)
  SLOT_NOT_FOUND: 'SLOT_001',
  SLOT_UNAVAILABLE: 'SLOT_002',
  SLOT_LOCKED_BY_OTHER: 'SLOT_003',
  SLOT_LOCK_EXPIRED: 'SLOT_004',
  SLOT_ALREADY_BOOKED: 'SLOT_005',
  SLOT_CANNOT_BE_LOCKED: 'SLOT_006',
  
  // Booking (4xx)
  BOOKING_NOT_FOUND: 'BOOK_001',
  BOOKING_NOT_OWNED: 'BOOK_002',
  BOOKING_INVALID_STATE: 'BOOK_003',
  BOOKING_LIMIT_EXCEEDED: 'BOOK_004',
  BOOKING_EXPIRED: 'BOOK_005',
  BOOKING_IN_PROGRESS: 'BOOK_006',
  
  // Payment (5xx)
  PAYMENT_ALREADY_PROCESSED: 'PAY_001',
  PAYMENT_FAILED: 'PAY_002',
  DUPLICATE_PAYMENT: 'PAY_003',
  PAYMENT_NOT_FOUND: 'PAY_004',
  
  // Time (6xx)
  TIME_IN_PAST: 'TIME_001',
  TIME_TOO_CLOSE: 'TIME_002',
  
  // Field (7xx)
  FIELD_NOT_FOUND: 'FIELD_001',
  FIELD_CLOSED: 'FIELD_002',
  FIELD_MAINTENANCE: 'FIELD_003',
  
  // System (9xx)
  INTERNAL_ERROR: 'SYS_001',
  RATE_LIMITED: 'SYS_002',
  SERVICE_UNAVAILABLE: 'SYS_003'
} as const

export type ErrorCode = typeof ERROR_CODES[keyof typeof ERROR_CODES]
export type ErrorCodeKey = keyof typeof ERROR_CODES

// lib/application/services/booking-transitions.ts
import { 
  SLOT_STATUS, 
  BOOKING_STATUS, 
  PAYMENT_STATUS 
} from '@/lib/shared/constants'
import { DomainError } from '@/lib/core/errors/domain-errors'

export class StateTransitionValidator {
  // Slot transitions
  static canTransitionSlot(
    currentStatus: string,
    targetStatus: string,
    userId?: string,
    slotData?: any
  ): { allowed: boolean; reason?: string } {
    
    const allowedTransitions: Record<string, string[]> = {
      [SLOT_STATUS.AVAILABLE]: [
        SLOT_STATUS.TEMP_LOCKED,
        SLOT_STATUS.UNAVAILABLE
      ],
      [SLOT_STATUS.TEMP_LOCKED]: [
        SLOT_STATUS.AVAILABLE, // timeout or manual release
        SLOT_STATUS.BOOKED     // after payment success
      ],
      [SLOT_STATUS.BOOKED]: [
        SLOT_STATUS.AVAILABLE  // admin only
      ],
      [SLOT_STATUS.UNAVAILABLE]: [
        SLOT_STATUS.AVAILABLE  // admin only
      ]
    }

    if (!allowedTransitions[currentStatus]?.includes(targetStatus)) {
      return {
        allowed: false,
        reason: `ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ø§Ù„ØªØ­ÙˆÙ„ Ù…Ù† ${currentStatus} Ø¥Ù„Ù‰ ${targetStatus}`
      }
    }

    // Additional checks
    if (currentStatus === SLOT_STATUS.TEMP_LOCKED && targetStatus === SLOT_STATUS.AVAILABLE) {
      if (slotData?.lockedByUserId && slotData.lockedByUserId !== userId) {
        return {
          allowed: false,
          reason: 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ù„ØºØ§Ø¡ Ù‚ÙÙ„ Ù…ÙˆØ¹Ø¯ Ù…Ù‚ÙÙˆÙ„ Ø¨ÙˆØ§Ø³Ø·Ø© Ù…Ø³ØªØ®Ø¯Ù… Ø¢Ø®Ø±'
        }
      }
    }

    if (currentStatus === SLOT_STATUS.BOOKED && targetStatus === SLOT_STATUS.AVAILABLE) {
      // Only admin can release booked slots
      if (userId && !this.isAdmin(userId)) {
        return {
          allowed: false,
          reason: 'ÙÙ‚Ø· Ø§Ù„Ù…Ø¯ÙŠØ± ÙŠÙ…ÙƒÙ†Ù‡ Ø¥Ù„ØºØ§Ø¡ Ø­Ø¬Ø² Ù…ÙˆØ¹Ø¯'
        }
      }
    }

    return { allowed: true }
  }

  // Helper method that throws DomainError
  static validateSlotTransition(
    currentStatus: string,
    targetStatus: string,
    userId?: string,
    slotData?: any
  ) {
    const validation = this.canTransitionSlot(currentStatus, targetStatus, userId, slotData)
    
    if (!validation.allowed) {
      throw new DomainError(
        'SLOT_CANNOT_BE_LOCKED',
        validation.reason
      )
    }
    
    return validation
  }

  // Booking transitions
  static canTransitionBooking(
    currentStatus: string,
    targetStatus: string,
    userId?: string,
    bookingData?: any
  ): { allowed: boolean; reason?: string } {
    
    const allowedTransitions: Record<string, string[]> = {
      [BOOKING_STATUS.DRAFT]: [
        BOOKING_STATUS.PENDING_PAYMENT,
        BOOKING_STATUS.EXPIRED,
        BOOKING_STATUS.CANCELLED
      ],
      [BOOKING_STATUS.PENDING_PAYMENT]: [
        BOOKING_STATUS.CONFIRMED,
        BOOKING_STATUS.FAILED,
        BOOKING_STATUS.CANCELLED
      ],
      [BOOKING_STATUS.CONFIRMED]: [
        BOOKING_STATUS.CANCELLED // with refund logic
      ],
      [BOOKING_STATUS.CANCELLED]: [],
      [BOOKING_STATUS.FAILED]: [],
      [BOOKING_STATUS.EXPIRED]: []
    }

    if (!allowedTransitions[currentStatus]?.includes(targetStatus)) {
      return {
        allowed: false,
        reason: `ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ ØªØºÙŠÙŠØ± Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø¬Ø² Ù…Ù† ${currentStatus} Ø¥Ù„Ù‰ ${targetStatus}`
      }
    }

    // Ownership check
    if (bookingData?.userId && userId && bookingData.userId !== userId) {
      if (!this.isAdmin(userId)) {
        return {
          allowed: false,
          reason: 'Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ ØªØ¹Ø¯ÙŠÙ„ Ø­Ø¬Ø² Ù…Ø³ØªØ®Ø¯Ù… Ø¢Ø®Ø±'
        }
      }
    }

    return { allowed: true }
  }

  // Helper method that throws DomainError for bookings
  static validateBookingTransition(
    currentStatus: string,
    targetStatus: string,
    userId?: string,
    bookingData?: any
  ) {
    const validation = this.canTransitionBooking(currentStatus, targetStatus, userId, bookingData)
    
    if (!validation.allowed) {
      throw new DomainError(
        'BOOKING_INVALID_STATE',
        validation.reason
      )
    }
    
    return validation
  }

  // Payment transitions
  static canTransitionPayment(
    currentStatus: string,
    targetStatus: string,
    _paymentData?: any
  ): { allowed: boolean; reason?: string } {
    
    const allowedTransitions: Record<string, string[]> = {
      [PAYMENT_STATUS.PENDING]: [
        PAYMENT_STATUS.PROCESSING,
        PAYMENT_STATUS.FAILED
      ],
      [PAYMENT_STATUS.PROCESSING]: [
        PAYMENT_STATUS.PAID,
        PAYMENT_STATUS.FAILED
      ],
      [PAYMENT_STATUS.PAID]: [
        PAYMENT_STATUS.REFUNDED
      ],
      [PAYMENT_STATUS.FAILED]: [
        PAYMENT_STATUS.PROCESSING // retry
      ],
      [PAYMENT_STATUS.REFUNDED]: []
    }

    if (!allowedTransitions[currentStatus]?.includes(targetStatus)) {
      return {
        allowed: false,
        reason: `ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ ØªØºÙŠÙŠØ± Ø­Ø§Ù„Ø© Ø§Ù„Ø¯ÙØ¹ Ù…Ù† ${currentStatus} Ø¥Ù„Ù‰ ${targetStatus}`
      }
    }

    return { allowed: true }
  }

  // Helper method that throws DomainError for payments
  static validatePaymentTransition(
    currentStatus: string,
    targetStatus: string,
    paymentData?: any
  ) {
    const validation = this.canTransitionPayment(currentStatus, targetStatus, paymentData)
    
    if (!validation.allowed) {
      throw new DomainError(
        'PAYMENT_FAILED',
        validation.reason
      )
    }
    
    return validation
  }

  // Helper to validate complete flow
  static validateBookingFlow(
    slotStatus: string,
    bookingStatus: string,
    paymentStatus: string
  ): string[] {
    const errors: string[] = []

    // Valid state combinations
    const validCombinations = [
      // Draft booking on locked slot
      { slot: SLOT_STATUS.TEMP_LOCKED, booking: BOOKING_STATUS.DRAFT, payment: PAYMENT_STATUS.PENDING },
      
      // Payment in progress
      { slot: SLOT_STATUS.TEMP_LOCKED, booking: BOOKING_STATUS.PENDING_PAYMENT, payment: PAYMENT_STATUS.PROCESSING },
      
      // Confirmed
      { slot: SLOT_STATUS.BOOKED, booking: BOOKING_STATUS.CONFIRMED, payment: PAYMENT_STATUS.PAID },
      
      // Failed/Cancelled
      { slot: SLOT_STATUS.AVAILABLE, booking: BOOKING_STATUS.FAILED, payment: PAYMENT_STATUS.FAILED },
      { slot: SLOT_STATUS.AVAILABLE, booking: BOOKING_STATUS.CANCELLED, payment: PAYMENT_STATUS.REFUNDED },
      { slot: SLOT_STATUS.AVAILABLE, booking: BOOKING_STATUS.EXPIRED, payment: PAYMENT_STATUS.FAILED }
    ]

    const isValid = validCombinations.some(combo => 
      combo.slot === slotStatus && 
      combo.booking === bookingStatus && 
      combo.payment === paymentStatus
    )

    if (!isValid) {
      errors.push(`Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ø­Ø§Ù„Ø§Øª ØºÙŠØ± ØµØ§Ù„Ø­Ø©: Slot=${slotStatus}, Booking=${bookingStatus}, Payment=${paymentStatus}`)
    }

    return errors
  }

  // Helper method that throws DomainError for complete flow
  static validateCompleteBookingFlow(
    slotStatus: string,
    bookingStatus: string,
    paymentStatus: string
  ) {
    const errors = this.validateBookingFlow(slotStatus, bookingStatus, paymentStatus)
    
    if (errors.length > 0) {
      throw new DomainError(
        'BOOKING_INVALID_STATE',
        errors.join(' | ')
      )
    }
    
    return { valid: true }
  }

  private static isAdmin(_userId: string): boolean {
    // TODO: Implement admin check from database
    // For now, return false
    return false
  }
}
// lib/application/services/booking-orchestrator.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { addMinutes } from 'date-fns'
import { 
  SLOT_STATUS, 
  BOOKING_STATUS, 
  PAYMENT_STATUS 
} from '@/lib/shared/constants'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { IdempotencyGuard } from '@/lib/application/idempotency/idempotency-guard'
import { checkBookingLimits } from '@/lib/domain/slots/time-slots/booking-limits'
import { notificationService } from '@/lib/infrastructure/notifications/notification-service'
import { paymobService } from '@/lib/infrastructure/payments/providers'
import { bookingLogger } from '@/lib/shared/logger'
import type { 
  BookingCreateInput, 
  BookingCreateResult,
  PaymentInitInput,
  PaymentInitResult
} from '@/lib/domain/booking/types'
import { ENV } from '@/lib/shared/env/env'

export class BookingOrchestrator {
  /**
   * ğŸ« 1. Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø¬Ø² Ø¬Ø¯ÙŠØ¯
   */
  static async createBooking(input: BookingCreateInput): Promise<BookingCreateResult> {
    const startTime = Date.now()
    const requestId = `booking_create_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

    bookingLogger.info('Creating booking', {
      requestId,
      userId: input.userId,
      slotId: input.slotId,
      fieldId: input.fieldId,
      idempotencyKey: input.idempotencyKey
    })

    try {
      // ğŸ” Idempotency check
      if (input.idempotencyKey) {
        const check = await IdempotencyGuard.check(
          input.idempotencyKey,
          input.userId,
          'booking:create',
          { slotId: input.slotId, fieldId: input.fieldId }
        )

        if (!check.shouldProceed) {
          if (check.response) {
            bookingLogger.info('Idempotent response returned', { requestId })
            return check.response as BookingCreateResult
          }
          throw new DomainError('BOOKING_IN_PROGRESS', 'Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø·Ù„Ø¨')
        }
      }

      const result = await prisma.$transaction(async (tx) => {
        // 1. ğŸ” ØªØ£ÙƒØ¯ Ø£Ù† Slot Ù…Ù‚ÙÙˆÙ„Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
        const slot = await tx.slot.findUnique({
          where: {
            id: input.slotId,
            fieldId: input.fieldId,
            status: SLOT_STATUS.TEMP_LOCKED,
            lockedByUserId: input.userId,
            lockedUntil: { gt: new Date() }
          },
          include: { field: true }
        })

        if (!slot) {
          throw new DomainError('SLOT_NOT_FOUND', 'Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù„Ù… ÙŠØ¹Ø¯ Ù…ØªØ§Ø­Ø§Ù‹ Ø£Ùˆ Ø§Ù†ØªÙ‡Ù‰ Ù‚ÙÙ„Ù‡')
        }

        // 2. ğŸ“ ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø­Ø¬Ø²
        await checkBookingLimits({
          userId: input.userId,
          slotDate: new Date(slot.startTime),
          slotDurationMin: slot.durationMinutes || 60
        })

        // 3. ğŸ« Ø¥Ù†Ø´Ø§Ø¡ Booking
        const booking = await tx.booking.create({
          data: {
            userId: input.userId,
            fieldId: input.fieldId,
            slotId: input.slotId,
            status: BOOKING_STATUS.DRAFT,
            paymentStatus: PAYMENT_STATUS.PENDING,
            totalAmount: slot.price,
            expiresAt: addMinutes(new Date(), 10),
            idempotencyKey: input.idempotencyKey || null
          }
        })

        const result: BookingCreateResult = {
          bookingId: booking.id,
          needsConfirmation: !this.canBookDirectly(new Date(slot.startTime))
        }

        // ğŸ’¾ Ø­ÙØ¸ Ù„Ù„Ù€ Idempotency
        if (input.idempotencyKey) {
          await IdempotencyGuard.saveResponse(
            input.idempotencyKey,
            input.userId,
            'booking:create',
            result,
            { slotId: input.slotId, fieldId: input.fieldId },
            60
          )
        }

        bookingLogger.info('Booking created successfully', {
          requestId,
          bookingId: booking.id,
          durationMs: Date.now() - startTime
        })

        return result
      })

      return result

    } catch (error: any) {
      bookingLogger.error('Booking creation failed', {
        requestId,
        error: error.message,
        userId: input.userId,
        durationMs: Date.now() - startTime
      })
      
      if (error instanceof DomainError) {
        throw error
      }
      throw new DomainError('INTERNAL_ERROR', 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø¬Ø²')
    }
  }

  /**
   * ğŸ’³ 2. Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¯ÙØ¹
   */
  static async initiatePayment(input: PaymentInitInput & { userId: string }): Promise<PaymentInitResult> {
    const startTime = Date.now()
    const requestId = `payment_init_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

    bookingLogger.info('Initiating payment', {
      requestId,
      bookingId: input.bookingId,
      userId: input.userId,
      amount: input.amount
    })

    try {
      // 1. ğŸ” Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Booking
      const booking = await prisma.booking.findUnique({
        where: { id: input.bookingId },
        include: { 
          slot: true,
          field: true,
          user: true
        }
      })

      if (!booking) {
        throw new DomainError('BOOKING_NOT_FOUND')
      }

      // 2. ğŸ” Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ù„ÙƒÙŠØ©
      if (booking.userId !== input.userId) {
        throw new DomainError('BOOKING_NOT_OWNED')
      }

      // 3. ğŸ” Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø¬Ø²
      if (booking.status !== BOOKING_STATUS.DRAFT) {
        throw new DomainError(
          'BOOKING_INVALID_STATE',
          `Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„Ø¯ÙØ¹ Ù„Ø­Ø¬Ø² Ø¨Ø­Ø§Ù„Ø© ${booking.status}`
        )
      }

      // 4. â° Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©
      if (booking.expiresAt && booking.expiresAt < new Date()) {
        throw new DomainError('BOOKING_EXPIRED')
      }

      // 5. ğŸ” Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Slot Ù„Ø§ ØªØ²Ø§Ù„ Ù…Ù‚ÙÙˆÙ„Ø©
      if (booking.slot.status !== SLOT_STATUS.TEMP_LOCKED) {
        throw new DomainError('SLOT_LOCK_EXPIRED')
      }

      // 6. ğŸ’³ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¯ÙØ¹ Ø³Ø§Ø¨Ù‚ Ù†Ø§Ø¬Ø­
      const lastPayment = await prisma.payment.findFirst({
        where: { bookingId: input.bookingId },
        orderBy: { createdAt: 'desc' }
      })

      if (lastPayment?.status === PAYMENT_STATUS.PAID) {
        throw new DomainError('PAYMENT_ALREADY_PROCESSED')
      }

      // 7. ğŸ” Idempotency Ù„Ù„Ø¯ÙØ¹
      const idempotencyKey = input.idempotencyKey || IdempotencyGuard.generateKey('payment')
      
      const check = await IdempotencyGuard.check(
        idempotencyKey,
        input.userId,
        'payment:initiate',
        { bookingId: input.bookingId, amount: input.amount }
      )

      if (!check.shouldProceed) {
        if (check.response) {
          bookingLogger.info('Idempotent payment response', { requestId })
          return check.response as PaymentInitResult
        }
        throw new DomainError('BOOKING_IN_PROGRESS')
      }

      const result = await prisma.$transaction(async (tx) => {
        // 8. ğŸ“¦ Ø¥Ù†Ø´Ø§Ø¡ Order ÙÙŠ Paymob
        let orderId: string
        let paymentToken: string

        if (paymobService.isMockMode()) {
          const mockOrder = await paymobService.createMockOrder({
            amount: input.amount,
            currency: input.currency || 'EGP',
            bookingId: input.bookingId
          })
          orderId = mockOrder.id.toString()
          paymentToken = await paymobService.getMockPaymentKey({ orderId: mockOrder.id })
        } else {
          const order = await paymobService.createOrder({
            amount: input.amount,
            currency: input.currency || 'EGP',
            bookingId: input.bookingId,
            userId: input.userId
          })
          orderId = order.id.toString()
          
          // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙÙˆØ§ØªÙŠØ±
          const billingData = {
            apartment: "NA",
            email: booking.user.email,
            floor: "NA",
            first_name: booking.user.name?.split(' ')[0] || "Ø¹Ù…ÙŠÙ„",
            street: "NA",
            building: "NA",
            phone_number: booking.user.phone || "01000000000",
            shipping_method: "NA",
            postal_code: "NA",
            city: "NA",
            country: "NA",
            last_name: booking.user.name?.split(' ').slice(1).join(' ') || "Ù…Ø³ØªØ®Ø¯Ù…",
            state: "NA"
          }

          paymentToken = await paymobService.getPaymentKey({
            orderId: order.id,
            amount: input.amount,
            billingData,
            bookingId: input.bookingId
          })
        }

        // 9. ğŸ’³ Ø¥Ù†Ø´Ø§Ø¡ Payment
        const payment = await tx.payment.create({
          data: {
            bookingId: input.bookingId,
            amount: input.amount,
            currency: input.currency || 'EGP',
            paymentId: `pay_${orderId}`,
            orderId: orderId,
            status: PAYMENT_STATUS.PROCESSING
          }
        })

        // 10. ğŸ”„ ØªØ­Ø¯ÙŠØ« Booking
        await tx.booking.update({
          where: { id: input.bookingId },
          data: {
            status: BOOKING_STATUS.PENDING_PAYMENT,
            paymentStatus: PAYMENT_STATUS.PROCESSING,
            paymentId: payment.id,
            orderId: orderId
          }
        })

        const result: PaymentInitResult = {
          paymentUrl: paymobService.isMockMode() 
            ? `/payment/mock/${orderId}` 
            : `https://accept.paymob.com/api/acceptance/iframes/${ENV.PAYMOB_IFRAME_ID || 'default'}?payment_token=${paymentToken}`,
          orderId,
          idempotencyKey
        }

        // ğŸ’¾ Ø­ÙØ¸ Ù„Ù„Ù€ Idempotency
        await IdempotencyGuard.saveResponse(
          idempotencyKey,
          input.userId,
          'payment:initiate',
          result,
          { bookingId: input.bookingId, amount: input.amount },
          30
        )

        bookingLogger.info('Payment initiated successfully', {
          requestId,
          orderId,
          paymentId: payment.id,
          durationMs: Date.now() - startTime
        })

        return result
      })

      return result

    } catch (error: any) {
      bookingLogger.error('Payment initiation failed', {
        requestId,
        error: error.message,
        bookingId: input.bookingId,
        durationMs: Date.now() - startTime
      })
      
      if (error instanceof DomainError) {
        throw error
      }
      throw new DomainError('INTERNAL_ERROR', 'ÙØ´Ù„ ÙÙŠ Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¯ÙØ¹')
    }
  }

  /**
   * âœ… 3. Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ø­Ø¬Ø² Ø¨Ø¹Ø¯ Ø§Ù„Ø¯ÙØ¹
   */
  static async completeBooking(params: {
    bookingId: string
    success: boolean
    paymentDetails: {
      transactionId: string
      orderId: string
      amount: number
      currency: string
    }
  }) {
    const startTime = Date.now()
    const requestId = `complete_booking_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

    bookingLogger.info('Completing booking', {
      requestId,
      bookingId: params.bookingId,
      success: params.success,
      orderId: params.paymentDetails.orderId
    })

    let booking: any

    try {
      // Transaction Ù„Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø­Ø±Ø¬Ø©
      await prisma.$transaction(async (tx) => {
        booking = await tx.booking.findUnique({
          where: { id: params.bookingId },
          include: { 
            slot: true, 
            field: true, 
            user: true 
          }
        })

        if (!booking) {
          throw new DomainError('BOOKING_NOT_FOUND')
        }

        // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† payment Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… orderId Ø£ÙˆÙ„Ø§Ù‹
        const existingPayment = await tx.payment.findFirst({
          where: { orderId: params.paymentDetails.orderId }
        })

        if (existingPayment) {
          if (existingPayment.status === PAYMENT_STATUS.PAID) {
            throw new DomainError('PAYMENT_ALREADY_PROCESSED')
          }
          
          if (existingPayment.bookingId !== params.bookingId) {
            throw new DomainError('DUPLICATE_PAYMENT', 'ØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… orderId ÙÙŠ Ø­Ø¬Ø² Ø¢Ø®Ø±')
          }
        }

        if (params.success) {
          // âœ… Ù†Ø¬Ø§Ø­ Ø§Ù„Ø¯ÙØ¹
          await tx.booking.update({
            where: { id: params.bookingId },
            data: {
              status: BOOKING_STATUS.CONFIRMED,
              paymentStatus: PAYMENT_STATUS.PAID
            }
          })

          await tx.slot.update({
            where: { id: booking.slotId },
            data: {
              status: SLOT_STATUS.BOOKED,
              lockedByUserId: null,
              lockedUntil: null
            }
          })

          await tx.payment.updateMany({
            where: { bookingId: params.bookingId },
            data: {
              status: PAYMENT_STATUS.PAID,
              paymentId: params.paymentDetails.transactionId,
              metadata: params.paymentDetails
            }
          })

          bookingLogger.info('Payment succeeded', {
            requestId,
            bookingId: params.bookingId,
            transactionId: params.paymentDetails.transactionId
          })

        } else {
          // âŒ ÙØ´Ù„ Ø§Ù„Ø¯ÙØ¹
          await tx.booking.update({
            where: { id: params.bookingId },
            data: {
              status: BOOKING_STATUS.FAILED,
              paymentStatus: PAYMENT_STATUS.FAILED
            }
          })

          await tx.slot.update({
            where: { id: booking.slotId },
            data: { 
              status: SLOT_STATUS.AVAILABLE,
              lockedByUserId: null,
              lockedUntil: null
            }
          })

          await tx.payment.updateMany({
            where: { bookingId: params.bookingId },
            data: {
              status: PAYMENT_STATUS.FAILED,
              metadata: params.paymentDetails
            }
          })

          bookingLogger.warn('Payment failed', {
            requestId,
            bookingId: params.bookingId
          })
        }
      })

      // âœ… Ø¥Ø±Ø³Ø§Ù„ Notifications Ø®Ø§Ø±Ø¬ Transaction
      await this.sendPostTransactionNotifications(booking, params.success, params.paymentDetails)

      bookingLogger.info('Booking completed successfully', {
        requestId,
        bookingId: params.bookingId,
        durationMs: Date.now() - startTime
      })

      return { success: true }

    } catch (error: any) {
      bookingLogger.error('Booking completion failed', {
        requestId,
        error: error.message,
        bookingId: params.bookingId,
        durationMs: Date.now() - startTime
      })
      
      if (error instanceof DomainError) {
        throw error
      }
      throw new DomainError('INTERNAL_ERROR', 'ÙØ´Ù„ ÙÙŠ Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ø­Ø¬Ø²')
    }
  }

  /**
   * ğŸ§¹ 4. ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø­Ø¬ÙˆØ²Ø§Øª Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ©
   */
  static async cleanupExpiredBookings() {
    const startTime = Date.now()
    const jobId = `cleanup_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

    bookingLogger.info('Starting expired bookings cleanup', { jobId })

    try {
      const now = new Date()
      
      const expiredBookings = await prisma.booking.findMany({
        where: {
          status: BOOKING_STATUS.DRAFT,
          expiresAt: { lt: now }
        },
        include: { slot: true }
      })

      bookingLogger.info(`Found ${expiredBookings.length} expired bookings`, { jobId })

      let cleaned = 0

      for (const booking of expiredBookings) {
        try {
          await prisma.$transaction(async (tx) => {
            await tx.booking.update({
              where: { id: booking.id },
              data: {
                status: BOOKING_STATUS.EXPIRED,
                paymentStatus: PAYMENT_STATUS.FAILED
              }
            })

            await tx.slot.update({
              where: { id: booking.slotId },
              data: { 
                status: SLOT_STATUS.AVAILABLE,
                lockedByUserId: null,
                lockedUntil: null
              }
            })

            cleaned++
          })

          // Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
          await notificationService.send({
            userId: booking.userId,
            type: 'BOOKING_EXPIRED',
            title: 'Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø­Ø¬Ø²',
            message: 'Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø­Ø¬Ø²ÙƒØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰',
            relatedId: booking.id
          })

        } catch (error: any) {
          bookingLogger.error(`Failed to clean up booking ${booking.id}`, {
            jobId,
            error: error.message
          })
        }
      }

      bookingLogger.info('Cleanup completed', {
        jobId,
        cleaned,
        durationMs: Date.now() - startTime
      })

      return { success: true, cleaned }

    } catch (error: any) {
      bookingLogger.error('Cleanup job failed', {
        jobId,
        error: error.message,
        durationMs: Date.now() - startTime
      })
      
      return { success: false, error: error.message }
    }
  }

  /**
   * ğŸ”“ 5. ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³Ù„Ø§Øª Ø§Ù„Ù…Ù‚ÙÙˆÙ„Ø© Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ©
   */
  static async cleanupExpiredLocks() {
    const startTime = Date.now()
    const jobId = `unlock_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

    bookingLogger.info('Starting expired locks cleanup', { jobId })

    try {
      const now = new Date()
      
      const result = await prisma.slot.updateMany({
        where: {
          status: SLOT_STATUS.TEMP_LOCKED,
          lockedUntil: { lt: now }
        },
        data: {
          status: SLOT_STATUS.AVAILABLE,
          lockedByUserId: null,
          lockedUntil: null
        }
      })

      bookingLogger.info('Locks cleanup completed', {
        jobId,
        unlockedSlots: result.count,
        durationMs: Date.now() - startTime
      })

      return { success: true, unlockedSlots: result.count }

    } catch (error: any) {
      bookingLogger.error('Locks cleanup failed', {
        jobId,
        error: error.message,
        durationMs: Date.now() - startTime
      })
      
      return { success: false, error: error.message }
    }
  }

  /**
   * ğŸ”’ Private helpers
   */

  private static async sendPostTransactionNotifications(
    booking: any,
    success: boolean,
    paymentDetails: any
  ): Promise<void> {
    try {
      if (success) {
        await notificationService.send({
          userId: booking.userId,
          type: 'PAYMENT_SUCCESS',
          title: 'ØªÙ… Ø§Ù„Ø¯ÙØ¹ Ø¨Ù†Ø¬Ø§Ø­',
          message: `ØªÙ… ØªØ£ÙƒÙŠØ¯ Ø­Ø¬Ø²Ùƒ ÙÙŠ ${booking.field.name} Ø¨ØªØ§Ø±ÙŠØ® ${new Date(booking.slot.startTime).toLocaleDateString('ar-EG')}`,
          relatedId: booking.id,
          data: {
            amount: paymentDetails.amount,
            fieldName: booking.field.name,
            date: booking.slot.startTime
          }
        })
      } else {
        await notificationService.send({
          userId: booking.userId,
          type: 'PAYMENT_FAILED',
          title: 'ÙØ´Ù„ Ø§Ù„Ø¯ÙØ¹',
          message: 'ÙØ´Ù„Øª Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¯ÙØ¹ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰',
          relatedId: booking.id
        })
      }
    } catch (error: any) {
      bookingLogger.error('Failed to send notifications', {
        error: error.message,
        bookingId: booking.id
      })
      // Ù„Ø§ ØªØ±Ù…ÙŠ error - notifications ÙØ´Ù„Øª Ù„ÙƒÙ† Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ù†Ø¬Ø­Øª
    }
  }

  private static canBookDirectly(start: Date): boolean {
    const diffMs = start.getTime() - Date.now()
    const diffHours = diffMs / (1000 * 60 * 60)
    return diffHours >= 24
  }
}
export const bookingOrchestrator = new BookingOrchestrator()
// lib/application/jobs/unlock-slots.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { SLOT_STATUS, BOOKING_STATUS } from '@/lib/shared/constants'   // âœ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ BOOKING_STATUS
import { bookingLogger } from '@/lib/shared/logger'
import { DomainError } from '@/lib/core/errors/domain-errors'

export async function unlockSlotsJob() {
  const jobId = `unlock_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  bookingLogger.info('ğŸ”“ Starting unlock slots job...', { jobId })
  
  const now = new Date()
  let unlockedCount = 0
  let orphanedCount = 0
  let errorsCount = 0

  try {
    // 1. Find expired TEMP_LOCKED slots
    const expiredSlots = await prisma.slot.findMany({
      where: {
        status: SLOT_STATUS.TEMP_LOCKED,
        lockedUntil: { lt: now }
      },
      include: {
        lockedByUser: { select: { id: true, email: true, name: true } },
        field: { select: { id: true, name: true } }
      }
    })

    bookingLogger.info(`ğŸ“Š Found ${expiredSlots.length} expired locked slots`, {
      jobId,
      count: expiredSlots.length
    })

    if (expiredSlots.length > 0) {
      bookingLogger.debug('ğŸ“ Expired slots details:', {
        jobId,
        slots: expiredSlots.map(slot => ({
          id: slot.id,
          startTime: slot.startTime,
          userId: slot.lockedByUserId,
          userEmail: slot.lockedByUser?.email,
          fieldName: slot.field?.name,
          lockedUntil: slot.lockedUntil
        }))
      })
    }

    const result = await prisma.slot.updateMany({
      where: { status: SLOT_STATUS.TEMP_LOCKED, lockedUntil: { lt: now } },
      data: { status: SLOT_STATUS.AVAILABLE, lockedByUserId: null, lockedUntil: null }
    })

    unlockedCount = result.count
    
    bookingLogger.info(`ğŸ”“ Unlocked ${unlockedCount} expired slots`, { jobId, unlockedCount })

    // 4. Also check for orphaned locks (no booking)
    const orphanedSlots = await prisma.slot.findMany({
      where: {
        status: SLOT_STATUS.TEMP_LOCKED,
        bookings: {
          none: {
            status: { in: [BOOKING_STATUS.DRAFT, BOOKING_STATUS.PENDING_PAYMENT] }   // âœ… Ø§Ø³ØªØ®Ø¯Ø§Ù… BOOKING_STATUS
          }
        }
      },
      include: { field: { select: { id: true, name: true } } }
    })

    if (orphanedSlots.length > 0) {
      bookingLogger.warn(`âš ï¸ Found ${orphanedSlots.length} orphaned locked slots`, {
        jobId,
        orphanedCount: orphanedSlots.length,
        orphanedSlots: orphanedSlots.map(s => ({
          id: s.id,
          field: s.field?.name,
          startTime: s.startTime
        }))
      })
      
      const orphanedResult = await prisma.slot.updateMany({
        where: { id: { in: orphanedSlots.map(s => s.id) } },
        data: { status: SLOT_STATUS.AVAILABLE, lockedByUserId: null, lockedUntil: null }
      })

      orphanedCount = orphanedResult.count
      
      bookingLogger.info(`ğŸ”„ Unlocked ${orphanedCount} orphaned slots`, { jobId, orphanedCount })
    }

    const totalUnlocked = unlockedCount + orphanedCount
    const jobDuration = Date.now() - now.getTime()
    
    bookingLogger.info('âœ… Unlock slots job completed', {
      jobId,
      durationMs: jobDuration,
      stats: {
        expiredSlotsFound: expiredSlots.length,
        unlockedExpiredSlots: unlockedCount,
        orphanedSlotsFound: orphanedSlots.length,
        unlockedOrphanedSlots: orphanedCount,
        totalUnlocked,
        errors: errorsCount
      }
    })

    return {
      success: true,
      stats: {
        unlockedSlots: totalUnlocked,
        orphanedSlots: orphanedCount,
        expiredSlots: expiredSlots.length,
        timestamp: now.toISOString(),
        durationMs: jobDuration
      }
    }

  } catch (error: any) {
    bookingLogger.error('âŒ Fatal error in unlock slots job', {
      jobId,
      error: error.message,
      stack: error.stack
    })
    
    throw new DomainError('INTERNAL_ERROR', `Job failed: ${error.message}`)
  }
}

export async function runUnlockSlotsJob() {
  const requestId = `run_unlock_${Date.now()}`
  
  try {
    bookingLogger.info('Starting scheduled unlock slots job', { requestId })
    
    const result = await unlockSlotsJob()
    
    bookingLogger.info('âœ… Scheduled unlock slots job completed', { requestId, result })
    
    return result
  } catch (error: any) {
    bookingLogger.error('âŒ Scheduled unlock slots job failed', {
      requestId,
      error: error.message,
      stack: error.stack
    })
    
    return { 
      success: false, 
      error: error.message,
      timestamp: new Date().toISOString()
    }
  }
}
// lib/application/jobs/expire-bookings.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { 
  BOOKING_STATUS, 
  PAYMENT_STATUS,
  SLOT_STATUS 
} from '@/lib/shared/constants'
import { bookingLogger } from '@/lib/shared/logger'
import { DomainError } from '@/lib/core/errors/domain-errors'

export async function expireBookingsJob() {
  const jobId = `expire_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  bookingLogger.info('ğŸš€ Starting expire bookings job...', { jobId })
  
  const now = new Date()
  let expiredCount = 0
  let unlockedSlots = 0
  let errorsCount = 0

  try {
    // 1. Find expired DRAFT bookings
    const expiredBookings = await prisma.booking.findMany({
      where: {
        status: BOOKING_STATUS.DRAFT,
        expiresAt: { lt: now }
      },
      include: {
        slot: true,
        user: {
          select: { id: true, email: true, name: true }
        }
      }
    })

    bookingLogger.info(`ğŸ“Š Found ${expiredBookings.length} expired bookings`, { 
      jobId,
      count: expiredBookings.length 
    })

    // 2. Process each booking
    for (const booking of expiredBookings) {
      try {
        const startTime = Date.now()
        
        await prisma.$transaction(async (tx) => {
          // Update booking
          await tx.booking.update({
            where: { id: booking.id },
            data: {
              status: BOOKING_STATUS.EXPIRED,
              paymentStatus: PAYMENT_STATUS.FAILED
            }
          })

          // Unlock slot
          await tx.slot.update({
            where: { id: booking.slotId },
            data: {
              status: SLOT_STATUS.AVAILABLE,
              lockedByUserId: null,
              lockedUntil: null
            }
          })

          // Create notification
          await tx.notification.create({
            data: {
              userId: booking.userId,
              type: 'BOOKING_EXPIRED',
              title: 'Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø­Ø¬Ø²',
              message: `Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø­Ø¬Ø²Ùƒ ÙÙŠ ${booking.slot.startTime.toLocaleDateString('ar-EG')}`,
              relatedId: booking.id,
              data: {
                slotTime: booking.slot.startTime,
                fieldId: booking.slot.fieldId
              }
            }
          })
        })

        const duration = Date.now() - startTime
        
        bookingLogger.debug('Booking expired successfully', {
          jobId,
          bookingId: booking.id,
          userId: booking.userId,
          userEmail: booking.user?.email,
          slotId: booking.slotId,
          durationMs: duration
        })

        expiredCount++
        unlockedSlots++

      } catch (error: any) {
        errorsCount++
        bookingLogger.error(`âŒ Error processing booking ${booking.id}`, {
          jobId,
          bookingId: booking.id,
          error: error.message,
          stack: error.stack
        })
      }
    }

    // 3. Cleanup old expired bookings (older than 7 days)
    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
    
    const deleted = await prisma.booking.deleteMany({
      where: {
        status: BOOKING_STATUS.EXPIRED,
        updatedAt: { lt: sevenDaysAgo }
      }
    })

    bookingLogger.info(`ğŸ—‘ï¸ Deleted ${deleted.count} old expired bookings`, {
      jobId,
      deletedCount: deleted.count,
      cutoffDate: sevenDaysAgo.toISOString()
    })

    // 4. Ø¥Ø­ØµØ§Ø¡Ø§Øª Ø§Ù„Ù†Ù‡Ø§ÙŠØ©
    const jobDuration = Date.now() - now.getTime()
    
    bookingLogger.info('âœ… Expire bookings job completed', {
      jobId,
      durationMs: jobDuration,
      stats: {
        totalFound: expiredBookings.length,
        successfullyExpired: expiredCount,
        unlockedSlots,
        deletedOldBookings: deleted.count,
        errors: errorsCount,
        successRate: expiredBookings.length > 0 ? 
          ((expiredCount / expiredBookings.length) * 100).toFixed(2) + '%' : 'N/A'
      }
    })

    return {
      success: true,
      stats: {
        expiredBookings: expiredCount,
        unlockedSlots,
        deletedOld: deleted.count,
        errors: errorsCount,
        timestamp: now.toISOString(),
        durationMs: jobDuration
      }
    }

  } catch (error: any) {
    bookingLogger.error('âŒ Fatal error in expire bookings job', {
      jobId,
      error: error.message,
      stack: error.stack
    })
    
    throw new DomainError('INTERNAL_ERROR', `Job failed: ${error.message}`)
  }
}

// For cron/API usage
export async function runExpireBookingsJob() {
  const requestId = `run_expire_${Date.now()}`
  
  try {
    bookingLogger.info('Starting scheduled expire bookings job', { requestId })
    
    const result = await expireBookingsJob()
    
    bookingLogger.info('âœ… Scheduled expire bookings job completed', {
      requestId,
      result
    })
    
    return result
  } catch (error: any) {
    bookingLogger.error('âŒ Scheduled expire bookings job failed', {
      requestId,
      error: error.message,
      stack: error.stack
    })
    
    return { 
      success: false, 
      error: error.message,
      timestamp: new Date().toISOString()
    }
  }
}
// lib/application/idempotency/idempotency-guard.ts
import { prisma } from '@/lib/infrastructure/database/prisma'
import { addMinutes } from 'date-fns'
import crypto from 'crypto'

export class IdempotencyGuard {
  /**
   * ğŸ” ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø¹Ù…Ù„ÙŠØ© idempotent
   * @param key Ø§Ù„Ù…ÙØªØ§Ø­ Ø§Ù„ÙØ±ÙŠØ¯
   * @param userId Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
   * @param method Ø§Ø³Ù… Ø§Ù„Ø¹Ù…Ù„ÙŠØ©
   * @param requestData Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø¨ (Ù„ØªØ¬Ù†Ø¨ Ù†ÙØ³ Ø§Ù„Ø·Ù„Ø¨ Ø¨Ù…Ø¹Ø·ÙŠØ§Øª Ù…Ø®ØªÙ„ÙØ©)
   * @returns {idempotent: boolean, response?: any, shouldProceed: boolean}
   */
  static async check(
    key: string,
    userId: string,
    method: string,
    requestData?: any
  ): Promise<{
    idempotent: boolean
    response?: any
    shouldProceed: boolean
  }> {
    const now = new Date()
    
    // 1. ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ©
    await prisma.idempotencyKey.deleteMany({
      where: { expiresAt: { lt: now } }
    }).catch(() => {
      // ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ÙÙŠ Ø§Ù„ØªÙ†Ø¸ÙŠÙ
    })

    try {
      // 2. Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…ÙØªØ§Ø­ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… key Ùˆ userId
      const existing = await prisma.idempotencyKey.findFirst({
        where: { 
          AND: [
            { key },
            { userId }
          ]
        }
      })

      if (!existing) {
        return { idempotent: false, shouldProceed: true }
      }

      // 3. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø·Ø±ÙŠÙ‚Ø©
      if (existing.method !== method) {
        throw new Error('Ù…ÙØªØ§Ø­ idempotency ØºÙŠØ± ØµØ§Ù„Ø­ Ù„Ù‡Ø°Ø§ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©')
      }

      // 4. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† requestHash Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
      if (requestData && existing.requestHash) {
        const currentHash = this.hashRequest(requestData)
        if (currentHash !== existing.requestHash) {
          throw new Error('Ø·Ù„Ø¨ Ù…ÙƒØ±Ø± Ø¨Ù…Ø¹Ø·ÙŠØ§Øª Ù…Ø®ØªÙ„ÙØ©')
        }
      }

      // 5. Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ response Ù…Ø®Ø²Ù†
      if (existing.response) {
        return {
          idempotent: true,
          response: existing.response,
          shouldProceed: false
        }
      }

      // 6. Ø§Ù„Ù…ÙØªØ§Ø­ Ù…ÙˆØ¬ÙˆØ¯ ÙˆÙ„ÙƒÙ† Ø¨Ø¯ÙˆÙ† response (Ù…Ø§Ø²Ø§Ù„ ÙŠØ¹Ù…Ù„)
      return { idempotent: true, shouldProceed: false }

    } catch (error) {
      console.error('Idempotency check error:', error)
      return { idempotent: false, shouldProceed: true }
    }
  }

  /**
   * ğŸ’¾ Ø­ÙØ¸ Ù†ØªÙŠØ¬Ø© idempotent
   */
  static async saveResponse(
    key: string,
    userId: string,
    method: string,
    response: any,
    requestData?: any,
    ttlMinutes: number = 60
  ) {
    // âœ… Ø¥ØµÙ„Ø§Ø­: Ø§Ø³ØªØ®Ø¯Ù… Ù‚ÙŠÙ…Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù„Ù€ requestHash
    const requestHash = requestData ? this.hashRequest(requestData) : ''
    
    try {
      return await prisma.idempotencyKey.upsert({
        where: {
          key_userId: {
            key,
            userId
          }
        },
        update: {
          response,
          expiresAt: addMinutes(new Date(), ttlMinutes)
        },
        create: {
          key,
          userId,
          method,
          requestHash, // âœ… Ø§Ù„Ø¢Ù† string ÙˆÙ„ÙŠØ³ null
          response,
          expiresAt: addMinutes(new Date(), ttlMinutes)
        }
      })
    } catch (error) {
      console.error('Failed to save idempotency response:', error)
      // âœ… Ø¥ØµÙ„Ø§Ø­: Ø¥Ø±Ø¬Ø§Ø¹ Ù‚ÙŠÙ…Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
      return null
    }
  }

  /**
   * ğŸ”¢ ØªÙˆÙ„ÙŠØ¯ Ù…ÙØªØ§Ø­ Ø¢Ù…Ù†
   */
  static generateKey(prefix: string = 'req'): string {
    const timestamp = Date.now()
    const random = crypto.randomBytes(16).toString('hex')
    return `${prefix}_${timestamp}_${random}`
  }

  /**
   * ğŸ” Ø­Ø³Ø§Ø¨ Ù‡Ø§Ø´ Ù„Ù„Ø·Ù„Ø¨ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… SHA-256
   */
  private static hashRequest(data: any): string {
    const str = JSON.stringify(data, Object.keys(data).sort())
    return crypto.createHash('sha256').update(str).digest('hex')
  }
}

// middleware.ts
import { NextRequest, NextResponse } from 'next/server'
import { getToken } from 'next-auth/jwt'

// âœ… Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø© (Ù…Ø³Ù…ÙˆØ­ Ù„Ù„Ø¬Ù…ÙŠØ¹)
const PUBLIC_PATHS = [
  '/',
  '/login', 
  '/register',
  '/about',
  '/contact',
  '/api/auth',
  '/api/auth/register',
  '/api/fields' // Ù„Ù„Ø³Ù…Ø§Ø­ Ø¨Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù„Ø§Ø¹Ø¨ Ù„Ù„Ø¬Ù…ÙŠØ¹
]

// âœ… Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø­Ù…ÙŠØ© (ØªØ­ØªØ§Ø¬ Ù…ØµØ§Ø¯Ù‚Ø©)
const PROTECTED_PATHS = [
  '/dashboard/admin',
  '/dashboard/owner',
  '/dashboard/employee',
  '/dashboard/player',
  '/api/bookings',
  '/api/payments',
  '/api/fields/[id]/slots/[slotid]/lock'
]

// âœ… Ù…Ø³Ø§Ø±Ø§Øª API Ø§Ù„ØªÙŠ ØªØ­ØªØ§Ø¬ Ù…ØµØ§Ø¯Ù‚Ø©
const PROTECTED_API_PATHS = [
  '/api/bookings',
  '/api/payments'
]

// âœ… Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø©
const isPublicPath = (pathname: string): boolean => {
  return PUBLIC_PATHS.some(path => 
    pathname === path || 
    pathname.startsWith(`${path}/`) ||
    // Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ ØµÙØ­Ø§Øª Ø§Ù„Ù…Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø¹Ø§Ù…Ø©
    pathname.startsWith('/fields')
  )
}

const isProtectedPath = (pathname: string): boolean => {
  return PROTECTED_PATHS.some(path => 
    pathname.startsWith(path)
  )
}

const isProtectedApiPath = (pathname: string): boolean => {
  return PROTECTED_API_PATHS.some(path => 
    pathname.startsWith(path)
  )
}

// âœ… Rate limiting Ø¨Ø³Ø§Ø·Ø©
const rateLimitStore = new Map<string, { count: number; timestamp: number }>()

function checkRateLimit(pathname: string, ip: string): boolean {
  const key = `${ip}:${pathname}`
  const now = Date.now()
  const windowMs = 60 * 1000 // 1 Ø¯Ù‚ÙŠÙ‚Ø©
  const max = 100 // 100 Ø·Ù„Ø¨ ÙÙŠ Ø§Ù„Ø¯Ù‚ÙŠÙ‚Ø©
  
  const entry = rateLimitStore.get(key)
  
  if (entry && now - entry.timestamp < windowMs) {
    if (entry.count >= max) {
      return false
    }
    entry.count++
    rateLimitStore.set(key, entry)
  } else {
    rateLimitStore.set(key, { count: 1, timestamp: now })
  }
  
  // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
  if (rateLimitStore.size > 1000) {
    for (const [k, v] of rateLimitStore.entries()) {
      if (now - v.timestamp > windowMs) {
        rateLimitStore.delete(k)
      }
    }
  }
  
  return true
}

// âœ… Middleware Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
export default async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl
  const ip = request.headers.get('x-forwarded-for') || 'unknown'
  
  // 1. ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ© ÙˆØ§Ù„Ø£ØµÙˆÙ„ Ø§Ù„Ø«Ø§Ø¨ØªØ©
  if (
    pathname.startsWith('/_next') ||
    pathname.startsWith('/_next/static') ||
    pathname.startsWith('/_next/image') ||
    pathname.includes('.') || // Ø§Ù„Ù…Ù„ÙØ§Øª Ù…Ø«Ù„ .js, .css, .png
    pathname === '/favicon.ico'
  ) {
    return NextResponse.next()
  }
  
  // 2. Rate Limiting Ù„Ù€ API
  if (pathname.startsWith('/api/')) {
    if (!checkRateLimit(pathname, ip)) {
      return new NextResponse(
        JSON.stringify({ 
          error: 'RATE_LIMITED', 
          message: 'Ù„Ù‚Ø¯ ØªØ¬Ø§ÙˆØ²Øª Ø§Ù„Ø­Ø¯ Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡ Ù…Ù† Ø§Ù„Ø·Ù„Ø¨Ø§Øª' 
        }),
        { status: 429, headers: { 'Content-Type': 'application/json' } }
      )
    }
  }
  
  // 3. Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ token
  const token = await getToken({ 
    req: request, 
    secret: process.env.NEXTAUTH_SECRET 
  })
  
  // 4. Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø© (Ù…Ø³Ù…ÙˆØ­ Ù„Ù„Ø¬Ù…ÙŠØ¹)
  if (isPublicPath(pathname)) {
    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø³Ø¬Ù„ ÙˆÙŠØ­Ø§ÙˆÙ„ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù€ /login Ø£Ùˆ /register
    if (token && (pathname === '/login' || pathname === '/register')) {
      return NextResponse.redirect(new URL('/dashboard', request.url))
    }
    return NextResponse.next()
  }
  
  // 5. Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø­Ù…ÙŠØ© (ØªØ­ØªØ§Ø¬ Ù…ØµØ§Ø¯Ù‚Ø©)
  if (isProtectedPath(pathname) || isProtectedApiPath(pathname)) {
    // Ø£. ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…Ø³Ø¬Ù„
    if (!token) {
      const loginUrl = new URL('/login', request.url)
      loginUrl.searchParams.set('redirect', pathname)
      return NextResponse.redirect(loginUrl)
    }
    
    // Ø¨. ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ ØºÙŠØ± Ù†Ø´Ø·
    if (token.isActive === false) {
      const loginUrl = new URL('/login', request.url)
      loginUrl.searchParams.set('error', 'account_inactive')
      return NextResponse.redirect(loginUrl)
    }
    
    // Ø¬. ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ù„Ù„Ù€ admin routes
    const userRole = token.role as string
    
    // Ø¥Ø°Ø§ Ø­Ø§ÙˆÙ„ Ù„Ø§Ø¹Ø¨ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù€ /dashboard/admin
    if (pathname.startsWith('/dashboard/admin') && userRole !== 'ADMIN') {
      return NextResponse.redirect(new URL('/dashboard/player', request.url))
    }
    
    // Ø¥Ø°Ø§ Ø­Ø§ÙˆÙ„ Ù„Ø§Ø¹Ø¨ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù€ /dashboard/owner
    if (pathname.startsWith('/dashboard/owner') && userRole !== 'OWNER') {
      return NextResponse.redirect(new URL('/dashboard/player', request.url))
    }
    
    // Ø¥Ø°Ø§ Ø­Ø§ÙˆÙ„ Ù„Ø§Ø¹Ø¨ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù€ /dashboard/employee
    if (pathname.startsWith('/dashboard/employee') && userRole !== 'EMPLOYEE') {
      return NextResponse.redirect(new URL('/dashboard/player', request.url))
    }
    
    return NextResponse.next()
  }
  
  // 6. Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ `/dashboard` (ØµÙØ­Ø© ØªÙˆØ¬ÙŠÙ‡)
  if (pathname === '/dashboard') {
    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…Ø³Ø¬Ù„
    if (!token) {
      const loginUrl = new URL('/login', request.url)
      loginUrl.searchParams.set('redirect', '/dashboard')
      return NextResponse.redirect(loginUrl)
    }
    
    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ø³Ø¬Ù„Ø§Ù‹ØŒ Ø¯Ø¹ Ø§Ù„Ù€ page.tsx ÙŠØªÙˆÙ„Ù‰ Ø§Ù„ØªÙˆØ¬ÙŠÙ‡ Ø­Ø³Ø¨ Ø§Ù„Ø±ÙˆÙ„
    return NextResponse.next()
  }
  
  // 7. Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ø¨Ø§Ù‚ÙŠ (Ù…Ø«Ù„ ØµÙØ­Ø§Øª Ø§Ù„Ù…Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø¹Ø§Ù…Ø©)
  return NextResponse.next()
}

export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public folder
     */
    '/((?!_next/static|_next/image|favicon.ico).*)',
  ],
}
// components/booking/slots-mapper.ts
import { Day, SlotStatus } from '@/lib/core/types'

export interface ApiSlot {
  id: string
  day: Day                // âœ… Ø§Ø³ØªØ®Ø¯Ù…Ù†Ø§ Day Ù‡Ù†Ø§
  startTime: string
  endTime: string
  status: SlotStatus
  price: number
  deposit: number
}

export interface UISlot {
  id: string
  day: Day                // âœ… ÙˆÙ‡Ù†Ø§ ÙƒÙ…Ø§Ù†
  startTime: Date
  endTime: Date
  status: SlotStatus
  uiStatus: 'AVAILABLE' | 'BOOKED' | 'LOCKED_ME' | 'LOCKED_OTHER' | 'UNAVAILABLE'
  needsConfirmation: boolean
  price: number
  deposit: number
  metadata?: {
    needsConfirmation?: boolean
    [key: string]: any
  }
}

export function mapApiSlotsToUI(slots: ApiSlot[], userId?: string): UISlot[] {
  return slots.map(slot => {
    const needsConfirmation = slot.status === 'AVAILABLE_NEEDS_CONFIRM'

    let uiStatus: UISlot['uiStatus'] = 'UNAVAILABLE'

    switch (slot.status) {
      case 'AVAILABLE':
        uiStatus = 'AVAILABLE'
        break
      case 'AVAILABLE_NEEDS_CONFIRM':
        uiStatus = 'AVAILABLE'
        break
      case 'BOOKED':
        uiStatus = 'BOOKED'
        break
      case 'TEMP_LOCKED':
        uiStatus = userId ? 'LOCKED_ME' : 'LOCKED_OTHER'
        break
      default:
        uiStatus = 'UNAVAILABLE'
    }

    return {
      id: slot.id,
      day: slot.day, // âœ… Ù†Ù…Ø±Ø± Ù‚ÙŠÙ…Ø© Ø§Ù„ÙŠÙˆÙ… Ù…Ù† Ø§Ù„Ù€ API
      startTime: new Date(slot.startTime),
      endTime: new Date(slot.endTime),
      status: slot.status,
      uiStatus,
      needsConfirmation,
      price: slot.price,
      deposit: slot.deposit,
      metadata: {
        needsConfirmation
      }
    }
  })
}
// components/booking/slot-grid.tsx
'use client'

import { useState } from 'react'
import { Clock, Lock, CheckCircle, AlertCircle } from 'lucide-react'
import SlotBookingModal from './slot-booking-modal'
import { SlotGridProps } from '@/lib/core/types'

export default function SlotGrid({ 
  slots, 
  fieldId, 
  fieldName, 
  onSlotSelect 
}: SlotGridProps) {
  const [selectedSlot, setSelectedSlot] = useState<any | null>(null)

  const handleSlotClick = (slot: any) => {
    if (slot.uiStatus === 'AVAILABLE') {
      setSelectedSlot(slot)
      if (onSlotSelect) {
        onSlotSelect(slot)
      }
    }
  }

  const getSlotVariant = (slot: any) => {
    switch (slot.uiStatus) {
      case 'AVAILABLE':
        return {
          bg: 'bg-gradient-to-br from-green-50 to-green-100',
          border: 'border-green-200',
          text: 'text-green-800',
          hover: 'hover:from-green-100 hover:to-green-200 hover:border-green-300 hover:shadow-md hover:scale-[1.02]',
          icon: <Clock className="w-4 h-4" />,
          label: 'Ù…ØªØ§Ø­'
        }
      case 'LOCKED_ME':
        return {
          bg: 'bg-gradient-to-br from-blue-50 to-blue-100',
          border: 'border-blue-200',
          text: 'text-blue-800',
          hover: 'hover:from-blue-100 hover:to-blue-200 hover:border-blue-300',
          icon: <Lock className="w-4 h-4" />,
          label: 'Ù…Ù‚ÙÙˆÙ„ Ù„Ùƒ'
        }
      case 'LOCKED_OTHER':
        return {
          bg: 'bg-gradient-to-br from-gray-100 to-gray-200',
          border: 'border-gray-300',
          text: 'text-gray-600',
          hover: '',
          icon: <Lock className="w-4 h-4" />,
          label: 'Ù…Ø­Ø¬ÙˆØ²'
        }
      case 'BOOKED':
        return {
          bg: 'bg-gradient-to-br from-red-50 to-red-100',
          border: 'border-red-200',
          text: 'text-red-600',
          hover: '',
          icon: <CheckCircle className="w-4 h-4" />,
          label: 'Ù…Ø­Ø¬ÙˆØ²'
        }
      default:
        return {
          bg: 'bg-gray-100',
          border: 'border-gray-300',
          text: 'text-gray-500',
          hover: '',
          icon: null,
          label: 'ØºÙŠØ± Ù…ØªØ§Ø­'
        }
    }
  }

  // ØªØµÙÙŠØ© Ø§Ù„Ø³Ø§Ø¹Ø§Øª Ø­Ø³Ø¨ ÙØªØ±Ø© Ø§Ù„ÙŠÙˆÙ…
  const morningSlots = slots.filter((slot: any) => 
    new Date(slot.startTime).getHours() < 12
  )
  const afternoonSlots = slots.filter((slot: any) => 
    new Date(slot.startTime).getHours() >= 12 && 
    new Date(slot.startTime).getHours() < 17
  )
  const eveningSlots = slots.filter((slot: any) => 
    new Date(slot.startTime).getHours() >= 17
  )

  const renderTimeSlot = (slot: any) => {
    const variant = getSlotVariant(slot)
    const isAvailable = slot.uiStatus === 'AVAILABLE'
    const timeString = new Date(slot.startTime).toLocaleTimeString('ar-EG', {
      hour: '2-digit',
      minute: '2-digit',
      hour12: true
    })

    return (
      <button
        key={slot.id}
        onClick={() => handleSlotClick(slot)}
        disabled={!isAvailable}
        className={`
          relative flex flex-col items-center justify-center p-4 rounded-xl
          ${variant.bg} ${variant.border} border ${variant.text}
          transition-all duration-200 ${variant.hover}
          disabled:opacity-50 disabled:cursor-not-allowed
          group min-h-[120px]
        `}
      >
        <div className="flex items-center gap-2 mb-2">
          {variant.icon}
          <span className="font-bold">{timeString}</span>
        </div>
        
        <div className="text-sm font-medium mb-1">{variant.label}</div>
        
        {slot.needsConfirmation && (
          <div className="absolute -top-2 -right-2">
            <div className="bg-amber-500 text-white text-xs px-2 py-1 rounded-full flex items-center gap-1">
              <AlertCircle className="w-3 h-3" />
              <span>ØªØ£ÙƒÙŠØ¯</span>
            </div>
          </div>
        )}
        
        {isAvailable && (
          <div className="mt-2">
            <div className="text-lg font-bold">{slot.price} Ø¬.Ù…</div>
            <div className="text-xs opacity-75">Ø¹Ø±Ø¨ÙˆÙ† {slot.deposit} Ø¬.Ù…</div>
          </div>
        )}
        
        {/* Hover Effect */}
        {isAvailable && (
          <div className="absolute inset-0 bg-gradient-to-br from-primary-500/10 to-transparent opacity-0 group-hover:opacity-100 rounded-xl transition-opacity"></div>
        )}
      </button>
    )
  }

  const renderSection = (title: string, slotsArray: any[], colorClass: string) => {
    if (slotsArray.length === 0) return null
    
    return (
      <div>
        <h4 className="text-lg font-bold text-gray-900 mb-4 flex items-center gap-2">
          <div className={`w-2 h-2 ${colorClass} rounded-full`}></div>
          {title}
        </h4>
        <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-3">
          {slotsArray.map(renderTimeSlot)}
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-8">
      {/* Morning Slots */}
      {renderSection("ÙØªØ±Ø© Ø§Ù„ØµØ¨Ø§Ø­", morningSlots, "bg-amber-500")}

      {/* Afternoon Slots */}
      {renderSection("ÙØªØ±Ø© Ø§Ù„Ø¸Ù‡ÙŠØ±Ø©", afternoonSlots, "bg-orange-500")}

      {/* Evening Slots */}
      {renderSection("ÙØªØ±Ø© Ø§Ù„Ù…Ø³Ø§Ø¡", eveningSlots, "bg-purple-500")}

      {/* No Slots Message */}
      {slots.length === 0 && (
        <div className="text-center py-12 bg-gradient-to-br from-gray-50 to-gray-100 rounded-2xl">
          <Clock className="w-16 h-16 text-gray-400 mx-auto mb-4" />
          <h3 className="text-xl font-semibold text-gray-700 mb-2">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…ÙˆØ§Ø¹ÙŠØ¯ Ù…ØªØ§Ø­Ø©</h3>
          <p className="text-gray-500">Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯ Ù…Ø­Ø¬ÙˆØ²Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„ÙŠÙˆÙ…</p>
        </div>
      )}

      {/* Booking Modal */}
      {selectedSlot && (
        <SlotBookingModal
          slot={selectedSlot}
          fieldId={fieldId}
          fieldName={fieldName}
          onClose={() => setSelectedSlot(null)}
        />
      )}
    </div>
  )
}

// components/booking/slot-booking-modal.tsx
'use client'

import { X, Clock, MapPin, CreditCard, Shield, AlertCircle, Loader2, CheckCircle } from 'lucide-react'
import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { useSession } from 'next-auth/react'
import { IdempotencyGuard } from '@/lib/application/idempotency/idempotency-guard'
import { SlotBookingModalProps } from '@/lib/core/types'

export default function SlotBookingModal({ slot, fieldId, fieldName, onClose }: SlotBookingModalProps) {
  const { data: session } = useSession()
  const router = useRouter()
  const [isBooking, setIsBooking] = useState(false)
  const [step, setStep] = useState(1)
  const [error, setError] = useState<string | null>(null)

  const handleBook = async () => {
    if (!session) {
      router.push('/login?callbackUrl=' + encodeURIComponent(window.location.pathname))
      return
    }

    // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ userId Ù…Ù† Ø§Ù„Ù€ session
    const userId = session.user?.id
    
    setIsBooking(true)
    setError(null)
    setStep(2)

    try {
      // ØªÙˆÙ„ÙŠØ¯ Ù…ÙØªØ§Ø­ idempotency Ø¢Ù…Ù†
      const idempotencyKey = IdempotencyGuard.generateKey('booking')

      // 1. Ù‚ÙÙ„ Ø§Ù„Ù€ Slot
      const lockResponse = await fetch(`/api/fields/${fieldId}/slots/${slot.id}/lock`, {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ userId })
      })

      if (!lockResponse.ok) {
        const err = await lockResponse.json()
        throw new Error(err.error || 'ÙØ´Ù„ ÙÙŠ Ù‚ÙÙ„ Ø§Ù„Ù…ÙˆØ¹Ø¯. Ù‚Ø¯ ÙŠÙƒÙˆÙ† ØªÙ… Ø­Ø¬Ø²Ù‡ Ø¨ÙˆØ§Ø³Ø·Ø© Ø´Ø®Øµ Ø¢Ø®Ø±.')
      }

      // 2. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø¬Ø²
      const response = await fetch('/api/bookings', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          slotId: slot.id,
          fieldId,
          userId,
          startTime: slot.startTime,
          endTime: slot.endTime,
          price: slot.price,
          deposit: slot.deposit,
          idempotencyKey
        })
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || data.message || 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­Ø¬Ø²')
      }

      setStep(3)
      
      setTimeout(() => {
        if (slot.needsConfirmation) {
          router.push('/bookings?status=pending')
        } else {
          router.push(`/payment?bookingId=${data.bookingId}`)
        }
        onClose()
      }, 1500)

    } catch (error: any) {
      console.error('Booking error:', error)
      setError(error.message || 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­Ø¬Ø². ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.')
      setStep(1)
    } finally {
      setIsBooking(false)
    }
  }

  const formatDate = (date: Date | string) => {
    const dateObj = typeof date === 'string' ? new Date(date) : date
    return dateObj.toLocaleDateString('ar-EG', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    })
  }

  const formatTime = (date: Date | string) => {
    const dateObj = typeof date === 'string' ? new Date(date) : date
    return dateObj.toLocaleTimeString('ar-EG', {
      hour: '2-digit',
      minute: '2-digit',
      hour12: true
    })
  }

  const getStepContent = () => {
    switch (step) {
      case 1:
        return (
          <>
            {/* Header */}
            <div className="flex items-center justify-between p-6 border-b border-gray-100">
              <div>
                <h3 className="text-xl font-bold text-gray-900">ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø¬Ø²</h3>
                <p className="text-gray-600 text-sm mt-1">Ø§Ù„Ø±Ø¬Ø§Ø¡ Ù…Ø±Ø§Ø¬Ø¹Ø© ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø­Ø¬Ø²</p>
              </div>
              <button
                onClick={onClose}
                className="p-2 hover:bg-gray-100 rounded-xl transition-colors"
                disabled={isBooking}
              >
                <X className="w-5 h-5 text-gray-500" />
              </button>
            </div>

            {/* Content */}
            <div className="p-6">
              {error && (
                <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-xl">
                  <div className="flex items-start gap-2">
                    <AlertCircle className="w-5 h-5 text-red-600 mt-0.5" />
                    <div>
                      <div className="font-medium text-red-800">Ø®Ø·Ø£</div>
                      <p className="text-red-700 text-sm mt-1">{error}</p>
                    </div>
                  </div>
                </div>
              )}

              <div className="mb-6">
                <h4 className="font-bold text-lg text-gray-900 mb-2">{fieldName}</h4>
                <p className="text-gray-600">Ù…Ù„Ø¹Ø¨ ÙƒØ±Ø© Ù‚Ø¯Ù… Ø§Ø­ØªØ±Ø§ÙÙŠ</p>
              </div>

              <div className="space-y-4">
                <div className="flex items-center gap-3 p-3 bg-gray-50 rounded-xl">
                  <Clock className="w-5 h-5 text-primary-500" />
                  <div>
                    <div className="font-medium text-gray-900">{formatDate(slot.startTime)}</div>
                    <div className="text-gray-600 text-sm">
                      Ù…Ù† {formatTime(slot.startTime)} Ø¥Ù„Ù‰ {formatTime(slot.endTime)}
                    </div>
                  </div>
                </div>

                <div className="flex items-center gap-3 p-3 bg-gray-50 rounded-xl">
                  <MapPin className="w-5 h-5 text-primary-500" />
                  <div>
                    <div className="font-medium text-gray-900">Ø§Ù„Ù…ÙˆÙ‚Ø¹</div>
                    <div className="text-gray-600 text-sm">Ù…Ø¯ÙŠÙ†Ø© Ù†ØµØ±ØŒ Ø§Ù„Ù‚Ø§Ù‡Ø±Ø©</div>
                  </div>
                </div>

                <div className="flex items-center gap-3 p-3 bg-gray-50 rounded-xl">
                  <CreditCard className="w-5 h-5 text-primary-500" />
                  <div className="flex-1">
                    <div className="font-medium text-gray-900">Ø§Ù„Ø³Ø¹Ø±</div>
                    <div className="flex justify-between items-center">
                      <div>
                        <span className="text-2xl font-bold text-gray-900">{slot.price}</span>
                        <span className="text-gray-600 mr-2">Ø¬.Ù…</span>
                      </div>
                      <div className="text-sm text-gray-600">
                        Ø¹Ø±Ø¨ÙˆÙ†: {slot.deposit} Ø¬.Ù…
                      </div>
                    </div>
                  </div>
                </div>

                {slot.needsConfirmation && (
                  <div className="p-3 bg-amber-50 border border-amber-200 rounded-xl">
                    <div className="flex items-start gap-2">
                      <AlertCircle className="w-5 h-5 text-amber-600 mt-0.5" />
                      <div>
                        <div className="font-medium text-amber-800">ÙŠØ­ØªØ§Ø¬ ØªØ£ÙƒÙŠØ¯</div>
                        <p className="text-amber-700 text-sm mt-1">
                          Ù‡Ø°Ø§ Ø§Ù„Ù…ÙˆØ¹Ø¯ ÙŠØ­ØªØ§Ø¬ ØªØ£ÙƒÙŠØ¯ Ù…Ù† Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù„Ø¹Ø¨. Ø³ÙŠØªÙ… Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ Ø®Ù„Ø§Ù„ 24 Ø³Ø§Ø¹Ø©.
                        </p>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </div>

            {/* Footer */}
            <div className="p-6 border-t border-gray-100">
              <div className="flex gap-3">
                <button
                  onClick={onClose}
                  disabled={isBooking}
                  className="flex-1 py-3 px-4 border border-gray-300 text-gray-700 rounded-xl font-medium hover:bg-gray-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  Ø¥Ù„ØºØ§Ø¡
                </button>
                <button
                  onClick={handleBook}
                  disabled={isBooking}
                  className="flex-1 py-3 px-4 rounded-xl font-bold text-white bg-gradient-to-r from-primary-500 to-primary-600 hover:from-primary-600 hover:to-primary-700 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-300 flex items-center justify-center gap-2"
                >
                  {isBooking ? (
                    <>
                      <Loader2 className="w-5 h-5 animate-spin" />
                      Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­Ø¬Ø²...
                    </>
                  ) : (
                    'ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø¬Ø²'
                  )}
                </button>
              </div>
              
              <div className="flex items-center justify-center gap-2 mt-4 text-sm text-gray-500">
                <Shield className="w-4 h-4" />
                <span>Ø¬Ù…ÙŠØ¹ Ø¨ÙŠØ§Ù†Ø§ØªÙƒ Ù…Ø­Ù…ÙŠØ© ÙˆØ¢Ù…Ù†Ø©</span>
              </div>
            </div>
          </>
        )
      
      case 2:
        return (
          <div className="p-8 text-center">
            <div className="relative w-20 h-20 mx-auto mb-6">
              <Loader2 className="w-20 h-20 text-primary-500 animate-spin" />
              <div className="absolute inset-0 flex items-center justify-center">
                <div className="w-8 h-8 bg-primary-500 rounded-full animate-ping"></div>
              </div>
            </div>
            <h3 className="text-xl font-bold text-gray-900 mb-2">Ø¬Ø§Ø±ÙŠ ØªØ£ÙƒÙŠØ¯ Ø­Ø¬Ø²Ùƒ</h3>
            <p className="text-gray-600">Ø¨Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø¨ÙŠÙ†Ù…Ø§ Ù†Ù‚ÙˆÙ… Ø¨ØªØ£Ù…ÙŠÙ† Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù„Ùƒ</p>
          </div>
        )
      
      case 3:
        return (
          <div className="p-8 text-center">
            <div className="w-20 h-20 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-6">
              <div className="w-12 h-12 bg-green-500 rounded-full flex items-center justify-center">
                <CheckCircle className="w-8 h-8 text-white" />
              </div>
            </div>
            <h3 className="text-xl font-bold text-gray-900 mb-2">ØªÙ… Ø­Ø¬Ø² Ø§Ù„Ù…ÙˆØ¹Ø¯ Ø¨Ù†Ø¬Ø§Ø­!</h3>
            <p className="text-gray-600 mb-6">
              {slot.needsConfirmation 
                ? 'Ø³ÙŠØªÙ… Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ Ù„ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø¬Ø² Ø®Ù„Ø§Ù„ 24 Ø³Ø§Ø¹Ø©' 
                : 'Ø³ÙŠØªÙ… ØªÙˆØ¬ÙŠÙ‡Ùƒ Ø¥Ù„Ù‰ ØµÙØ­Ø© Ø§Ù„Ø¯ÙØ¹ Ø®Ù„Ø§Ù„ Ù„Ø­Ø¸Ø§Øª'
              }
            </p>
            <div className="w-12 h-1 bg-primary-500 rounded-full mx-auto animate-pulse"></div>
          </div>
        )
      
      default:
        return null
    }
  }

  return (
    <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4 backdrop-blur-sm">
      <div className="bg-white rounded-2xl max-w-md w-full shadow-2xl animate-in zoom-in-95">
        {getStepContent()}
      </div>
    </div>
  )
}

// components/booking/day-selector.tsx

'use client'

import { ChevronRight, ChevronLeft } from 'lucide-react'
// âœ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ù…ÙˆØ­Ø¯
import { Day } from '@/lib/core/types'

interface DaySelectorProps {
  days: Day[]
  selectedDate: Date | null
  onSelectDate: (date: Date) => void
}

export default function DaySelector({ days, selectedDate, onSelectDate }: DaySelectorProps) {
  const scroll = (direction: 'left' | 'right') => {
    const container = document.getElementById('days-container')
    if (container) {
      const scrollAmount = direction === 'left' ? -300 : 300
      container.scrollBy({ left: scrollAmount, behavior: 'smooth' })
    }
  }

  return (
    <div className="mb-12">
      <div className="flex items-center justify-between mb-6">
        <div>
          <h2 className="text-2xl font-bold text-gray-900">Ø§Ø®ØªØ± Ø§Ù„ØªØ§Ø±ÙŠØ®</h2>
          <p className="text-gray-600 mt-1">Ø­Ø¯Ø¯ Ø§Ù„ÙŠÙˆÙ… Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„Ø­Ø¬Ø²Ùƒ</p>
        </div>
        <div className="flex gap-2">
          <button
            onClick={() => scroll('left')}
            className="p-3 rounded-xl bg-gray-100 hover:bg-gray-200 transition-colors"
            aria-label="Scroll left"
          >
            <ChevronLeft className="w-5 h-5 text-gray-700" />
          </button>
          <button
            onClick={() => scroll('right')}
            className="p-3 rounded-xl bg-gray-100 hover:bg-gray-200 transition-colors"
            aria-label="Scroll right"
          >
            <ChevronRight className="w-5 h-5 text-gray-700" />
          </button>
        </div>
      </div>

      <div className="relative">
        <div
          id="days-container"
          className="flex gap-4 overflow-x-auto pb-6 scrollbar-hide"
        >
          {days.map((day) => {
            const dayDate = new Date(day.date) // âœ… Ø­ÙˆÙ„ string Ù„Ù€ Date
            const isSelected = selectedDate?.toDateString() === dayDate.toDateString()
            
            return (
              <button
                key={day.date}
                onClick={() => onSelectDate(dayDate)}
                className={`
                  flex-shrink-0 w-36 h-36 rounded-2xl p-5 text-center transition-all duration-300
                  border-2 hover:border-primary-500 hover:shadow-lg
                  ${isSelected
                    ? 'bg-gradient-to-br from-primary-500 to-primary-600 border-primary-500 text-white shadow-xl scale-105'
                    : 'bg-white border-gray-200 text-gray-700 hover:shadow-lg'
                  }
                  ${day.isWeekend ? 'bg-gradient-to-br from-amber-50 to-amber-100 border-amber-200' : ''}
                `}
              >
                <div className="text-sm font-medium mb-1">
                  {dayDate.toDateString() === new Date().toDateString()
                    ? 'Ø§Ù„ÙŠÙˆÙ…'
                    : day.isTomorrow
                    ? 'ØºØ¯Ø§Ù‹'
                    : day.weekday}
                </div>
                <div className="text-3xl font-bold mb-2">{day.dayNumber}</div>
                <div className="text-sm mb-3">{day.monthName}</div>
                
                {day.isWeekend && !isSelected && (
                  <div className="inline-block px-3 py-1 bg-amber-100 text-amber-800 rounded-full text-xs font-medium">
                    Ø¹Ø·Ù„Ø© Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹
                  </div>
                )}
                
                {isSelected && (
                  <div className="mt-2">
                    <div className="w-8 h-1 bg-white/30 rounded-full mx-auto"></div>
                  </div>
                )}
              </button>
            )
          })}
        </div>
        
        {/* Gradient overlays for scroll indication */}
        <div className="absolute left-0 top-0 bottom-6 w-12 bg-gradient-to-r from-white to-transparent pointer-events-none"></div>
        <div className="absolute right-0 top-0 bottom-6 w-12 bg-gradient-to-l from-white to-transparent pointer-events-none"></div>
      </div>
    </div>
  )
}

// app/api/auth/[...nextauth]/route.ts
import NextAuth from 'next-auth'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'  // âœ… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯

const handler = NextAuth(authOptions)

export { handler as GET, handler as POST }
// app/api/auth/me/route.ts
import { NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { successResponse, errorResponse } from '@/lib/infrastructure/auth/responses'
import { logger } from '@/lib/shared/logger'

// âœ… Ø£Ø¶Ù Ù‡Ø°Ø§ Ù„ØªØ­Ø¯ÙŠØ¯ Ø£Ù† Ø§Ù„Ù…Ø³Ø§Ø± Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ
export const dynamic = 'force-dynamic'

export const GET = async () => {
  const requestId = `auth_me_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

  try {
    logger.info('Fetching user data', { requestId })

    const session = await getServerSession(authOptions)

    if (!session?.user?.id) {
      logger.warn('Unauthorized access to /api/auth/me', { requestId })
      return NextResponse.json(
        errorResponse('ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹', 'UNAUTHORIZED'),
        { status: 401 }
      )
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: {
        id: true,
        name: true,
        email: true,
        phoneNumber: true,
        age: true,
        description: true,
        skillLevel: true,
        role: true,
        isVerified: true,
        isActive: true,
        lastLogin: true,
        createdAt: true,
        updatedAt: true,
      }
    })

    if (!user) {
      logger.warn('User not found', { requestId, userId: session.user.id })
      return NextResponse.json(
        errorResponse('Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯', 'USER_NOT_FOUND'),
        { status: 404 }
      )
    }

    if (!user.isActive) {
      logger.warn('Inactive account accessed', { requestId, userId: user.id })
      return NextResponse.json(
        errorResponse('Ø§Ù„Ø­Ø³Ø§Ø¨ ØºÙŠØ± Ù†Ø´Ø·', 'ACCOUNT_INACTIVE'),
        { status: 403 }
      )
    }

    logger.info('User data fetched successfully', { requestId, userId: user.id })

    return NextResponse.json(
      successResponse('ØªÙ… Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­', {
        user: {
          ...user,
          lastLogin: user.lastLogin?.toISOString(),
          createdAt: user.createdAt.toISOString(),
          updatedAt: user.updatedAt.toISOString()
        }
      }, '/api/auth/me')
    )

  } catch (error: any) {
    logger.error('Error in /api/auth/me', error, { requestId })
    return NextResponse.json(
      errorResponse('Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…', 'INTERNAL_ERROR'),
      { status: 500 }
    )
  }
}

// app/api/auth/register/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { RateLimiterMemory } from 'rate-limiter-flexible'
import { prisma } from '@/lib/infrastructure/database/prisma'  
import { hashPassword } from '@/lib/infrastructure/security/password'  // âœ… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯
import { z } from 'zod'
import { logger } from '@/lib/shared/logger'  // âœ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù€ logger Ø§Ù„Ø¬Ø¯ÙŠØ¯

// Rate Limiter Ù„Ù„ØªØ³Ø¬ÙŠÙ„
const registerRateLimiter = new RateLimiterMemory({
  points: 3,
  duration: 60 * 60,
  blockDuration: 60 * 60,
})

const registerSchema = z.object({
  name: z.string().min(2, 'Ø§Ù„Ø§Ø³Ù… ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø­Ø±ÙÙŠÙ† Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„'),
  email: z.string().email('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ØºÙŠØ± ØµØ§Ù„Ø­'),
  password: z.string()
    .min(6, 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† 6 Ø£Ø­Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„')
    .max(72, 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø·ÙˆÙŠÙ„Ø© Ø¬Ø¯Ø§Ù‹'),
  phoneNumber: z.string().min(10, 'Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ ØºÙŠØ± ØµØ§Ù„Ø­'),
  age: z.number().min(13, 'Ø§Ù„Ø¹Ù…Ø± ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† 13 Ø³Ù†Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„'),
  skillLevel: z.enum(['WEAK', 'AVERAGE', 'GOOD', 'EXCELLENT', 'LEGENDARY'])
})

const normalizeEmail = (email: string): string => {
  return email.toLowerCase().trim()
}

const checkRegisterRateLimit = async (ip: string) => {
  try {
    await registerRateLimiter.consume(ip)
    return { allowed: true }
  } catch (rateLimiterRes: any) {
    const retryAfter = Math.ceil(rateLimiterRes.msBeforeNext / 1000) || 60
    throw new Error(`Ù„Ù‚Ø¯ ØªØ¬Ø§ÙˆØ²Øª Ø§Ù„Ø­Ø¯ Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡ Ù…Ù† Ø§Ù„ØªØ³Ø¬ÙŠÙ„Ø§Øª. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¨Ø¹Ø¯ ${retryAfter} Ø«Ø§Ù†ÙŠØ©`)
  }
}

const getClientIp = (request: NextRequest): string => {
  const forwardedFor = request.headers.get('x-forwarded-for')
  const realIp = request.headers.get('x-real-ip')
  
  if (forwardedFor) {
    return forwardedFor.split(',')[0].trim()
  }
  
  return realIp || 'unknown'
}

export async function POST(request: NextRequest) {
  const requestId = `register_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    logger.info('Registration attempt', { requestId })
    
    const clientIp = getClientIp(request)
    await checkRegisterRateLimit(clientIp)
    
    const body = await request.json()
    const validatedData = registerSchema.parse(body)

    const normalizedEmail = normalizeEmail(validatedData.email)

    const existingUser = await prisma.user.findUnique({
      where: { email: normalizedEmail }
    })

    if (existingUser) {
      logger.warn('Email already exists', { requestId, email: normalizedEmail })
      return NextResponse.json(
        { 
          success: false,
          error: 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„',
          code: 'EMAIL_ALREADY_EXISTS'
        },
        { status: 409 }
      )
    }

    const existingPhone = await prisma.user.findUnique({
      where: { phoneNumber: validatedData.phoneNumber }
    })

    if (existingPhone) {
      logger.warn('Phone already exists', { requestId, phone: validatedData.phoneNumber })
      return NextResponse.json(
        { 
          success: false,
          error: 'Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„',
          code: 'PHONE_ALREADY_EXISTS'
        },
        { status: 409 }
      )
    }

    const hashedPassword = await hashPassword(validatedData.password)

    const user = await prisma.user.create({
      data: {
        name: validatedData.name,
        email: normalizedEmail,
        passwordHash: hashedPassword,
        phoneNumber: validatedData.phoneNumber,
        age: validatedData.age,
        skillLevel: validatedData.skillLevel,
        role: 'PLAYER',
        roleUpdatedAt: new Date(),
        isActive: true,
        isVerified: false,
        emailVerifiedAt: null
      }
    })

    logger.info('Registration successful', { requestId, userId: user.id })
    
    return NextResponse.json({
      success: true,
      message: 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø¨Ù†Ø¬Ø§Ø­',
      data: {
        id: user.id,
        name: user.name,
        email: user.email,
        requiresVerification: true
      }
    }, { status: 201 })

  } catch (error: any) {
    if (error.name === 'ZodError') {
      const firstError = error.errors[0]
      logger.warn('Validation error in registration', { requestId, error: firstError.message })
      return NextResponse.json(
        { 
          success: false,
          error: firstError.message,
          code: 'VALIDATION_ERROR'
        },
        { status: 400 }
      )
    }

    if (error.message.includes('Ù„Ù‚Ø¯ ØªØ¬Ø§ÙˆØ²Øª Ø§Ù„Ø­Ø¯ Ø§Ù„Ù…Ø³Ù…ÙˆØ­')) {
      logger.warn('Rate limit exceeded', { requestId, error: error.message })
      return NextResponse.json(
        { 
          success: false,
          error: error.message,
          code: 'RATE_LIMIT_EXCEEDED'
        },
        { status: 429 }
      )
    }

    logger.error('Registration error', error, { requestId })
    return NextResponse.json(
      { 
        success: false,
        error: 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨',
        code: 'INTERNAL_SERVER_ERROR'
      },
      { status: 500 }
    )
  }
}

// app/api/bookings/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'
import { BookingOrchestrator } from '@/lib/application/services/booking-orchestrator'  // âœ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„ÙƒÙ„Ø§Ø³ Ù…Ø¨Ø§Ø´Ø±Ø©
import { IdempotencyGuard } from '@/lib/application/idempotency/idempotency-guard'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { BOOKING_STATUS } from '@/lib/shared/constants'
import { logger } from '@/lib/shared/logger'

export async function GET(request: NextRequest) {
  const requestId = `get_bookings_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    logger.info('Fetching bookings', { requestId })
    
    const session = await getServerSession(authOptions)
    const userId = session?.user?.id

    if (!userId) {
      logger.warn('Unauthorized access to bookings', { requestId })
      throw new DomainError('UNAUTHORIZED')
    }

    const { searchParams } = new URL(request.url)
    const page = parseInt(searchParams.get('page') || '1')
    const limit = Math.min(parseInt(searchParams.get('limit') || '20'), 50)
    const status = searchParams.get('status')
    const skip = (page - 1) * limit

    const where: any = { userId }
    
    if (status) {
      where.status = status
    } else {
      where.status = {
        in: [BOOKING_STATUS.CONFIRMED, BOOKING_STATUS.PENDING_PAYMENT]
      }
    }

    const [bookings, total] = await Promise.all([
      prisma.booking.findMany({
        where,
        include: {
          field: {
            select: {
              id: true,
              name: true,
              pricePerHour: true
            }
          },
          slot: {
            select: {
              id: true,
              startTime: true,
              endTime: true,
              durationMinutes: true
            }
          },
          payments: {
            take: 1,
            orderBy: { createdAt: 'desc' }
          }
        },
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit
      }),
      prisma.booking.count({ where })
    ])

    logger.info('Bookings fetched successfully', { 
      requestId, 
      userId, 
      count: bookings.length,
      total 
    })
    
    return NextResponse.json({
      success: true,
      data: bookings,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
        hasMore: page * limit < total
      }
    })

  } catch (error: any) {
    logger.error('Get bookings error', error, { requestId })
    return apiErrorHandler(error)
  }
}

export async function POST(request: NextRequest) {
  const requestId = `create_booking_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    logger.info('Creating booking', { requestId })
    
    const session = await getServerSession(authOptions)
    const userId = session?.user?.id

    if (!userId) {
      logger.warn('Unauthorized booking creation attempt', { requestId })
      throw new DomainError('UNAUTHORIZED')
    }

    const { slotId, fieldId, idempotencyKey } = await request.json()

    if (!slotId || !fieldId) {
      logger.warn('Incomplete booking data', { requestId, slotId, fieldId })
      throw new DomainError('VALIDATION_ERROR', 'Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø¬Ø² ØºÙŠØ± Ù…ÙƒØªÙ…Ù„Ø©')
    }

    const finalKey = idempotencyKey || IdempotencyGuard.generateKey('booking')

    // âœ… Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ù€ static method Ù…Ù† Ø§Ù„ÙƒÙ„Ø§Ø³
    const result = await BookingOrchestrator.createBooking({
      userId,
      slotId,
      fieldId,
      idempotencyKey: finalKey
    })

    logger.info('Booking created successfully', { 
      requestId, 
      bookingId: result.bookingId,
      userId 
    })
    
    return NextResponse.json({
      success: true,
      ...result,
      idempotencyKey: finalKey
    })

  } catch (error: any) {
    logger.error('Create booking error', error, { requestId })
    return apiErrorHandler(error)
  }
}
import { NextResponse } from 'next/server'
import { BookingOrchestrator } from '@/lib/application/services/booking-orchestrator' // ğŸ”§ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„ÙƒÙ„Ø§Ø³
import { ENV } from '@/lib/shared/env/env'
import { logger } from '@/lib/shared/logger'

export const dynamic = 'force-dynamic'

export async function GET(request: Request) {
  const jobId = `cron_cleanup_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    logger.info('Starting cron cleanup job', { jobId })
    
    const authHeader = request.headers.get('authorization')
    
    if (authHeader !== `Bearer ${ENV.CRON_SECRET}`) {
      logger.warn('Unauthorized cron attempt', { jobId })
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // ğŸ”§ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§ - Ø§Ø³ØªØ®Ø¯Ù… static methods
    const [expireResult, unlockResult] = await Promise.all([
      BookingOrchestrator.cleanupExpiredBookings(),    // âœ… BookingOrchestrator.
      BookingOrchestrator.cleanupExpiredLocks()        // âœ… BookingOrchestrator.
    ])

    logger.info('Cron cleanup completed', { 
      jobId,
      expiredBookings: expireResult.cleaned || 0,
      unlockedSlots: unlockResult.unlockedSlots || 0
    })
    
    return NextResponse.json({
      success: true,
      timestamp: new Date().toISOString(),
      results: {
        expireBookings: expireResult,
        unlockSlots: unlockResult
      }
    })
  } catch (error: any) {
    logger.error('Cron cleanup error', error, { jobId })
    return NextResponse.json(
      { 
        success: false,
        error: 'Cleanup failed', 
        details: error.message 
      },
      { status: 500 }
    )
  }
}

// app/api/fields/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { FIELD_STATUS } from '@/lib/shared/constants'
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { logger } from '@/lib/shared/logger'

export async function GET(request: NextRequest) {
  const requestId = `get_fields_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    const userAgent = request.headers.get('user-agent') || 'unknown'
    const ip = request.headers.get('x-forwarded-for') || request.headers.get('x-real-ip') || 'unknown'
    const acceptLanguage = request.headers.get('accept-language') || 'ar'
    const acceptEncoding = request.headers.get('accept-encoding') || 'gzip'
    
    logger.info('Fetching fields', { requestId, userAgent, ip, acceptLanguage, acceptEncoding, url: request.url, method: request.method })
    
    const searchParams = request.nextUrl.searchParams
    const type = searchParams.get('type')
    const location = searchParams.get('location')
    const page = parseInt(searchParams.get('page') || '1')
    const limit = parseInt(searchParams.get('limit') || '10')
    const minPrice = searchParams.get('minPrice')
    const maxPrice = searchParams.get('maxPrice')
    const sortBy = searchParams.get('sortBy') || 'createdAt'
    const sortOrder = searchParams.get('sortOrder') || 'desc'

    if (page < 1 || limit < 1 || limit > 100) {
      return NextResponse.json({ success: false, error: 'Ù‚ÙŠÙ… Ø§Ù„ØªØµÙØ­ ØºÙŠØ± ØµØ§Ù„Ø­Ø©', code: 'INVALID_PAGINATION' }, { status: 400 })
    }

    const skip = (page - 1) * limit
    const where: any = { status: FIELD_STATUS.OPEN }

    if (type && type !== 'Ø§Ù„ÙƒÙ„') where.type = type.toUpperCase()
    if (location && location !== 'Ø§Ù„ÙƒÙ„') where.location = location
    if (minPrice) where.pricePerHour = { ...where.pricePerHour, gte: parseFloat(minPrice) }
    if (maxPrice) where.pricePerHour = { ...where.pricePerHour, lte: parseFloat(maxPrice) }

    const orderBy: any = {}
    if (sortBy === 'price') orderBy.pricePerHour = sortOrder
    else if (sortBy === 'name') orderBy.name = sortOrder
    else orderBy.createdAt = 'desc'

    // âœ… Ø§Ø³ØªØ®Ø¯Ù… select ÙÙ‚Ø· Ù…Ø¹ _count
    const [fields, totalCount] = await Promise.all([
      prisma.field.findMany({
        where,
        orderBy,
        skip,
        take: limit,
        select: {
          id: true,
          name: true,
          description: true,
          location: true,
          address: true,
          type: true,
          imageUrl: true,
          pricePerHour: true,
          depositPrice: true,
          facilities: true,
          _count: {
            select: {
              bookings: true,
              reviews: true
            }
          }
        }
      }),
      prisma.field.count({ where })
    ])

    const enrichedFields = fields.map(field => ({
      ...field,
      popularity: field._count.bookings,
      positiveReviews: field._count.reviews,
      isPopular: field._count.bookings > 10,
      hasDiscount: field.pricePerHour > 100,
      estimatedEarnings: field.pricePerHour * field._count.bookings
    }))

    const totalPages = Math.ceil(totalCount / limit)
    const hasNextPage = page < totalPages
    const hasPreviousPage = page > 1

    logger.info('Fields fetched successfully', { requestId, count: fields.length, totalCount, page, limit, totalPages, filters: { type, location, minPrice, maxPrice } })
    
    return NextResponse.json({ 
      success: true,
      data: enrichedFields,
      pagination: {
        currentPage: page,
        totalPages,
        totalItems: totalCount,
        itemsPerPage: limit,
        hasNextPage,
        hasPreviousPage
      },
      filters: {
        applied: { type, location, minPrice, maxPrice, sortBy, sortOrder },
        available: {
          types: ['FOOTBALL', 'BASKETBALL', 'TENNIS', 'SWIMMING'],
          locations: ['Ø§Ù„Ù‚Ø§Ù‡Ø±Ø©', 'Ø§Ù„Ø¬ÙŠØ²Ø©', 'Ø§Ù„Ø¥Ø³ÙƒÙ†Ø¯Ø±ÙŠØ©', 'Ø§Ù„Ù…Ù†ØµÙˆØ±Ø©'],
          priceRange: { min: 50, max: 500, step: 50 }
        }
      },
      metadata: {
        requestId,
        generatedAt: new Date().toISOString(),
        cacheInfo: { recommended: true, duration: 300 }
      }
    }, {
      headers: {
        'Cache-Control': 'public, max-age=300, stale-while-revalidate=60',
        'X-Total-Count': totalCount.toString(),
        'X-Page-Count': totalPages.toString(),
        'X-Request-ID': requestId
      }
    })
    
  } catch (error: any) {
    logger.error('Error fetching fields', error, { requestId, url: request.url })
    return apiErrorHandler(error)
  }
}
// app/api/fields/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { FIELD_STATUS } from '@/lib/shared/constants'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { logger } from '@/lib/shared/logger'

interface Params {
  params: {
    id: string
  }
}

export async function GET(
  request: NextRequest,
  { params }: Params
) {
  const requestId = `get_field_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    const fieldId = params.id
    
    const userAgent = request.headers.get('user-agent') || 'unknown'
    const ip = request.headers.get('x-forwarded-for') || request.headers.get('x-real-ip') || 'unknown'
    const acceptLanguage = request.headers.get('accept-language') || 'unknown'
    
    logger.info('Fetching field details', { 
      requestId, 
      fieldId,
      userAgent,
      ip,
      acceptLanguage,
      url: request.url,
      method: request.method
    })

    if (!fieldId) {
      throw new DomainError('VALIDATION_ERROR', 'Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ù…Ù„Ø¹Ø¨ ØºÙŠØ± ØµØ§Ù„Ø­')
    }

    const ifNoneMatch = request.headers.get('if-none-match')
    const cacheKey = `field_${fieldId}`
    
    if (ifNoneMatch === cacheKey) {
      return new NextResponse(null, { status: 304 })
    }

    // âœ… Ø´ÙŠÙ„ reviewCount Ù…Ù† select
    const field = await prisma.field.findUnique({
      where: { id: fieldId },
      select: {
        id: true,
        name: true,
        description: true,
        location: true,
        address: true,
        type: true,
        imageUrl: true,
        pricePerHour: true,
        depositPrice: true,
        openingTime: true,
        closingTime: true,
        slotDurationMin: true,
        status: true,
        facilities: true,
        gallery: true
      }
    })

    if (!field) {
      logger.warn('Field not found', { requestId, fieldId, ip })
      throw new DomainError('FIELD_NOT_FOUND', 'Ø§Ù„Ù…Ù„Ø¹Ø¨ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯')
    }

    if (field.status === FIELD_STATUS.CLOSED || field.status === FIELD_STATUS.MAINTENANCE) {
      logger.warn('Field not available', { 
        requestId, 
        fieldId, 
        status: field.status,
        ip 
      })
      
      return NextResponse.json({
        success: false,
        error: 'Ø§Ù„Ù…Ù„Ø¹Ø¨ ØºÙŠØ± Ù…ØªØ§Ø­ Ø­Ø§Ù„ÙŠÙ‹Ø§',
        code: 'FIELD_UNAVAILABLE',
        field: {
          id: field.id,
          name: field.name,
          status: field.status,
          estimatedReopen: field.status === FIELD_STATUS.MAINTENANCE ? 
            'Ø®Ù„Ø§Ù„ 24 Ø³Ø§Ø¹Ø©' : 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'
        }
      }, { 
        status: 403,
        headers: {
          'Cache-Control': 'no-cache',
          'X-Field-Status': field.status
        }
      })
    }

    const bookingsCount = await prisma.booking.count({
      where: {
        fieldId: fieldId,
        status: 'CONFIRMED'
      }
    })

    logger.info('Field details fetched successfully', { 
      requestId, 
      fieldId,
      totalBookings: bookingsCount
    })
    
    return NextResponse.json({
      success: true,
      data: {
        field: {
          ...field,
          gallery: field.gallery || [],
          popularity: bookingsCount
        }
      },
      metadata: {
        cached: false,
        expires: new Date(Date.now() + 5 * 60 * 1000).toISOString()
      }
    }, {
      headers: {
        'ETag': cacheKey,
        'Cache-Control': 'public, max-age=300',
        'X-Request-ID': requestId
      }
    })
    
  } catch (error: any) {
    logger.error('Error fetching field', error, { 
      requestId,
      url: request.url 
    })
    return apiErrorHandler(error)
  }
}

// app/api/fields/[id]/slots/date/[date]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { parseISO, isValid, startOfDay } from 'date-fns'
import { generateSlotsForDay } from '@/lib/domain/slots/time-slots/core-logic'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { SLOT_STATUS } from '@/lib/shared/constants'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { logger } from '@/lib/shared/logger'

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string; date: string } }
) {
  const requestId = `get_slots_by_date_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    const { id: fieldId, date } = params

    const userAgent = request.headers.get('user-agent') || 'unknown'
    const accept = request.headers.get('accept') || 'application/json'
    
    logger.info('Fetching slots by date', { 
      requestId, 
      fieldId, 
      date,
      userAgent,
      accept
    })

    if (!fieldId || !date) {
      throw new DomainError('VALIDATION_ERROR', 'Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ù„Ø¹Ø¨ ÙˆØ§Ù„ØªØ§Ø±ÙŠØ® Ù…Ø·Ù„ÙˆØ¨Ø§Ù†')
    }

    const parsedDate = parseISO(date)

    if (!isValid(parsedDate)) {
      throw new DomainError('VALIDATION_ERROR', 'ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ø±ÙŠØ® ØºÙŠØ± ØµØ§Ù„Ø­. ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† YYYY-MM-DD')
    }

    const now = new Date()
    const startOfToday = startOfDay(now)
    
    if (parsedDate < startOfToday) {
      throw new DomainError('INVALID_DATE', 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¹Ø±Ø¶ Ù…ÙˆØ§Ø¹ÙŠØ¯ ÙÙŠ Ø§Ù„Ù…Ø§Ø¶ÙŠ')
    }

    const cleanupResult = await prisma.slot.updateMany({
      where: {
        fieldId,
        status: SLOT_STATUS.TEMP_LOCKED,
        lockedUntil: { lt: now }
      },
      data: {
        status: SLOT_STATUS.AVAILABLE,
        lockedUntil: null,
        lockedByUserId: null
      }
    })

    if (cleanupResult.count > 0) {
      logger.debug('Cleaned expired locks', {
        requestId,
        cleaned: cleanupResult.count
      })
    }

    const slots = await generateSlotsForDay({
      fieldId,
      date: startOfDay(parsedDate),
      now
    })

    const normalizedSlots = slots.map(slot => {
      const startTimeISO = slot.startTime.toISOString()
      const endTimeISO = slot.endTime.toISOString()

      return {
        ...slot,
        startTime: startTimeISO,
        endTime: endTimeISO,
        durationMinutes: Math.floor(
          (slot.endTime.getTime() - slot.startTime.getTime()) / (1000 * 60)
        ),
        price: slot.price,
        isPast: slot.startTime < now, // Ù‡Ù†Ø§ Ù„Ø³Ù‡ Date
        canBook: slot.status === 'AVAILABLE' && slot.startTime > now,
        timeUntilStart: slot.startTime.getTime() - now.getTime()
      }
    })

    const stats = {
      total: normalizedSlots.length,
      available: normalizedSlots.filter(s => s.status === 'AVAILABLE').length,
      locked: normalizedSlots.filter(s => s.status === 'TEMP_LOCKED').length,
      booked: normalizedSlots.filter(s => s.status === 'BOOKED').length,
      past: normalizedSlots.filter(s => new Date(s.startTime) < now).length
    }

    logger.info('Slots by date fetched successfully', { 
      requestId, 
      fieldId, 
      date,
      slotCount: normalizedSlots.length,
      stats
    })
    
    return NextResponse.json({
      success: true,
      data: {
        fieldId,
        date: parsedDate.toISOString().split('T')[0],
        slots: normalizedSlots,
        statistics: stats,
        metadata: {
          generatedAt: now.toISOString(),
          cacheDuration: 60,
          timezone: 'Africa/Cairo'
        }
      }
    }, {
      headers: {
        'Cache-Control': 'public, max-age=60',
        'X-Request-ID': requestId,
        'X-Slots-Count': normalizedSlots.length.toString()
      }
    })
    
  } catch (error: any) {
    logger.error('Get slots by date error', error, { 
      requestId,
      url: request.url 
    })
    return apiErrorHandler(error)
  }
}
// app/api/fields/[fieldId]/slots/[slotId]/lock/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'
import { addMinutes } from 'date-fns'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { SLOT_STATUS } from '@/lib/shared/constants'
import { logger } from '@/lib/shared/logger'
import { assertSlotCanLock } from '@/lib/domain/guards/slot-guards' // âœ… Ø§Ù„Ø¢Ù† Ù…Ø³ØªØ®Ø¯Ù…

const LOCK_DURATION_MINUTES = 5

export async function POST(
  request: NextRequest,
  { params }: { params: { fieldId: string; slotId: string } }
) {
  const requestId = `lock_slot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    // Ø§Ø³ØªØ®Ø¯Ø§Ù… request Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† headers
    const userAgent = request.headers.get('user-agent') || 'unknown'
    const ip = request.headers.get('x-forwarded-for') || 'unknown'
    
    logger.info('Locking slot', { 
      requestId, 
      fieldId: params.fieldId,
      slotId: params.slotId,
      userAgent,
      ip,
      endpoint: request.url
    })

    const session = await getServerSession(authOptions)
    const userId = session?.user?.id

    if (!userId) {
      logger.warn('Unauthorized lock attempt', { 
        requestId,
        ip,
        userAgent,
        fieldId: params.fieldId,
        slotId: params.slotId
      })
      throw new DomainError('UNAUTHORIZED', 'ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù„Ù‚ÙÙ„ Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯')
    }

    const { slotId, fieldId } = params
    const now = new Date()

    // âœ… Ø§Ø³ØªØ®Ø¯Ø§Ù… assertSlotCanLock Ù„Ù„ØªØ­Ù‚Ù‚ Ù‚Ø¨Ù„ Ø§Ù„Ù‚ÙÙ„
    const validation = await assertSlotCanLock({
      slotId,
      userId,
      fieldId
    })

    // Ø¥Ø°Ø§ ÙƒØ§Ù† ÙŠÙ…ÙƒÙ† ØªÙ…Ø¯ÙŠØ¯ Ø§Ù„Ù‚ÙÙ„
    if (validation.canExtend) {
      logger.info('Extending existing lock', {
        requestId,
        slotId,
        userId,
        previousLockUntil: validation.slot.lockedUntil,
        newLockUntil: addMinutes(now, LOCK_DURATION_MINUTES)
      })
      
      await prisma.slot.update({
        where: { id: slotId },
        data: {
          lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES)
        }
      })

      return NextResponse.json({
        success: true,
        data: {
          extended: true,
          lockDuration: LOCK_DURATION_MINUTES,
          lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES).toISOString(),
          message: 'ØªÙ… ØªÙ…Ø¯ÙŠØ¯ Ù‚ÙÙ„ Ø§Ù„Ù…ÙˆØ¹Ø¯ Ø¨Ù†Ø¬Ø§Ø­'
        },
        metadata: {
          requestId,
          userId,
          timestamp: now.toISOString()
        }
      })
    }

    // Ù‚ÙÙ„ Ø¬Ø¯ÙŠØ¯
    const result = await prisma.$transaction(async (tx) => {
      const updateResult = await tx.slot.updateMany({
        where: {
          id: slotId,
          fieldId: fieldId,
          OR: [
            {
              status: SLOT_STATUS.AVAILABLE
            },
            {
              status: SLOT_STATUS.TEMP_LOCKED,
              OR: [
                { lockedUntil: null },
                { lockedUntil: { lt: now } }
              ]
            }
          ]
        },
        data: {
          status: SLOT_STATUS.TEMP_LOCKED,
          lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES),
          lockedByUserId: userId
        }
      })

      if (updateResult.count === 0) {
        const slot = await tx.slot.findUnique({
          where: { id: slotId },
          include: {
            field: {
              select: { id: true, name: true }
            },
            lockedByUser: {
              select: { id: true, email: true, name: true }
            }
          }
        })

        if (!slot) {
          throw new DomainError('SLOT_NOT_FOUND', 'Ø§Ù„Ù…ÙˆØ¹Ø¯ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯')
        }

        if (slot.status === SLOT_STATUS.BOOKED) {
          throw new DomainError('SLOT_ALREADY_BOOKED', 'Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù…Ø­Ø¬ÙˆØ² Ø¨Ø§Ù„ÙØ¹Ù„')
        }

        if (slot.status === SLOT_STATUS.TEMP_LOCKED && slot.lockedUntil && slot.lockedUntil > now) {
          if (slot.lockedByUserId === userId) {
            // ØªØ­Ø¯ÙŠØ« ÙˆÙ‚Øª Ø§Ù„Ù‚ÙÙ„
            await tx.slot.update({
              where: { id: slotId },
              data: {
                lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES)
              }
            })
            
            logger.info('Slot lock extended (fallback)', { 
              requestId, 
              slotId, 
              userId,
              fieldName: slot.field?.name 
            })
            return { success: true, extended: true }
          } else {
            throw new DomainError('SLOT_LOCKED_BY_OTHER', 
              `Ø§Ù„Ù…ÙˆØ¹Ø¯ Ù…Ù‚ÙÙˆÙ„ Ø­Ø§Ù„ÙŠØ§Ù‹ Ø¨ÙˆØ§Ø³Ø·Ø© ${slot.lockedByUser?.name || 'Ù…Ø³ØªØ®Ø¯Ù… Ø¢Ø®Ø±'}`
            )
          }
        }

        throw new DomainError('SLOT_CANNOT_BE_LOCKED', 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ù‚ÙÙ„ Ù‡Ø°Ø§ Ø§Ù„Ù…ÙˆØ¹Ø¯ Ø­Ø§Ù„ÙŠØ§Ù‹')
      }

      logger.info('Slot locked successfully', { 
        requestId, 
        slotId, 
        userId,
        lockDuration: LOCK_DURATION_MINUTES,
        lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES).toISOString()
      })
      
      return { success: true, locked: true }
    })

    // Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Slot Ø¨Ø¹Ø¯ Ø§Ù„Ù‚ÙÙ„
    const updatedSlot = await prisma.slot.findUnique({
      where: { id: slotId },
      select: {
        id: true,
        startTime: true,
        endTime: true,
        status: true,
        lockedUntil: true,
        field: {
          select: {
            id: true,
            name: true,
            pricePerHour: true
          }
        }
      }
    })

    return NextResponse.json({
      success: true,
      data: {
        ...result,
        slot: updatedSlot,
        lockDuration: LOCK_DURATION_MINUTES,
        lockedUntil: addMinutes(now, LOCK_DURATION_MINUTES).toISOString(),
        expiresIn: LOCK_DURATION_MINUTES * 60, // Ø¨Ø§Ù„Ø«ÙˆØ§Ù†ÙŠ
        countdownStart: now.getTime(),
        message: result.extended ? 'ØªÙ… ØªÙ…Ø¯ÙŠØ¯ Ø§Ù„Ù‚ÙÙ„' : 'ØªÙ… Ù‚ÙÙ„ Ø§Ù„Ù…ÙˆØ¹Ø¯ Ø¨Ù†Ø¬Ø§Ø­'
      },
      metadata: {
        requestId,
        userId,
        timestamp: now.toISOString(),
        cacheControl: 'no-cache'
      }
    }, {
      headers: {
        'Cache-Control': 'no-store, no-cache, must-revalidate',
        'X-Lock-Duration': LOCK_DURATION_MINUTES.toString(),
        'X-Request-ID': requestId
      }
    })

  } catch (error: any) {
    logger.error('Lock error', error, { 
      requestId,
      url: request.url,
      params,
      ip: request.headers.get('x-forwarded-for') || 'unknown'
    })
    
    return apiErrorHandler(error)
  }
}
// app/api/fields/[id]/slots/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/infrastructure/database/prisma'
import { generateSlotsForDay } from '@/lib/domain/slots/time-slots/core-logic'
import { getUISlots } from '@/lib/domain/slots/read-model'
import { FIELD_STATUS, SLOT_STATUS } from '@/lib/shared/constants'
import { DomainError } from '@/lib/core/errors/domain-errors'
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { logger } from '@/lib/shared/logger'

export async function GET(
  request: NextRequest,
  { params }: { params: { fieldId: string } }
) {
  const requestId = `get_slots_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    const fieldId = params.fieldId
    const { searchParams } = new URL(request.url)
    const dateParam = searchParams.get('date')
    
    // Ø§Ø³ØªØ®Ø¯Ø§Ù… request Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† rate limiting
    const ip = request.headers.get('x-forwarded-for') || 'unknown'
    const userAgent = request.headers.get('user-agent') || 'unknown'
    
    logger.info('Fetching slots', { 
      requestId, 
      fieldId, 
      dateParam,
      ip,
      userAgent 
    })

    if (!fieldId) {
      throw new DomainError('VALIDATION_ERROR', 'Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ù„Ø¹Ø¨ Ù…Ø·Ù„ÙˆØ¨')
    }

    if (!dateParam) {
      throw new DomainError('VALIDATION_ERROR', 'Ø§Ù„ØªØ§Ø±ÙŠØ® Ù…Ø·Ù„ÙˆØ¨')
    }

    const date = new Date(dateParam)
    if (isNaN(date.getTime())) {
      throw new DomainError('VALIDATION_ERROR', 'ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ø±ÙŠØ® ØºÙŠØ± ØµØ§Ù„Ø­')
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„ØªØ§Ø±ÙŠØ® Ù„ÙŠØ³ ÙÙŠ Ø§Ù„Ù…Ø§Ø¶ÙŠ
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    
    if (date < today) {
      throw new DomainError('INVALID_DATE', 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø¬Ø² Ù…ÙˆØ§Ø¹ÙŠØ¯ ÙÙŠ Ø§Ù„Ù…Ø§Ø¶ÙŠ')
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„ØªØ§Ø±ÙŠØ® Ù„ÙŠØ³ Ø£Ø¨Ø¹Ø¯ Ù…Ù† 30 ÙŠÙˆÙ…
    const maxDate = new Date()
    maxDate.setDate(maxDate.getDate() + 30)
    
    if (date > maxDate) {
      throw new DomainError('INVALID_DATE', 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø¬Ø² Ù…ÙˆØ§Ø¹ÙŠØ¯ Ø£Ø¨Ø¹Ø¯ Ù…Ù† 30 ÙŠÙˆÙ…')
    }

    const field = await prisma.field.findUnique({
      where: { id: fieldId }
    })

    if (!field) {
      throw new DomainError('FIELD_NOT_FOUND', 'Ø§Ù„Ù…Ù„Ø¹Ø¨ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯')
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ù„Ø¹Ø¨
    if (field.status === FIELD_STATUS.CLOSED) {
      logger.info('Field is closed', { requestId, fieldId })
      return NextResponse.json({
        success: true,
        data: {
          slots: [],
          field: {
            id: field.id,
            name: field.name,
            status: field.status,
            message: 'Ø§Ù„Ù…Ù„Ø¹Ø¨ Ù…ØºÙ„Ù‚ Ø­Ø§Ù„ÙŠØ§Ù‹'
          },
          metadata: {
            reason: 'FIELD_CLOSED',
            reopenDate: field.closingTime ? new Date(field.closingTime).toISOString() : null
          }
        }
      })
    }

    if (field.status === FIELD_STATUS.MAINTENANCE) {
      logger.info('Field is under maintenance', { requestId, fieldId })
      return NextResponse.json({
        success: true,
        data: {
          slots: [],
          field: {
            id: field.id,
            name: field.name,
            status: field.status,
            message: 'Ø§Ù„Ù…Ù„Ø¹Ø¨ ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©'
          },
          metadata: {
            reason: 'FIELD_MAINTENANCE',
            estimatedCompletion: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
          }
        }
      })
    }

    // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³Ù„Ø§Øª Ø§Ù„Ù…Ù‚ÙÙˆÙ„Ø© Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ©
    const cleanupResult = await prisma.slot.updateMany({
      where: {
        fieldId,
        status: SLOT_STATUS.TEMP_LOCKED,
        lockedUntil: { lt: new Date() }
      },
      data: {
        status: SLOT_STATUS.AVAILABLE,
        lockedByUserId: null,
        lockedUntil: null
      }
    })

    if (cleanupResult.count > 0) {
      logger.debug('Cleaned expired locks', { 
        requestId, 
        cleaned: cleanupResult.count 
      })
    }

    // ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø³Ù„Ø§Øª
    const slots = await generateSlotsForDay({
      fieldId,
      date,
      now: new Date()
    })

    const uiSlots = getUISlots(slots)

    // âœ… Ø¥ØµÙ„Ø§Ø­: Ø§Ø³ØªØ®Ø¯Ù… uiStatus Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† status
    const availableSlots = uiSlots.filter(s => s.uiStatus === 'AVAILABLE').length
    const lockedSlots = uiSlots.filter(s => s.uiStatus === 'LOCKED_ME' || s.uiStatus === 'LOCKED_OTHER').length
    const bookedSlots = uiSlots.filter(s => s.uiStatus === 'BOOKED').length

    logger.info('Slots fetched successfully', { 
      requestId, 
      fieldId, 
      slotCount: uiSlots.length,
      availableSlots,
      lockedSlots
    })
    
    return NextResponse.json({
      success: true,
      data: {
        field: {
          id: field.id,
          name: field.name,
          description: field.description,
          status: field.status,
          pricePerHour: field.pricePerHour,
          depositPrice: field.depositPrice,
          openingTime: field.openingTime,
          closingTime: field.closingTime,
          slotDurationMin: field.slotDurationMin
        },
        slots: uiSlots,
        date: date.toISOString().split('T')[0],
        statistics: {
          total: uiSlots.length,
          available: availableSlots, // âœ… Ù…Ø³ØªØ®Ø¯Ù… uiStatus
          locked: lockedSlots,       // âœ… Ù…Ø³ØªØ®Ø¯Ù… uiStatus
          booked: bookedSlots        // âœ… Ù…Ø³ØªØ®Ø¯Ù… uiStatus
        }
      }
    }, {
      headers: {
        'Cache-Control': 'public, max-age=60', // 1 Ø¯Ù‚ÙŠÙ‚Ø© Ù„Ù„Ø³Ù„Ø§Øª
        'X-Request-ID': requestId
      }
    })

  } catch (error: any) {
    logger.error('Get slots error', error, { 
      requestId,
      url: request.url 
    })
    return apiErrorHandler(error)
  }
}

// app/api/payment/create/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/infrastructure/auth/auth-options'
import { BookingOrchestrator } from '@/lib/application/services/booking-orchestrator' // ğŸ”§ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„ÙƒÙ„Ø§Ø³
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { logger } from '@/lib/shared/logger'

export async function POST(request: NextRequest) {
  const requestId = `create_payment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  
  try {
    logger.info('Creating payment', { requestId })

    const session = await getServerSession(authOptions)
    const userId = session?.user?.id

    if (!userId) {
      logger.warn('Unauthorized payment attempt', { requestId })
      return NextResponse.json(
        { error: 'ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹' },
        { status: 401 }
      )
    }

    const { bookingId, amount, currency = 'EGP', idempotencyKey } = await request.json()

    if (!bookingId || !amount) {
      logger.warn('Incomplete payment data', { requestId, bookingId, amount })
      return NextResponse.json(
        { error: 'Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯ÙØ¹ ØºÙŠØ± Ù…ÙƒØªÙ…Ù„Ø©' },
        { status: 400 }
      )
    }

    if (amount <= 0) {
      logger.warn('Invalid payment amount', { requestId, amount })
      return NextResponse.json(
        { error: 'Ù‚ÙŠÙ…Ø© Ø§Ù„Ø¯ÙØ¹ ØºÙŠØ± ØµØ§Ù„Ø­Ø©' },
        { status: 400 }
      )
    }

    // ğŸ”§ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§
    const result = await BookingOrchestrator.initiatePayment({  // âœ… BookingOrchestrator.
      bookingId,
      amount,
      currency,
      idempotencyKey,
      userId,
    })

    logger.info('Payment initiated successfully', {
      requestId,
      bookingId,
      orderId: result.orderId,
      userId
    })

    return NextResponse.json({
      success: true,
      data: result,
      message: 'ØªÙ… Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¯ÙØ¹ Ø¨Ù†Ø¬Ø§Ø­'
    })

  } catch (error: any) {
    logger.error('Payment creation error', error, { requestId })
    return apiErrorHandler(error)
  }
}
// app/api/webhooks/paymob/route.ts
import { NextRequest } from 'next/server'
import { BookingOrchestrator } from '@/lib/application/services/booking-orchestrator'
import { paymobService } from '@/lib/infrastructure/payments/providers'
import { assertWebhookValid } from '@/lib/domain/guards/payment-guards'
import { apiErrorHandler } from '@/lib/shared/api/api-error-handler'
import { logger } from '@/lib/shared/logger'
import { parseISO, differenceInMinutes } from 'date-fns'

export async function POST(request: NextRequest) {
  const webhookId = `webhook_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

  try {
    logger.info('Processing Paymob webhook', {
      webhookId,
      ip: request.headers.get('x-forwarded-for') || 'unknown',
      userAgent: request.headers.get('user-agent') || 'unknown'
    })

    const body = await request.json()
    const hmac = request.headers.get('hmac')

    if (!hmac) {
      logger.error('HMAC header missing', {
        webhookId,
        headers: Object.fromEntries(request.headers.entries())
      })
      return apiErrorHandler(new Error('HMAC header missing'))
    }

    // 1ï¸âƒ£ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† HMAC
    if (!paymobService.verifyHMAC(body.obj, hmac)) {
      logger.error('Invalid HMAC signature', {
        webhookId,
        hmac,
        bodyHash: JSON.stringify(body.obj).length
      })
      return apiErrorHandler(new Error('Invalid HMAC signature'))
    }

    // 2ï¸âƒ£ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    const {
      success,
      amount_cents,
      id: transactionId,
      order: { id: orderId, merchant_order_id: bookingId },
      created_at,
      currency = 'EGP'
    } = body.obj

    const createdAt = parseISO(created_at)
    const now = new Date()
    const minutesDiff = differenceInMinutes(now, createdAt)

    logger.info('Webhook data extracted', {
      webhookId,
      bookingId,
      orderId,
      transactionId,
      success,
      amount: amount_cents / 100,
      created_at: createdAt.toISOString(),
      minutesAgo: minutesDiff,
      currency
    })

    if (minutesDiff > 60) {
      logger.warn('Webhook is too old, ignoring', {
        webhookId,
        minutesDiff,
        created_at: createdAt.toISOString(),
        received_at: now.toISOString()
      })
      return new Response('OK', {
        status: 200,
        headers: {
          'Content-Type': 'text/plain',
          'X-Webhook-Status': 'IGNORED_OLD'
        }
      })
    }

    // 3ï¸âƒ£ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù€ webhook
    const payment = await assertWebhookValid({
      orderId: orderId.toString(),
      transactionId: transactionId.toString(),
      amount: amount_cents / 100
    })

    logger.info('Webhook validated', {
      webhookId,
      paymentId: payment.id,
      bookingId: payment.bookingId,
      previousStatus: payment.status,
      created_at: createdAt.toISOString(),
      processingDelay: minutesDiff
    })

    // 4ï¸âƒ£ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø­Ø¬Ø²
    const processingStart = Date.now()

    await BookingOrchestrator.completeBooking({
      bookingId: payment.bookingId,
      success: Boolean(success),
      paymentDetails: {
        transactionId: transactionId.toString(),
        orderId: orderId.toString(),
        amount: amount_cents / 100,
        currency
      }
    })

    const processingTime = Date.now() - processingStart

    logger.info('Booking processing completed', {
      webhookId,
      bookingId: payment.bookingId,
      success,
      processingTime,
      totalTimeFromCreation: minutesDiff + processingTime / 60000
    })

    return new Response('OK', {
      status: 200,
      headers: {
        'Content-Type': 'text/plain',
        'X-Webhook-ID': webhookId,
        'X-Processing-Time': processingTime.toString(),
        'X-Booking-ID': payment.bookingId
      }
    })
  } catch (error: any) {
    logger.error('Webhook processing error', error, {
      webhookId,
      url: request.url,
      body: JSON.stringify(await request.json()).substring(0, 500)
    })

    return new Response('ERROR', {
      status: 500,
      headers: {
        'Content-Type': 'text/plain',
        'X-Webhook-Status': 'ERROR',
        'X-Error-Message': error.message.substring(0, 100)
      }
    })
  }
}
