بلوبرنت كامل ومتكامل للمشروع — من الألف إلى الياء

(بالعربي وبأسلوب عملي جداً بحيث أي مطوِّر أو أداة AI تقدر تنفذه حرفياً بدون غلطات صغيرة)

هذا المستند هو الخريطة النهائية: كل ملف، كل دالة، كل API contract، كل قاعدة بيانات، كل متغير بيئة، أوامر التشغيل، استراتيجيات الأمان، اختبارات أساسية، ونقاط الانتباه. انسخها طبق-طبق في المشروع.

نظرة سريعة / هدف

نظام حجز ملاعب (Soccer & Padel) باستخدام:

Next.js (App Router) — Frontend + Backend (Route Handlers)

Prisma + PostgreSQL

JWT Auth (HttpOnly cookie)

Paymob للدفع

Minimal, secure, production-ready defaults

1 — هيكل المشروع (روت كامل وملفات)
project-root/
├── app
│   ├── (auth)
│   │   ├── login
│   │   │   └── page.tsx
│   │   └── register
│   │       └── page.tsx
│   ├── api
│   │   ├── admin
│   │   │   ├── manage-users
│   │   │   │   └── route.ts
│   │   │   ├── reports
│   │   │   │   └── route.ts
│   │   │   └── stats
│   │   │       └── route.ts
│   │   ├── areas
│   │   │   └── list
│   │   │       └── route.ts
│   │   ├── auth
│   │   │   ├── login
│   │   │   │   └── route.ts
│   │   │   ├── logout
│   │   │   │   └── route.ts
│   │   │   ├── me
│   │   │   │   └── route.ts
│   │   │   ├── refresh
│   │   │   │   └── route.ts
│   │   │   └── register
│   │   │       └── route.ts
│   │   ├── bookings
│   │   │   ├── [id]
│   │   │   │   └── route.ts
│   │   │   ├── accept
│   │   │   │   └── route.ts
│   │   │   ├── cancel
│   │   │   │   └── route.ts
│   │   │   ├── create
│   │   │   │   └── route.ts
│   │   │   ├── list
│   │   │   │   └── route.ts
│   │   │   └── reject
│   │   │       └── route.ts
│   │   ├── employee
│   │   │   ├── dashboard
│   │   │   │   └── route.ts
│   │   │   └── manage-bookings
│   │   │       └── route.ts
│   │   ├── fields
│   │   │   ├── create
│   │   │   │   └── route.ts
│   │   │   ├── details
│   │   │   │   └── route.ts
│   │   │   ├── list
│   │   │   │   └── route.ts
│   │   │   └── update
│   │   │       └── route.ts
│   │   ├── owner
│   │   │   └── fields
│   │   │       └── route.ts
│   │   ├── payments
│   │   │   ├── create-session
│   │   │   │   └── route.ts
│   │   │   ├── initiate
│   │   │   │   └── route.ts
│   │   │   ├── mock-pay
│   │   │   │   └── route.ts
│   │   │   └── webhook
│   │   │       └── route.ts
│   │   ├── schedule
│   │   │   ├── generate
│   │   │   │   └── route.ts
│   │   │   └── list
│   │   │       └── route.ts
│   │   └── users
│   │       └── [id]
│   │           └── route.ts
│   ├── dashboard
│   │   ├── admin
│   │   │   └── page.tsx
│   │   ├── employee
│   │   │   └── page.tsx
│   │   ├── owner
│   │   │   ├── [id]
│   │   │   │   └── page.tsx
│   │   │   └── page.tsx
│   │   └── player
│   │       └── page.tsx
│   ├── fields
│   │   ├── [id]
│   │   │   └── page.tsx
│   │   └── page.tsx
│   ├── globals.css
│   ├── layout.tsx
│   ├── my-bookings
│   │   └── page.tsx
│   └── page.tsx
├── components
│   ├── BookingSlot.tsx
│   ├── FieldCard.tsx
│   ├── layout
│   │   ├── Footer.tsx
│   │   └── Header.tsx
│   └── ui
│       ├── Button.tsx
│       ├── Card.tsx
│       ├── Input.tsx
│       ├── LoadingSpinner.tsx
│       ├── Modal.tsx
│       └── Toast.tsx
├── context
│   └── AuthContext.tsx
├── lib
│   ├── auth.ts
│   ├── helpers.ts
│   ├── prisma.ts
│   └── responses.ts
├── middleware.ts
├── next.config.js
├── package.json
├── postcss.config.js
├── prisma
│   ├── schema.prisma
│   └── seed.ts
├── tailwind.config.js
├── tsconfig.json
├── utils
│   └── sendMail.js
2 — قاعدة البيانات (Prisma schema) — نهائي PostgreSQL

احفظ الملف prisma/schema.prisma كما يلي (مباشر وجاهز للـ Postgres):

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  OWNER
  EMPLOYEE
  ADMIN
}

enum FieldType {
  SOCCER
  PADEL
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  FAILED
}

enum PaymentStatus {
  PENDING
  SUCCESS
  FAILED
}

model User {
  id        String   @id @default(uuid())
  name      String
  email     String   @unique
  password  String
  role      Role     @default(USER)
  createdAt DateTime @default(now())

  fields        Field[]      @relation("OwnerFields")
  bookings      Booking[]
  ownedEmployees Employee[] @relation("OwnerEmployees")
  asEmployee    Employee?    @relation("UserEmployee", fields: [employeeRefId], references: [id])
  employeeRefId String?
}

model Area {
  id     String  @id @default(uuid())
  name   String  @unique
  fields Field[]
}

model Field {
  id           String      @id @default(uuid())
  ownerId      String
  owner        User        @relation("OwnerFields", fields: [ownerId], references: [id])
  name         String
  type         FieldType
  pricePerHour Float
  location     String
  areaId       String
  area         Area        @relation(fields: [areaId], references: [id])
  image        String?
  phone        String?
  description  String?
  createdAt    DateTime    @default(now())

  openHour    String       // "06:00"
  closeHour   String       // "23:00"
  activeDays  Int[]        // 0 = Sun ... 6 = Sat

  schedules    FieldSchedule[]
  bookings     Booking[]
}

model TimeSlot {
  id    String @id @default(uuid())
  start String // "17:00"
  end   String // "18:00"
  label String @unique

  schedules FieldSchedule[]
  bookings  Booking[]
}

model FieldSchedule {
  id        String   @id @default(uuid())
  fieldId   String
  field     Field    @relation(fields: [fieldId], references: [id])
  slotId    String
  slot      TimeSlot @relation(fields: [slotId], references: [id])
  weekday   Int?     // 0..6 or null = every day

  @@unique([fieldId, slotId, weekday], name: "field_slot_weekday_unique")
}

model Booking {
  id             String   @id @default(uuid())
  fieldId        String
  field          Field    @relation(fields: [fieldId], references: [id])
  userId         String
  user           User     @relation(fields: [userId], references: [id])
  date           DateTime // date-only, stored in UTC 00:00
  slotId         String
  slot           TimeSlot @relation(fields: [slotId], references: [id])
  slotLabel      String
  status         BookingStatus @default(PENDING)
  paymentId      String?
  amount         Float
  createdAt      DateTime @default(now())
  cancelledAt    DateTime?
  cancelledBy    String?  // "user" | "employee" | "owner" | "system"
  cancelReason   String?

  payment        Payment? @relation(fields: [paymentId], references: [id])

  @@unique([fieldId, date, slotId], name: "booking_unique_slot_per_field_day")
  @@index([fieldId, date, slotId], name: "booking_field_date_slot_idx")
}

model Payment {
  id            String   @id @default(uuid())
  bookingId     String?
  booking       Booking? @relation(fields: [bookingId], references: [id])
  provider      String   // "paymob"
  providerTxId  String
  status        PaymentStatus
  amount        Float
  createdAt     DateTime @default(now())
}

model Employee {
  id       String   @id @default(uuid())
  ownerId  String
  owner    User     @relation("OwnerEmployees", fields: [ownerId], references: [id])
  userId   String
  user     User     @relation("UserEmployee", fields: [userId], references: [id])

  fieldIds String[]  // array of Field.id
}

3 — متغيرات البيئة (ملف .env)

املأ هذه المتغيرات قبل التشغيل:

DATABASE_URL=postgresql://USER:PASS@HOST:PORT/DBNAME
JWT_SECRET=very_secret_key_here
NEXT_PUBLIC_BASE_URL=http://localhost:3000
PAYMOB_API_KEY=...
PAYMOB_INTEGRATION_ID=...
PAYMOB_IFRAME_ID=...
PAYMOB_CALLBACK_URL=${NEXT_PUBLIC_BASE_URL}/api/payments/webhook

4 — ملفات lib/ الأساسية
lib/prisma.ts
import { PrismaClient } from "@prisma/client";
declare global { var prisma: PrismaClient | undefined; }
const prisma = global.prisma ?? new PrismaClient();
if (process.env.NODE_ENV !== "production") global.prisma = prisma;
export default prisma;

lib/auth.ts
import jwt from "jsonwebtoken";
import prisma from "./prisma";

export function signToken(user) {
  return jwt.sign({ id: user.id, role: user.role }, process.env.JWT_SECRET, { expiresIn: "7d" });
}

export function verifyToken(token) {
  try { return jwt.verify(token, process.env.JWT_SECRET); } catch { return null; }
}

export async function getUserFromRequest(req) {
  const token = req.cookies?.token || req.headers.get("cookie")?.match(/token=([^;]+)/)?.[1];
  if (!token) return null;
  const decoded = verifyToken(token);
  if (!decoded) return null;
  return await prisma.user.findUnique({ where: { id: decoded.id } });
}

lib/responses.ts
export function ok(data={}, message='') {
  return new Response(JSON.stringify({ status:'success', message, data }), { status: 200, headers: {'Content-Type':'application/json'} });
}
export function bad(message='', code=400) {
  return new Response(JSON.stringify({ status:'error', message }), { status: code, headers: {'Content-Type':'application/json'} });
}

lib/helpers.ts (مهم)

تضم:

calculateDeposit(price, bookingDateTimeUTC) → إذا الفرق >=24 ساعة ترجع price وإلا 0.

combineDateAndTime(dateStr, timeStr) → Date UTC.

isSlotAvailable(prisma, fieldId, dateUTC, slotId) → داخل transaction: تحقق عدم وجود Booking مع status CONFIRMED/PENDING.

createBookingTransaction(...) → encapsulate transaction.

(سأكتب تفاصيل الدوال عند طلب تنفيذ route معين.)

5 — Middleware (ملف middleware.ts)
import { NextResponse } from "next/server";
import { verifyToken } from "./lib/auth";

export async function middleware(req) {
  const { pathname } = req.nextUrl;
  // protect APIs that need auth
  if (pathname.startsWith("/api/") && (pathname.startsWith("/api/bookings") || pathname.startsWith("/api/fields/create") || pathname.startsWith("/api/schedule"))) {
    const token = req.cookies.get("token")?.value;
    if (!token) return NextResponse.json({ status:'error', message:'Unauthorized' }, { status: 401 });
    const decoded = verifyToken(token);
    if (!decoded) return NextResponse.json({ status:'error', message:'Invalid token' }, { status: 401 });
    // attach role? can't mutate req; routes should re-verify user.
  }
  // protect dashboards - redirect to login if no token
  if (pathname.startsWith("/dashboard")) {
    const token = req.cookies.get("token")?.value;
    if (!token) return NextResponse.redirect(new URL("/(auth)/login", req.url));
  }
  return NextResponse.next();
}


ملاحظة: Route Handlers يجب أن يعيدوا فحص المستخدم لأن middleware لا تعطي الـ user object داخل الـ handler تلقائياً.

6 — API Route Handlers — موجز العقود (Contracts)

كل route يرجع JSON مطابق لـ lib/responses.ok أو .bad.

POST /api/auth/register

Body: { name, email, password }

Action: validate, hash password (bcrypt), create user(role=USER), sign token, set cookie token (HttpOnly), return user (id, name, role).

Errors: 409 email exists, 400 invalid.

POST /api/auth/login

Body: { email, password }

Action: verify, sign token, set cookie, return user + redirect path (based on role).

Errors: 401 invalid.

GET /api/fields/list?type=&areaId=&q=&page=&limit=

Return: paginated fields + area info + owner basic info.

GET /api/fields/details?id=&date=YYYY-MM-DD

Return: field details + availableSlots: [{ slotId, label, status }] for given date.

How: read FieldSchedule for weekday, for each slot check Booking unique on that date.

POST /api/fields/create (OWNER|ADMIN)

Body: field data.

Action: create field, call schedule/generate optional.

POST /api/schedule/generate

Body: { fieldId }

Action: read field.openHour/closeHour/activeDays => create TimeSlot upserts and FieldSchedule entries.

POST /api/bookings/create

Body: { fieldId, date: 'YYYY-MM-DD', slotId }

Steps:

compute slot start datetime UTC

diffHours = (start - now)/3600

begin prisma.$transaction:

check if Booking exists same field/date/slot -> return conflict

if diffHours < 24:

create Booking status=CONFIRMED, amount=field.pricePerHour (or 0 deposit per your rule)

return booking
else:

create Booking status=PENDING, amount=field.pricePerHour (deposit = pricePerHour)

create Payment record status=PENDING amount=deposit

create Paymob payment session (server-side call) -> get payUrl or iframe token

return { bookingId, payUrl }

Concurrency safe by unique constraint and transaction.

POST /api/bookings/cancel

Body: { bookingId, reason }

Check rights: userOwns || ownerOfField || employeeAssigned || admin

Update booking.status=CANCELLED, set cancelledBy, cancelledAt, cancelReason.

If payment SUCCESS -> flag refund_needed (manual flow).

GET /api/bookings/list?role=player|owner|employee&dateFrom&dateTo

Return bookings accordingly with includes: field, slot, payment.

POST /api/payments/webhook (Paymob)

Validate provider signature (if any)

Find Payment by providerTxId or bookingId

If success -> update Payment.status = SUCCESS and Booking.status = CONFIRMED (link paymentId)

If failed -> Payment.status = FAILED ; Booking.status = FAILED or remain PENDING

7 — الواجهات (Frontend) — ملفات وصف الوظائف الدقيقة
/app/page.tsx (Landing)

header + 4 cards: Soccer, Padel, Add Field (link to Google Form), My Bookings

Each card routes to /fields?type=SOCCER or /fields?type=PADEL

/app/(auth)/login/page.tsx

Form (email,password) -> POST /api/auth/login

On success: redirect to /dashboard/{role}

/app/fields/page.tsx

Fetch /api/fields/list with filters (area, q)

Show FieldCard for each

Pagination controls

/app/fields/[id]/page.tsx

Fetch /api/fields/details?id=...&date=YYYY-MM-DD

Show details, images, price, features

Show booking UI: date picker -> list of BookingSlot components

On click BookingSlot -> call /api/bookings/create

Handle pay redirect if needed, else show confirmation

/app/my-bookings/page.tsx

Fetch /api/bookings/list?role=player

Show table with statuses and cancel button

Dashboards

/app/dashboard/player -> my bookings + quick actions

/app/dashboard/owner -> stats: weekly/monthly revenue, bookings per day, top fields, cancellations list

/app/dashboard/employee -> list of assigned fields and booking controls (book/cancel) for each

/app/dashboard/admin -> manage users, fields, set roles

8 — مكونات رئيسية (component contracts)
FieldCard.tsx

Props:

{ id, name, image, pricePerHour, location, areaName, onView }


Behavior:

display info + button "View" navigates to /fields/[id]

BookingSlot.tsx

Props:

{ slotId, label, status, disabled, onBook }


Statuses:

available (clickable)

booked (disabled)

pending (payment in progress)

cancelled (show reason)
Behavior:

onBook -> call handler passed from page

9 — سياسات وأمان أساسية (لا تتخلى عنها)

Passwords: hash with bcrypt (saltRounds 12).

JWT: HttpOnly cookie token, SameSite=Lax, Secure=true في prod.

Validate كل إدخال (email format, date format, slotId exists).

Use transactions لcreate booking + create payment.

Rate-limit /api/bookings/create per IP/user (to avoid spam).

Webhook security: verify signature or secret.

Escape/validate fields من XSS عند عرض أي user input مثل field.description.

10 — استراتيجية الدفع مع Paymob (مبسط)

Client يطلب حجز يحتاج دفع → Server ينشئ Booking (PENDING) وPayment (PENDING).

Server ينادي Paymob API لإنشاء order وpayment_key ويعيد للعميل رابط الدفع (payUrl) أو iframe token.

العميل يكمل الدفع في Paymob.

Paymob يعيد redirect أو يرسل webhook إلى /api/payments/webhook.

Webhook يحقق providerTxId, amount، ويحدّث Payment.status و Booking.status.

حافظة: لا تعتبر redirect كدليل نهائي على الدفع — يجب التحقق عبر webhook أو استعلام Paymob عن الحالة.

11 — seed script (اقتراح سريع)

prisma/seed.ts يقوم ب:

إدخال Areas

إدخال TimeSlots من 06:00 إلى 23:00

إنشاء admin, owner, employee, sample users

إنشاء 4–6 Fields وربطهم بالowner

assign employee.fieldIds لعدة ملاعب

بعض الحجوزات للتجربة

(أكتب لك سكريبت جاهز إذا أردت.)

12 — أوامر التشغيل (local dev)
# تثبيت
npm install

# Prisma: generate + migrate
npx prisma generate
npx prisma migrate dev --name init

# Seed (بعد الكتابة)
npm run prisma:seed   # script في package.json

# تشغيل dev
npm run dev


package.json scripts مقترح:

{
  "dev": "next dev",
  "build": "next build",
  "start": "next start",
  "prisma:generate": "prisma generate",
  "prisma:migrate": "prisma migrate dev --name init",
  "prisma:seed": "ts-node prisma/seed.ts"
}

13 — اختبار سريع للتأكد (checklist)

بعد إعداد DB و تشغيل:

 Register user -> cookie token set

 Create owner + field -> schedule generated

 Fetch field details for a date -> available slots accurate

 Create booking <24h -> CONFIRMED without payment

 Create booking >=24h -> PENDING + payment created

 Complete payment via Paymob -> webhook updates Booking to CONFIRMED

 Employee can book/cancel only their fields

 Admin can change user role

 Unique constraint prevents double-booking (test concurrent calls)

14 — اختبارات أوتوماتيكية مقترحة (minimal)

Unit: helpers.calculateDeposit

Integration: create booking happy path (no pay), create booking pay path

Concurrency: simulate two parallel create booking requests for same slot -> one fails with conflict

15 — ملاحظات ختامية ونصائح تنفيذية

اتبع العقود حرفياً: كل API يجب أن يتبع Request/Response المحدد هنا.

لا تقم بتعديل الـ unique constraint في Booking ما لم تفهم تبعات concurrency.

استخدم UTC دائماً داخل DB. حوّل عند العرض.

ابدأ بالـ seed لتجربة سريعة، ولا تعمل بيانات يدوية في DB أثناء التطوير لتجنب التضارب.
ملفات ومجلدات مفصّلة

سأعرض كل ملف/مجلد في ترتيب عملي: وظيفته، وظائف/exports رئيسية، واجهة البيانات (request/response)، أمثلة استعلامات Prisma، الأخطاء الشائعة، وتحسينات مستقبلية.

1. /prisma/schema.prisma

الهدف: تعريف مخطط قاعدة البيانات. هذا الملف هو المصدر الوحيد للحقيقة بالنسبة للـ DB.

محتوى أساسي: الجداول: User, Area, Field, TimeSlot, FieldSchedule, Booking, Payment, Employee مع الأنواع والـ enums: Role, FieldType, BookingStatus, PaymentStatus.

نقاط مهمة:

استخدم String @id @default(uuid()) لكل id.

Field.activeDays Int[] وEmployee.fieldIds String[] لأنك على PostgreSQL.

@@unique([fieldId, date, slotId]) في Booking لمنع الازدواج.

تأكد أن providerTxId في Payment له index إن كنا نبحث به.

خطوات بعد التعديل:

npx prisma generate

npx prisma migrate dev --name init (أو deploy حسب البيئة)

2. /lib/prisma.ts

الهدف: توفير كائن Prisma Client مستخدم في المشروع كله.

تصدير:

import { PrismaClient } from '@prisma/client';
const prisma = global.prisma || new PrismaClient();
if (process.env.NODE_ENV !== 'production') global.prisma = prisma;
export default prisma;


ملاحظة: استعمال caching في dev لتجنّب إنشاء اتصالات متعدّدة.

3. /lib/auth.ts

الهدف: دوال التوقيع والتحقق من JWT، دوال مساعدة لجلب المستخدم من التوكن.

وظائف مهمة:

signToken(user: { id, role }) => string — يستخدم process.env.JWT_SECRET.

verifyToken(token) => decoded | null — try/catch.

getUserFromToken(token) => prisma.user.findUnique({ where: { id } }) — لجلب بيانات المستخدم كاملة.

ممارسات أمان:

استخدم HttpOnly cookie مع SameSite=Lax وSecure على الإنتاج.

لا تضع بيانات حساسة في التوكن سوى id وrole.

4. /lib/responses.ts

الهدف: واجهة موحّدة للـ responses.

تصدير:

export function success(message, data = {}) {
  return NextResponse.json({ status: 'success', message, data });
}
export function error(message, code = 400) {
  return NextResponse.json({ status: 'error', message }, { status: code });
}


استعمال: كل route يجب أن يستدعي success() أو error().

5. /lib/helpers.ts

الهدف: دوال مساعدة متكررة.

دوال مقترحة:

formatDateUTC(date: Date) → string

parseDateToUTC(dateStr) → Date

calculateDeposit(pricePerHour, bookingDate) → number (طبق قاعدة 24 ساعة)

isSlotAvailable(fieldId, dateUTC, slotId) → boolean (تفحص Booking مع transaction)

getSlotStartDatetime(dateUTC, slot) → DateTime for diff calc

مثال isSlotAvailable (تقريبي):

async function isSlotAvailable(fieldId, date, slotId) {
  const existing = await prisma.booking.findFirst({
    where: { fieldId, date, slotId, status: { in: ['CONFIRMED','PENDING'] } }
  });
  return !existing;
}

6. /middleware.ts

الهدف: حماية الـ routes (app routes + api routes إن وُجدت) والتحقق من الـ role.

سلوك مقترح:

يقرأ cookie token.

verifyToken.

يرفض الوصول لصفحات /dashboard/* إذا لم يملك role المناسب.

إعادة توجيه إلى /auth/login في حال عدم التحقق.

نقطة مهمة: Next.js App Router يسمح بملف middleware على مستوى الجذر. في الـ API routes من الأفضل التحقق داخل الـ route أيضاً لأن الـ middleware قد لا يعمل على بعض endpoints (webhook...).

7. /app/layout.tsx و /app/page.tsx

layout.tsx

يحتوي Header (Navbar) و Footer.

يضم Provider للـ Auth/context إذا احتجنا.

page.tsx (Landing)

صفحة بسيطة تربط الأربع خانات (Soccer, Padel, Add field link, My Bookings).

8. /app/(auth)/login/page.tsx و register/page.tsx

وظيفة:

Forms للـ login/register (email, password, name).

تستدعي /api/auth/login و /api/auth/register.

بعد النجاح تحفظ cookie من الـ response (server-side) أو تعتمد redirect من الـ API الذي يضع cookie.

توافق: يجب أن الـ API يضع Set-Cookie: token=<jwt>; HttpOnly; Path=/; Max-Age=....

9. /app/dashboard/*/page.tsx (player/owner/employee/admin)

كل صفحة dashboard:

Fetch بيانات خاصة بالدور من endpoints المناسبة (مثال: owner يجلب /api/bookings/list?ownerId=me).

Layout موحد: Sidebar + Main content.

Minimal components: Summary cards, recent bookings table, actions buttons.

واجهة API مقترحة لكل Dashboard:

Player → /api/bookings/list?role=player (returns user's bookings)

Owner → /api/bookings/list?role=owner (owner's fields' bookings + revenues)

Employee → /api/bookings/list?role=employee (bookings for employee.fieldIds)

Admin → /api/admin/stats (manage users & fields)

10. /pages vs /app ملاحظة

بما أنك تستخدم App Router فكل الصفحات في /app. الـ API routes في /app/api أو /api تقنيًا كلاهما ممكن، لكن عادة نستخدم /app/api مع Route Handlers (route.js).

11. /app/api/auth/register/route.ts و /login/route.ts

Register

Validate input.

Hash password (bcrypt).

Create user with role USER.

Sign JWT and Set-Cookie.

Return success.

Login

Find user by email.

Compare password.

Sign JWT, set cookie, return role + redirect url in data (optional).

Request/Response:

Request: { name, email, password }

Response success: { status:'success', message:'', data: { user: { id, name, email, role }, redirect: '/dashboard/player' }}

أخطاء متوقعة:

Email already used -> 409 Conflict.

Weak password -> 400.

12. /app/api/fields/list/route.ts

Feature:

Query params: ?type=soccer&areaId=...&q=...&page=&limit=

Return paginated list with availableSlots for next N days or count.

Prisma Query (تقريبي):

const fields = await prisma.field.findMany({
  where: { type: typeFilter, areaId },
  include: { area: true, owner: { select: { id, name } } },
  take: limit, skip: (page-1)*limit
});


Note: To show availability for a specific day, call GET /api/fields/:id/details?date=YYYY-MM-DD which will:

read FieldSchedule for the field and weekday

for each slotId get if a Booking exists on that date

13. /app/api/fields/create/route.ts & /update/route.ts

Create

Auth: OWNER or ADMIN.

Body: { name, type, pricePerHour, areaId, openHour, closeHour, activeDays: [0..6], phone, description }

Creates Field and optionally calls schedule/generate to create FieldSchedule entries.

Update

Auth: OWNER for own field or ADMIN.

Updatable fields: price, hours, images, area.

If hours change, may need to regenerate schedules (careful with existing bookings).

Security

Validate ownerId matches token user id for non-admin.

14. /app/api/schedule/generate/route.ts

Goal: توليد FieldSchedule لساعات الملعب بين openHour و closeHour وربطها بـ TimeSlot عبر upsert.

Body: { fieldId, startHour, endHour, slotDuration = 1 } أو ببساطة يستخدم Field.openHour/closeHour.

Pseudo Implementation:

loop hours -> create or upsert TimeSlot (label unique) -> create FieldSchedule if not exists (upsert).

return created slots.

Edge cases: ملاعب مفتوحة لمنتصف الليل (مثال 22:00–02:00) تحتاج منطق يتعامل مع دورات التاريخ (نحول closeHour < openHour => عبور لليوم التالي).

15. /app/api/bookings/create/route.ts

المنطق الأساسي:

Input: { fieldId, date: 'YYYY-MM-DD', slotId } أو slotLabel.

Compute startDateTimeUTC = combine(date, timeSlot.start).

diffHours = (startDateTimeUTC - nowUTC) / 3600.

If diffHours < 24 → deposit = 0, create Booking with status CONFIRMED (or create confirmed payment=none).
Else → deposit = field.pricePerHour (أو نسبة) → create Booking with status PENDING and create Payment record PENDING → initiate Paymob auth and return paymentRedirectUrl to frontend.

Use prisma.$transaction to:

check Booking unique constraint

create Booking (or create+payment)

Return success with booking details or payment redirect url.

Concurrency safety:

Wrap availability check + create booking in transaction.

Unique constraint on booking(fieldId,date,slotId) ensures atomic safety; catch unique violation and return error.

Responses:

If immediate confirmed: { status:'success', message:'confirmed', data: { booking } }

If needs payment: { status:'success', message:'pending_payment', data: { bookingId, payUrl } }

16. /app/api/bookings/cancel/route.ts

Inputs: { bookingId, reason? } and identify caller via token.

Checks:

Only the owner of booking (user), owner (if owns field), employee (if assigned to that field), or admin can cancel.

Update Booking: status = CANCELLED, set cancelReason, cancelledBy, cancelledAt.

If payment was SUCCESS: process refund flow (not in MVP) or mark as refunded manually.

Return: updated booking.

17. /app/api/bookings/list/route.ts

Behavior:

Accepts query params: ?role=player|owner|employee&dateFrom&dateTo

For player: returns where: { userId: me }.

For owner: returns bookings where field.ownerId = me.

For employee: returns bookings where fieldId IN employee.fieldIds.

Include: field, slot, payment relations.

18. /app/api/payments/webhook/route.ts

Purpose: استقبال callback/webhook من Paymob عند اكتمال عملية الدفع.

Critical Steps:

Validate provider signature (if Paymob يدعم).

Find Payment by providerTxId (or by bookingId stored in callback).

Verify amount matches.

Update Payment.status = SUCCESS/FAILED.

If success → update Booking status = CONFIRMED and link paymentId.

Wrap in transaction.

Security note: Webhook URL يجب أن يكون سري ومستخدم على مستوى المزود، كما تحقق من IP whitelist إن أمكن.

19. /components/* (Navbar, Sidebar, FieldCard, BookingSlot, UI)

قواعد عامة:

كل component بسيط ووظيفي.

FieldCard يستلم: { id, name, image, pricePerHour, area, features } ويعرض زر "احجز الآن" يوجّه لـ /fields/[id].

BookingSlot يستلم: { slotId, label, status, onClick } ويعرض الحالة بألوان/حالة زر.

كل UI components يجب أن تستخدم prop-types أو TypeScript interfaces واضحة.

20. /components/field/BookingSlot.tsx تفاصيل

Props:

slotId: string, label: string, status: 'available'|'booked'|'cancelled'|'failed', onBook(slotId).

Behavior:

إذا available → زر Book يقوم بصنع request إلى /api/bookings/create.

إظهار feedback loading / success / error.

التعامل مع حالة double-click: تعطّل الزر أثناء الطلب.

21. /context/AuthContext.tsx و BookingContext.tsx

AuthContext:

يخزن user, loading, login, logout.

login() يستدعي /api/auth/login ويخزن بيانات المستخدم في state بعد redirect.

BookingContext (اختياري):

يحفظ آخر حجز قام به المستخدم لتحديث الواجهة فوراً بعد الحجز.

يوفر دالة refreshBookings() تؤدي fetch إلى /api/bookings/list.

22. /seed/seed.ts

محتوى:

Create Areas (3 names).

Create TimeSlots: من 06:00 إلى 23:00 — كل ساعة.

Create test Users: admin, ownerA, ownerB, employeeA, player1, player2.

Create Fields: 2–3 ملاعب لكل owner مع open/close/activeDays.

Create Employee entries with fieldIds arrays.

Create sample Bookings (some confirmed, some cancelled) for test.

تشغيل:

ts-node prisma/seed.ts أو سكربت في package.json: prisma:seed.

23. package.json (نقطة مهمة)

scripts مقترحة:

{
  "dev": "next dev",
  "build": "next build",
  "start": "next start",
  "prisma:generate": "prisma generate",
  "prisma:migrate": "prisma migrate dev",
  "prisma:seed": "ts-node prisma/seed.ts"
}

24. متغيرات البيئة (env)

مطلوب (مثال):

DATABASE_URL=postgresql://user:pass@host:5432/dbname
JWT_SECRET=your_super_secret
NEXT_PUBLIC_API_BASE_URL=https://your.domain.com
PAYMOB_API_KEY=...
PAYMOB_IFRAME_ID=...
PAYMOB_INTEGRATION_ID=...
PAYMOB_CALLBACK_URL=https://your.domain.com/api/payments/webhook


نصيحة: لا تعرض مفاتيح الدفع في الواجهة — استخدم متغيرات بيئة على السيرفر فقط.
